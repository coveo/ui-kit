import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import fs from "node:fs";
import require$$2$2 from "node:path";
import { randomFillSync, randomUUID as randomUUID$1 } from "crypto";
import dayjs from "dayjs";
import quarterOfYear from "dayjs/plugin/quarterOfYear.js";
import customParseFormat from "dayjs/plugin/customParseFormat.js";
import timezone from "dayjs/plugin/timezone.js";
import utc from "dayjs/plugin/utc.js";
import require$$0$4 from "node:os";
import require$$0$3 from "node:events";
import require$$0$1 from "fs";
import require$$1 from "events";
import require$$2 from "util";
import require$$3 from "path";
import require$$5 from "assert";
import require$$2$1 from "worker_threads";
import require$$0$2 from "module";
import require$$4 from "url";
import require$$7 from "buffer";
import escapeHtml$1 from "escape-html";
import express from "express";
import ReactDOMServer from "react-dom/server";
import { NavLink, Outlet, BrowserRouter, Routes, Route } from "react-router";
import { useState, useEffect, Component, createContext, useMemo, useContext, useRef, Fragment as Fragment$1, Children, createRef } from "react";
import { buildSamlClient } from "@coveo/auth";
/**
 * @license
 *
 * Copyright 2025 Coveo Solutions Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *       http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function buildSchemaValidationError(errors2, context) {
  const message = `
  The following properties are invalid:

    ${errors2.join("\n	")}
  
  ${context}
  `;
  return new SchemaValidationError(message);
}
var SchemaValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SchemaValidationError";
  }
};
var Schema = class {
  constructor(definition2) {
    this.definition = definition2;
  }
  validate(values = {}, message = "") {
    const mergedValues = {
      ...this.default,
      ...values
    };
    const errors2 = [];
    for (const property in this.definition) {
      const error = this.definition[property].validate(mergedValues[property]);
      error && errors2.push(`${property}: ${error}`);
    }
    if (errors2.length) {
      throw buildSchemaValidationError(errors2, message);
    }
    return mergedValues;
  }
  get default() {
    const defaultValues = {};
    for (const property in this.definition) {
      const defaultValue = this.definition[property].default;
      if (defaultValue !== void 0) {
        defaultValues[property] = defaultValue;
      }
    }
    return defaultValues;
  }
};
var Value = class {
  constructor(baseConfig = {}) {
    this.baseConfig = baseConfig;
  }
  validate(value) {
    if (this.baseConfig.required && isNullOrUndefined(value)) {
      return "value is required.";
    }
    return null;
  }
  get default() {
    return this.baseConfig.default instanceof Function ? this.baseConfig.default() : this.baseConfig.default;
  }
  get required() {
    return this.baseConfig.required === true;
  }
};
function isUndefined(value) {
  return value === void 0;
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return isUndefined(value) || isNull(value);
}
var BooleanValue = class {
  value;
  constructor(config = {}) {
    this.value = new Value(config);
  }
  validate(value) {
    const valueValidation = this.value.validate(value);
    if (valueValidation) {
      return valueValidation;
    }
    if (!isBooleanOrUndefined(value)) {
      return "value is not a boolean.";
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
function isBooleanOrUndefined(value) {
  return isUndefined(value) || isBoolean$1(value);
}
function isBoolean$1(value) {
  return typeof value === "boolean";
}
var NumberValue = class {
  constructor(config = {}) {
    this.config = config;
    this.value = new Value(config);
  }
  value;
  validate(value) {
    const valueValidation = this.value.validate(value);
    if (valueValidation) {
      return valueValidation;
    }
    if (!isNumberOrUndefined(value)) {
      return "value is not a number.";
    }
    if (value < this.config.min) {
      return `minimum value of ${this.config.min} not respected.`;
    }
    if (value > this.config.max) {
      return `maximum value of ${this.config.max} not respected.`;
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
function isNumberOrUndefined(value) {
  return isUndefined(value) || isNumber(value);
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
var ISODateStringRegex = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i;
var StringValue = class {
  value;
  config;
  constructor(config = {}) {
    this.config = {
      emptyAllowed: true,
      url: false,
      ...config
    };
    this.value = new Value(this.config);
  }
  validate(value) {
    const { emptyAllowed, url, regex, constrainTo, ISODate } = this.config;
    const valueValidation = this.value.validate(value);
    if (valueValidation) {
      return valueValidation;
    }
    if (isUndefined(value)) {
      return null;
    }
    if (!isString(value)) {
      return "value is not a string.";
    }
    if (!emptyAllowed && !value.length) {
      return "value is an empty string.";
    }
    if (url) {
      try {
        new URL(value);
      } catch (_) {
        return "value is not a valid URL.";
      }
    }
    if (regex && !regex.test(value)) {
      return `value did not match provided regex ${regex}`;
    }
    if (constrainTo && !constrainTo.includes(value)) {
      const values = constrainTo.join(", ");
      return `value should be one of: ${values}.`;
    }
    if (ISODate && !(ISODateStringRegex.test(value) && new Date(value).toString() !== "Invalid Date")) {
      return "value is not a valid ISO8601 date string";
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
var RecordValue = class {
  config;
  constructor(config = {}) {
    this.config = {
      options: { required: false },
      values: {},
      ...config
    };
  }
  validate(input) {
    if (isUndefined(input)) {
      return this.config.options.required ? "value is required and is currently undefined" : null;
    }
    if (!isRecord(input)) {
      return "value is not an object";
    }
    for (const [k, v] of Object.entries(this.config.values)) {
      if (v.required && isNullOrUndefined(input[k])) {
        return `value does not contain ${k}`;
      }
    }
    let out = "";
    for (const [key, validator] of Object.entries(this.config.values)) {
      const value = input[key];
      const invalidValue = validator.validate(value);
      if (invalidValue !== null) {
        out += ` ${invalidValue}`;
      }
    }
    return out === "" ? null : out;
  }
  get default() {
    return void 0;
  }
  get required() {
    return !!this.config.options.required;
  }
};
function isRecord(value) {
  return value !== void 0 && typeof value === "object";
}
var ArrayValue = class {
  constructor(config = {}) {
    this.config = config;
    this.value = new Value(this.config);
  }
  value;
  validate(input) {
    if (!isNullOrUndefined(input) && !Array.isArray(input)) {
      return "value is not an array";
    }
    const invalid = this.value.validate(input);
    if (invalid !== null) {
      return invalid;
    }
    if (isNullOrUndefined(input)) {
      return null;
    }
    if (this.config.max !== void 0 && input.length > this.config.max) {
      return `value contains more than ${this.config.max}`;
    }
    if (this.config.min !== void 0 && input.length < this.config.min) {
      return `value contains less than ${this.config.min}`;
    }
    if (this.config.each !== void 0) {
      let out = "";
      input.forEach((el) => {
        if (this.config.each.required && isNullOrUndefined(el)) {
          out = `value is null or undefined: ${input.join(",")}`;
        }
        const isInvalid = this.validatePrimitiveValue(el, this.config.each);
        if (isInvalid !== null) {
          out += ` ${isInvalid}`;
        }
      });
      return out === "" ? null : out;
    }
    return null;
  }
  validatePrimitiveValue(v, validator) {
    if (isBoolean$1(v)) {
      return validator.validate(v);
    } else if (isString(v)) {
      return validator.validate(v);
    } else if (isNumber(v)) {
      return validator.validate(v);
    } else if (isRecord(v)) {
      return validator.validate(v);
    }
    return "value is not a primitive value";
  }
  get default() {
    return void 0;
  }
  get required() {
    return this.value.required;
  }
};
function isArray$2(value) {
  return Array.isArray(value);
}
var EnumValue = class {
  constructor(config) {
    this.config = config;
    this.value = new Value(config);
  }
  value;
  validate(value) {
    const invalid = this.value.validate(value);
    if (invalid !== null) {
      return invalid;
    }
    if (isUndefined(value)) {
      return null;
    }
    const valueInEnum = Object.values(this.config.enum).find(
      (enumValue) => enumValue === value
    );
    if (!valueInEnum) {
      return "value is not in enum.";
    }
    return null;
  }
  get default() {
    return this.value.default;
  }
  get required() {
    return this.value.required;
  }
};
const randomID = (prepend, length = 5) => prepend + Math.random().toString(36).substring(2, 2 + length);
function isArray$1(value) {
  return Array.isArray(value);
}
function removeDuplicates(arr, predicate) {
  return [
    ...arr.reduce((map, item) => {
      const key = predicate(item);
      map.has(key) || map.set(key, item);
      return map;
    }, /* @__PURE__ */ new Map()).values()
  ];
}
function encodedBtoa(stringToEncode) {
  return btoa(encodeURI(stringToEncode));
}
function omit(key, obj) {
  const { [key]: _omitted, ...rest } = obj;
  return rest;
}
function getObjectHash(obj) {
  return encodedBtoa(JSON.stringify(obj));
}
const doNotTrackValues$1 = /* @__PURE__ */ new Set(["1", 1, "yes", true]);
function doNotTrack$1() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  const nav = navigator;
  const win = window;
  return [
    nav.globalPrivacyControl,
    nav.doNotTrack,
    nav.msDoNotTrack,
    win.doNotTrack
  ].some((value) => doNotTrackValues$1.has(value));
}
function fromEntries(values) {
  const newObject = {};
  for (const [key, value] of values) {
    newObject[key] = value;
  }
  return newObject;
}
function resetTimeout(callback, timeoutId, ms) {
  clearTimeout(timeoutId);
  return setTimeout(callback, ms);
}
function clone(value) {
  if (typeof value !== "object") {
    return value;
  }
  if (!value) {
    return value;
  }
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (_) {
    return value;
  }
}
function debounce(func, wait, options2 = {}) {
  let timeoutId;
  return ((...args) => {
    const shouldCallImmediately = options2.isImmediate && !timeoutId;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = void 0;
      if (!options2.isImmediate) {
        func.apply(void 0, args);
      }
    }, wait);
    if (shouldCallImmediately) {
      return func.apply(void 0, args);
    }
  });
}
function getHighlightedSuggestion(suggestion, options2) {
  suggestion = escapeHtml(suggestion);
  return suggestion.replace(/\[(.*?)\]|\{(.*?)\}|\((.*?)\)/g, (part, notMatched, matched, corrected) => {
    if (notMatched) {
      return suggestionWithDelimiters(notMatched, options2.notMatchDelimiters);
    }
    if (matched) {
      return suggestionWithDelimiters(matched, options2.exactMatchDelimiters);
    }
    if (corrected) {
      return suggestionWithDelimiters(corrected, options2.correctionDelimiters);
    }
    return part;
  });
}
function suggestionWithDelimiters(suggestion, delimiters) {
  if (delimiters) {
    return delimiters.open + suggestion + delimiters.close;
  }
  return suggestion;
}
function escapeHtml(str) {
  const mapOfCharToEscape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };
  const source = `(?:${Object.keys(mapOfCharToEscape).join("|")})`;
  const testRegexp = RegExp(source);
  const replaceRegexp = RegExp(source, "g");
  return testRegexp.test(str) ? str.replace(replaceRegexp, (substring) => mapOfCharToEscape[substring]) : str;
}
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
var ControlChars;
(function(ControlChars2) {
  ControlChars2[ControlChars2["NewLine"] = 10] = "NewLine";
  ControlChars2[ControlChars2["CarriageReturn"] = 13] = "CarriageReturn";
  ControlChars2[ControlChars2["Space"] = 32] = "Space";
  ControlChars2[ControlChars2["Colon"] = 58] = "Colon";
})(ControlChars || (ControlChars = {}));
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === ControlChars.NewLine) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case ControlChars.Colon:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case ControlChars.CarriageReturn:
            discardTrailingNewline = true;
            lineEnd = position;
            break;
          case ControlChars.NewLine:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage?.(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field2 = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field2) {
        case "data":
          message.data = message.data ? `${message.data}
${value}` : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          retry$1(value, message, onRetry);
          break;
      }
    }
  };
}
function retry$1(value, message, onRetry) {
  const retry2 = parseInt(value, 10);
  if (!Number.isNaN(retry2)) {
    onRetry(message.retry = retry2);
  }
}
function concat(a, b) {
  const res2 = new Uint8Array(a.length + b.length);
  res2.set(a);
  res2.set(b, a.length);
  return res2;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
const EventStreamContentType = "text/event-stream";
const DefaultRetryInterval = 1e3;
const LastEventId = "last-event-id";
function isBrowser$2() {
  return typeof window !== "undefined";
}
function fetchEventSource(input, { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch, ...rest }) {
  return new Promise((resolve, reject) => {
    const headers = { ...inputHeaders };
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController?.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden && isBrowser$2()) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer;
    function dispose() {
      if (isBrowser$2()) {
        document.removeEventListener("visibilitychange", onVisibilityChange);
      }
      clearTimeout(retryTimer);
      curRequestController?.abort();
    }
    inputSignal?.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const outputFetch = inputFetch ?? fetch;
    const onopen = inputOnOpen ?? defaultOnOpen;
    async function create() {
      curRequestController = AbortController ? new AbortController() : null;
      try {
        const response = await outputFetch(input, {
          ...rest,
          headers,
          signal: curRequestController?.signal
        });
        await onopen(response);
        await getBytes(response.body, getLines(getMessages((id2) => {
          if (id2) {
            headers[LastEventId] = id2;
          } else {
            delete headers[LastEventId];
          }
        }, (retry2) => {
          retryInterval = retry2;
        }, onmessage)));
        onclose?.();
        dispose();
        resolve();
      } catch (err2) {
        if (!curRequestController?.signal?.aborted) {
          try {
            const interval = onerror?.(err2) ?? retryInterval;
            clearTimeout(retryTimer);
            retryTimer = setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType?.startsWith(EventStreamContentType)) {
    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
  }
}
class URLPath {
  _basePath;
  _params = {};
  constructor(basePath2) {
    this._basePath = basePath2;
  }
  addParam(name, value) {
    this._params = {
      ...this.params,
      [name]: value
    };
  }
  get basePath() {
    return this._basePath;
  }
  get params() {
    return this._params;
  }
  get hasParams() {
    return Object.entries(this._params).length;
  }
  get href() {
    return this.hasParams ? `${this.basePath}?${Object.entries(this.params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&")}` : this.basePath;
  }
}
const buildStreamingUrl = (url, orgId, streamId) => new URLPath(`${url}/rest/organizations/${orgId}/machinelearning/streaming/${streamId}`).href;
const MAX_RETRIES = 3;
const MAX_TIMEOUT = 5e3;
const EVENT_STREAM_CONTENT_TYPE = "text/event-stream";
const RETRYABLE_STREAM_ERROR_CODE = 1;
class RetryableError extends Error {
}
class FatalError extends Error {
  payload;
  constructor(payload) {
    super(payload.message);
    this.payload = payload;
  }
}
class TimeoutStateManager {
  timeouts = /* @__PURE__ */ new Set();
  add(timeout) {
    this.timeouts.add(timeout);
  }
  remove(timeout) {
    clearTimeout(timeout);
    this.timeouts.delete(timeout);
  }
  isActive(timeout) {
    return this.timeouts.has(timeout);
  }
}
class GeneratedAnswerAPIClient {
  logger;
  constructor(options2) {
    this.logger = options2.logger;
  }
  streamGeneratedAnswer(params, callbacks) {
    const { url, organizationId, streamId, accessToken } = params;
    const { write, abort, close, resetAnswer: resetAnswer2 } = callbacks;
    const timeoutStateManager = new TimeoutStateManager();
    if (!streamId) {
      this.logger.error("No stream ID found");
      return;
    }
    let retryCount = 0;
    let timeout;
    const retryStream = () => {
      if (timeout && !timeoutStateManager.isActive(timeout)) {
        abortController?.abort();
        resetAnswer2();
        stream();
      }
    };
    const refreshTimeout = () => {
      timeoutStateManager.remove(timeout);
      timeout = resetTimeout(retryStream, timeout, MAX_TIMEOUT);
      timeoutStateManager.add(timeout);
    };
    const abortController = new AbortController();
    const stream = () => fetchEventSource(buildStreamingUrl(url, organizationId, streamId), {
      method: "GET",
      fetch,
      headers: {
        Authorization: `Bearer ${accessToken}`,
        accept: "*/*"
      },
      openWhenHidden: true,
      signal: abortController?.signal,
      async onopen(response) {
        if (response.ok && response.headers.get("content-type") === EVENT_STREAM_CONTENT_TYPE) {
          return;
        }
        const isClientSideError = response.status >= 400 && response.status < 500 && response.status !== 429;
        if (isClientSideError) {
          throw new FatalError({
            message: "Error opening stream",
            code: response.status
          });
        } else {
          throw new RetryableError();
        }
      },
      onmessage: (event) => {
        if (abortController?.signal.aborted) {
          return;
        }
        const data = JSON.parse(event.data);
        if (data.finishReason === "ERROR") {
          timeoutStateManager.remove(timeout);
          abortController?.abort();
          abort({
            message: data.errorMessage,
            code: data.statusCode
          });
          return;
        }
        write(data);
        retryCount = 0;
        if (data.finishReason === "COMPLETED") {
          timeoutStateManager.remove(timeout);
          close();
        } else {
          refreshTimeout();
        }
      },
      onerror: (err2) => {
        if (abortController?.signal.aborted) {
          return;
        }
        timeoutStateManager.remove(timeout);
        if (err2 instanceof FatalError) {
          abortController?.abort();
          abort(err2);
          throw err2;
        }
        if (++retryCount > MAX_RETRIES) {
          this.logger.info("Maximum retry exceeded.");
          const error = {
            message: "Failed to complete stream.",
            code: RETRYABLE_STREAM_ERROR_CODE
          };
          abortController?.abort();
          abort(error);
          throw new FatalError(error);
        }
        this.logger.info(`Retrying...(${retryCount}/${MAX_RETRIES})`);
        resetAnswer2();
      }
    });
    stream();
    return abortController;
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var backoff = {};
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  var __assign = options && options.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(options, "__esModule", { value: true });
  var defaultOptions = {
    delayFirstAttempt: false,
    jitter: "none",
    maxDelay: Infinity,
    numOfAttempts: 10,
    retry: function() {
      return true;
    },
    startingDelay: 100,
    timeMultiple: 2
  };
  function getSanitizedOptions(options2) {
    var sanitized = __assign(__assign({}, defaultOptions), options2);
    if (sanitized.numOfAttempts < 1) {
      sanitized.numOfAttempts = 1;
    }
    return sanitized;
  }
  options.getSanitizedOptions = getSanitizedOptions;
  return options;
}
var delay_factory = {};
var skipFirst_delay = {};
var delay_base = {};
var jitter_factory = {};
var full_jitter = {};
var hasRequiredFull_jitter;
function requireFull_jitter() {
  if (hasRequiredFull_jitter) return full_jitter;
  hasRequiredFull_jitter = 1;
  Object.defineProperty(full_jitter, "__esModule", { value: true });
  function fullJitter(delay) {
    var jitteredDelay = Math.random() * delay;
    return Math.round(jitteredDelay);
  }
  full_jitter.fullJitter = fullJitter;
  return full_jitter;
}
var no_jitter = {};
var hasRequiredNo_jitter;
function requireNo_jitter() {
  if (hasRequiredNo_jitter) return no_jitter;
  hasRequiredNo_jitter = 1;
  Object.defineProperty(no_jitter, "__esModule", { value: true });
  function noJitter(delay) {
    return delay;
  }
  no_jitter.noJitter = noJitter;
  return no_jitter;
}
var hasRequiredJitter_factory;
function requireJitter_factory() {
  if (hasRequiredJitter_factory) return jitter_factory;
  hasRequiredJitter_factory = 1;
  Object.defineProperty(jitter_factory, "__esModule", { value: true });
  var full_jitter_1 = requireFull_jitter();
  var no_jitter_1 = requireNo_jitter();
  function JitterFactory(options2) {
    switch (options2.jitter) {
      case "full":
        return full_jitter_1.fullJitter;
      case "none":
      default:
        return no_jitter_1.noJitter;
    }
  }
  jitter_factory.JitterFactory = JitterFactory;
  return jitter_factory;
}
var hasRequiredDelay_base;
function requireDelay_base() {
  if (hasRequiredDelay_base) return delay_base;
  hasRequiredDelay_base = 1;
  Object.defineProperty(delay_base, "__esModule", { value: true });
  var jitter_factory_1 = requireJitter_factory();
  var Delay = (
    /** @class */
    (function() {
      function Delay2(options2) {
        this.options = options2;
        this.attempt = 0;
      }
      Delay2.prototype.apply = function() {
        var _this = this;
        return new Promise(function(resolve) {
          return setTimeout(resolve, _this.jitteredDelay);
        });
      };
      Delay2.prototype.setAttemptNumber = function(attempt2) {
        this.attempt = attempt2;
      };
      Object.defineProperty(Delay2.prototype, "jitteredDelay", {
        get: function() {
          var jitter = jitter_factory_1.JitterFactory(this.options);
          return jitter(this.delay);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Delay2.prototype, "delay", {
        get: function() {
          var constant = this.options.startingDelay;
          var base = this.options.timeMultiple;
          var power = this.numOfDelayedAttempts;
          var delay = constant * Math.pow(base, power);
          return Math.min(delay, this.options.maxDelay);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
        get: function() {
          return this.attempt;
        },
        enumerable: true,
        configurable: true
      });
      return Delay2;
    })()
  );
  delay_base.Delay = Delay;
  return delay_base;
}
var hasRequiredSkipFirst_delay;
function requireSkipFirst_delay() {
  if (hasRequiredSkipFirst_delay) return skipFirst_delay;
  hasRequiredSkipFirst_delay = 1;
  var __extends = skipFirst_delay && skipFirst_delay.__extends || /* @__PURE__ */ (function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  })();
  var __awaiter2 = skipFirst_delay && skipFirst_delay.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = skipFirst_delay && skipFirst_delay.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f2, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f2 = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(skipFirst_delay, "__esModule", { value: true });
  var delay_base_1 = requireDelay_base();
  var SkipFirstDelay = (
    /** @class */
    (function(_super) {
      __extends(SkipFirstDelay2, _super);
      function SkipFirstDelay2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SkipFirstDelay2.prototype.apply = function() {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
          });
        });
      };
      Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
        get: function() {
          return this.attempt === 0;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
        get: function() {
          return this.attempt - 1;
        },
        enumerable: true,
        configurable: true
      });
      return SkipFirstDelay2;
    })(delay_base_1.Delay)
  );
  skipFirst_delay.SkipFirstDelay = SkipFirstDelay;
  return skipFirst_delay;
}
var always_delay = {};
var hasRequiredAlways_delay;
function requireAlways_delay() {
  if (hasRequiredAlways_delay) return always_delay;
  hasRequiredAlways_delay = 1;
  var __extends = always_delay && always_delay.__extends || /* @__PURE__ */ (function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  })();
  Object.defineProperty(always_delay, "__esModule", { value: true });
  var delay_base_1 = requireDelay_base();
  var AlwaysDelay = (
    /** @class */
    (function(_super) {
      __extends(AlwaysDelay2, _super);
      function AlwaysDelay2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return AlwaysDelay2;
    })(delay_base_1.Delay)
  );
  always_delay.AlwaysDelay = AlwaysDelay;
  return always_delay;
}
var hasRequiredDelay_factory;
function requireDelay_factory() {
  if (hasRequiredDelay_factory) return delay_factory;
  hasRequiredDelay_factory = 1;
  Object.defineProperty(delay_factory, "__esModule", { value: true });
  var skip_first_delay_1 = requireSkipFirst_delay();
  var always_delay_1 = requireAlways_delay();
  function DelayFactory(options2, attempt2) {
    var delay = initDelayClass(options2);
    delay.setAttemptNumber(attempt2);
    return delay;
  }
  delay_factory.DelayFactory = DelayFactory;
  function initDelayClass(options2) {
    if (!options2.delayFirstAttempt) {
      return new skip_first_delay_1.SkipFirstDelay(options2);
    }
    return new always_delay_1.AlwaysDelay(options2);
  }
  return delay_factory;
}
var hasRequiredBackoff;
function requireBackoff() {
  if (hasRequiredBackoff) return backoff;
  hasRequiredBackoff = 1;
  var __awaiter2 = backoff && backoff.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = backoff && backoff.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f2, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f2 = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(backoff, "__esModule", { value: true });
  var options_1 = requireOptions();
  var delay_factory_1 = requireDelay_factory();
  function backOff(request, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return __awaiter2(this, void 0, void 0, function() {
      var sanitizedOptions, backOff2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            sanitizedOptions = options_1.getSanitizedOptions(options2);
            backOff2 = new BackOff(request, sanitizedOptions);
            return [4, backOff2.execute()];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  }
  backoff.backOff = backOff;
  var BackOff = (
    /** @class */
    (function() {
      function BackOff2(request, options2) {
        this.request = request;
        this.options = options2;
        this.attemptNumber = 0;
      }
      BackOff2.prototype.execute = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var e_1, shouldRetry;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!this.attemptLimitReached) return [3, 7];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 4, , 6]);
                return [4, this.applyDelay()];
              case 2:
                _a.sent();
                return [4, this.request()];
              case 3:
                return [2, _a.sent()];
              case 4:
                e_1 = _a.sent();
                this.attemptNumber++;
                return [4, this.options.retry(e_1, this.attemptNumber)];
              case 5:
                shouldRetry = _a.sent();
                if (!shouldRetry || this.attemptLimitReached) {
                  throw e_1;
                }
                return [3, 6];
              case 6:
                return [3, 0];
              case 7:
                throw new Error("Something went wrong.");
            }
          });
        });
      };
      Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
        get: function() {
          return this.attemptNumber >= this.options.numOfAttempts;
        },
        enumerable: true,
        configurable: true
      });
      BackOff2.prototype.applyDelay = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var delay;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                return [4, delay.apply()];
              case 1:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      return BackOff2;
    })()
  );
  return backoff;
}
var backoffExports = requireBackoff();
class UnauthorizedTokenError extends Error {
  constructor() {
    super();
    this.name = "UnauthorizedTokenError";
    this.message = "The token being used to perform the request is unauthorized. It may be expired or invalid.";
  }
}
class DisconnectedError extends Error {
  statusCode;
  constructor(url, statusCode) {
    super();
    this.name = "Disconnected";
    this.message = `Client could not connect to the following URL: ${url}`;
    this.statusCode = statusCode ?? 0;
  }
}
function encodeAsFormUrl(obj) {
  const body = [];
  for (const property in obj) {
    const key = encodeURIComponent(property);
    const value = encodeURIComponent(obj[property]);
    body.push(`${key}=${value}`);
  }
  return body.join("&");
}
function canBeFormUrlEncoded(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (!obj) {
    return false;
  }
  return Object.values(obj).every(isPrimitive);
}
function isPrimitive(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
}
function isThrottled(status) {
  return status === 429;
}
class PlatformClient {
  static async call(options2) {
    const defaultRequestOptions = buildDefaultRequestOptions(options2);
    const { logger } = options2;
    const requestInfo = await PlatformClient.preprocessRequest(defaultRequestOptions, options2);
    logger.info(requestInfo, "Platform request");
    const { url, ...requestData } = requestInfo;
    const request = async () => {
      const response = await fetch(url, requestData);
      if (isThrottled(response.status)) {
        throw response;
      }
      return response;
    };
    try {
      const response = await backoffExports.backOff(request, {
        startingDelay: 100,
        timeMultiple: 2,
        maxDelay: 800,
        numOfAttempts: 4,
        jitter: "full",
        retry: async (e) => {
          const shouldRetry = e && isThrottled(e.status);
          if (shouldRetry) {
            logger.info("Platform retrying request");
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
          return shouldRetry;
        }
      });
      switch (response.status) {
        case 419:
        case 401:
          logger.info("Platform renewing token");
          throw new UnauthorizedTokenError();
        case 404:
          throw new DisconnectedError(url, response.status);
        default:
          logger.info({ response, requestInfo }, "Platform response");
          return response;
      }
    } catch (error) {
      if (error.message === "Failed to fetch") {
        return new DisconnectedError(url);
      }
      return error;
    }
  }
  static async preprocessRequest(defaultRequestOptions, options2) {
    const { origin, preprocessRequest, logger, requestMetadata } = options2;
    const { signal: _signal, ...withoutSignal } = defaultRequestOptions;
    const untaintedOutput = clone(withoutSignal);
    try {
      const processedRequest = await preprocessRequest(defaultRequestOptions, origin, requestMetadata);
      return {
        ...defaultRequestOptions,
        ...processedRequest
      };
    } catch (e) {
      logger.error(e, "Platform request preprocessing failed. Returning default request options.");
    }
    return untaintedOutput;
  }
}
function getOrganizationEndpoint(organizationId, environment = "prod", endpointType = "platform") {
  const environmentSuffix = environment === "prod" ? "" : environment;
  const endpointTypePart = endpointType === "platform" ? "" : `.${endpointType}`;
  return `https://${organizationId}${endpointTypePart}.org${environmentSuffix}.coveo.com`;
}
function getSearchApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(organizationId, environment);
  return `${organizationEndpoint}/rest/search/v2`;
}
function getAnalyticsNextApiBaseUrl(organizationId, environment = "prod") {
  const organizationEndpoint = getOrganizationEndpoint(organizationId, environment, "analytics");
  return `${organizationEndpoint}/rest/organizations/${organizationId}/events/v1`;
}
function buildDefaultRequestOptions(options2) {
  const { url, method, requestParams, contentType, accessToken, signal } = options2;
  const isMethodWithBody = options2.method === "POST" || options2.method === "PUT";
  const body = encodeBody(requestParams, contentType);
  return {
    url,
    method,
    headers: {
      "Content-Type": contentType,
      Authorization: `Bearer ${accessToken}`,
      ...options2.headers
    },
    ...isMethodWithBody && { body },
    signal
  };
}
function encodeBody(body, contentType) {
  if (contentType === "application/x-www-form-urlencoded") {
    return canBeFormUrlEncoded(body) ? encodeAsFormUrl(body) : "";
  }
  return JSON.stringify(body);
}
const NoopPreprocessRequest = (request) => request;
function emptyQuestionAnswer() {
  return {
    answerSnippet: "",
    documentId: {
      contentIdKey: "",
      contentIdValue: ""
    },
    question: "",
    relatedQuestions: [],
    score: 0
  };
}
function getSearchInitialState() {
  return {
    response: {
      results: [],
      searchUid: "",
      totalCountFiltered: 0,
      facets: [],
      generateAutomaticFacets: { facets: [] },
      queryCorrections: [],
      triggers: [],
      questionAnswer: emptyQuestionAnswer(),
      pipeline: "",
      splitTestRun: "",
      termsToHighlight: {},
      phrasesToHighlight: {},
      extendedResults: {}
    },
    duration: 0,
    queryExecuted: "",
    error: null,
    automaticallyCorrected: false,
    isLoading: false,
    results: [],
    searchResponseId: "",
    requestId: "",
    questionAnswer: emptyQuestionAnswer(),
    extendedResults: {},
    searchAction: void 0
  };
}
function pickNonBaseParams(req2) {
  const { url: _url, accessToken: _accessToken, organizationId: _organizationId, authentication: _authentication, ...nonBase } = req2;
  return nonBase;
}
const unwrapError = (payload) => {
  const { response } = payload;
  if (response.body) {
    return unwrapSearchApiError(payload);
  }
  return unwrapClientError(response);
};
const unwrapSearchApiError = (payload) => {
  if (isSearchAPIException(payload)) {
    return unwrapErrorByException(payload);
  }
  if (isSearchAPIErrorWithStatusCode(payload)) {
    return payload.body;
  }
  return { message: "unknown", statusCode: 0, type: "unknown" };
};
const unwrapClientError = (response) => {
  const body = JSON.parse(JSON.stringify(response, Object.getOwnPropertyNames(response)));
  return {
    ...body,
    message: `Client side error: ${body.message || ""}`,
    statusCode: 400,
    type: "ClientError"
  };
};
function isSearchAPIErrorWithStatusCode(r) {
  return r.body.statusCode !== void 0;
}
function isSearchAPIException(r) {
  return r.body.exception !== void 0;
}
const unwrapErrorByException = (res2) => ({
  message: res2.body.exception.code,
  statusCode: res2.response.status,
  type: res2.body.exception.code
});
class APICallsQueue {
  currentAbortController = null;
  /**
   * Enqueue an API call so that it can get cancelled if another call is enqueued before it finishes.
   */
  async enqueue(call, options2) {
    const lastAbortController = this.currentAbortController;
    this.currentAbortController = new AbortController();
    const abortController = this.currentAbortController;
    if (lastAbortController) {
      if (options2.warnOnAbort) {
        options2.logger.warn("Cancelling current pending search query");
      }
      lastAbortController.abort();
    }
    try {
      return await call(abortController?.signal ?? null);
    } finally {
      if (this.currentAbortController === abortController) {
        this.currentAbortController = null;
      }
    }
  }
}
function findEncoding(response) {
  const contentType = response.headers.get("content-type") || "";
  const charset = contentType.split(";").find((part) => part.indexOf("charset=") !== -1) || "";
  return charset.split("=")[1] || "UTF-8";
}
const baseSearchRequest = (req2, method, contentType, path) => {
  const url = new URLPath(`${req2.url}${path}`);
  url.addParam("organizationId", req2.organizationId);
  if (req2.authentication) {
    url.addParam("authentication", req2.authentication);
  }
  return {
    accessToken: req2.accessToken,
    method,
    contentType,
    url: url.href,
    origin: "searchApiFetch"
  };
};
const buildContentURL = (req2, path) => {
  const url = new URLPath(`${req2.url}${path}`);
  url.addParam("access_token", req2.accessToken);
  url.addParam("organizationId", req2.organizationId);
  url.addParam("uniqueId", req2.uniqueId);
  if (req2.authentication) {
    url.addParam("authentication", req2.authentication);
  }
  if (req2.q !== void 0) {
    url.addParam("q", req2.q);
  }
  if (req2.enableNavigation !== void 0) {
    url.addParam("enableNavigation", `${req2.enableNavigation}`);
  }
  if (req2.requestedOutputSize !== void 0) {
    url.addParam("requestedOutputSize", `${req2.requestedOutputSize}`);
  }
  return url.href;
};
const getHtml = async (req2, options2) => {
  const response = await PlatformClient.call({
    ...baseSearchRequest(req2, "POST", "application/x-www-form-urlencoded", "/html"),
    requestParams: pickNonBaseParams(req2),
    requestMetadata: { method: "html" },
    ...options2
  });
  if (response instanceof Error) {
    throw response;
  }
  const encoding = findEncoding(response);
  const buffer = await response.arrayBuffer();
  const decoder = new TextDecoder(encoding);
  const body = decoder.decode(buffer);
  if (isSuccessHtmlResponse(body)) {
    return { success: body };
  }
  return { error: unwrapError({ response, body }) };
};
function isSuccessHtmlResponse(body) {
  return typeof body === "string";
}
function buildDisconnectedError(error) {
  return {
    statusCode: error.statusCode,
    type: error.name,
    message: error.message
  };
}
function buildIgnoredAbortedError(error) {
  return {
    statusCode: error.code,
    type: error.name,
    message: error.message,
    ignored: true
  };
}
function buildAPIResponseFromErrorOrThrow(error, disableAbortWarning) {
  if (disableAbortWarning && error.name === "AbortError") {
    return {
      error: buildIgnoredAbortedError(error)
    };
  }
  if (error instanceof DisconnectedError) {
    return { error: buildDisconnectedError(error) };
  }
  throw error;
}
class SearchAPIClient {
  options;
  constructor(options2) {
    this.options = options2;
  }
  async plan(req2) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req2, "POST", "application/json", "/plan"),
      requestParams: pickNonBaseParams(req2),
      requestMetadata: { method: "plan" },
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    if (isSuccessPlanResponse(body)) {
      return { success: body };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
  async querySuggest(req2) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req2, "POST", "application/json", "/querySuggest"),
      requestMetadata: { method: "querySuggest" },
      requestParams: pickNonBaseParams(req2),
      ...this.options
    });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    const payload = { response, body };
    if (isSuccessQuerySuggestionsResponse(body)) {
      const processedResponse = await this.options.postprocessQuerySuggestResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError(payload)
    };
  }
  apiCallsQueues = {
    unknown: new APICallsQueue(),
    mainSearch: new APICallsQueue(),
    facetValues: new APICallsQueue(),
    foldingCollection: new APICallsQueue(),
    instantResults: new APICallsQueue()
  };
  async search(req2, options2) {
    const origin = options2?.origin ?? "unknown";
    const response = await this.apiCallsQueues[origin].enqueue((signal) => PlatformClient.call({
      ...baseSearchRequest(req2, "POST", "application/json", ""),
      requestParams: pickNonBaseParams(req2),
      requestMetadata: { method: "search", origin: options2?.origin },
      ...this.options,
      signal: signal ?? void 0
    }), { logger: this.options.logger, warnOnAbort: !options2?.disableAbortWarning });
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response, options2?.disableAbortWarning);
    }
    const body = await response.json();
    const payload = { response, body };
    if (isSuccessSearchResponse(body)) {
      payload.body = shimResponse(body);
      const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError(payload)
    };
  }
  async facetSearch(req2) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req2, "POST", "application/json", "/facet"),
      requestParams: pickNonBaseParams(req2),
      requestMetadata: { method: "facetSearch" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    const payload = { response, body };
    const processedResponse = await this.options.postprocessFacetSearchResponseMiddleware(payload);
    return processedResponse.body;
  }
  async recommendations(req2) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req2, "POST", "application/json", ""),
      requestParams: pickNonBaseParams(req2),
      requestMetadata: { method: "recommendations" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    if (isSuccessSearchResponse(body)) {
      const payload = { response, body };
      payload.body = shimResponse(body);
      const processedResponse = await this.options.postprocessSearchResponseMiddleware(payload);
      return {
        success: processedResponse.body
      };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
  async html(req2) {
    return getHtml(req2, { ...this.options });
  }
  async fieldDescriptions(req2) {
    const response = await PlatformClient.call({
      ...baseSearchRequest(req2, "GET", "application/json", "/fields"),
      requestParams: {},
      requestMetadata: { method: "fieldDescriptions" },
      ...this.options
    });
    if (response instanceof Error) {
      throw response;
    }
    const body = await response.json();
    if (isSuccessFieldsDescriptionResponse(body)) {
      return { success: body };
    }
    return {
      error: unwrapError({ response, body })
    };
  }
}
const isSuccessResponse = (r) => {
  return r.success !== void 0;
};
const isErrorResponse$1 = (r) => {
  return r.error !== void 0;
};
function isSuccessSearchResponse(body) {
  return body.results !== void 0;
}
function shimResponse(response) {
  const empty = emptyQuestionAnswer();
  if (isNullOrUndefined(response.questionAnswer)) {
    response.questionAnswer = empty;
    return response;
  }
  response.questionAnswer = { ...empty, ...response.questionAnswer };
  return response;
}
function isSuccessQuerySuggestionsResponse(body) {
  return body.completions !== void 0;
}
function isSuccessPlanResponse(body) {
  return body.preprocessingOutput !== void 0;
}
function isSuccessFieldsDescriptionResponse(body) {
  return body.fields !== void 0;
}
const NoopPostprocessSearchResponseMiddleware = (response) => response;
const NoopPostprocessFacetSearchResponseMiddleware = (response) => response;
const NoopPostprocessQuerySuggestResponseMiddleware = (response) => response;
const requiredNonEmptyString = new StringValue({
  required: true,
  emptyAllowed: false
});
const nonEmptyString = new StringValue({
  required: false,
  emptyAllowed: false
});
const requiredEmptyAllowedString = new StringValue({
  required: true,
  emptyAllowed: true
});
const nonRequiredEmptyAllowedString = new StringValue({
  required: false,
  emptyAllowed: true
});
const nonEmptyStringArray = new ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
const optionalNonEmptyVersionString = new StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^\d+\.\d+\.\d+$/
});
const optionalTrackingId = new StringValue({
  required: false,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
const requiredTrackingId = new StringValue({
  required: true,
  emptyAllowed: false,
  regex: /^[a-zA-Z0-9_\-.]{1,100}$/
});
const serializeSchemaValidationError = ({ message, name, stack }) => ({ message, name, stack });
const validatePayloadAndThrow = (payload, definition2) => {
  const isSchemaValue = "required" in definition2;
  if (isSchemaValue) {
    return {
      payload: new Schema({
        value: definition2
      }).validate({ value: payload }).value
    };
  }
  const asRecordValue = new RecordValue({
    options: { required: true },
    values: definition2
  });
  const isInvalid = asRecordValue.validate(payload);
  if (isInvalid) {
    throw new SchemaValidationError(isInvalid);
  }
  return { payload };
};
const validatePayload = (payload, definition2) => {
  try {
    return validatePayloadAndThrow(payload, definition2);
  } catch (error) {
    return {
      payload,
      error: serializeSchemaValidationError(error)
    };
  }
};
const validateInitialState = (engine, schema, obj, functionName) => {
  const message = `Check the initialState of ${functionName}`;
  return validateObject(engine, schema, obj, message, "Controller initialization error");
};
const validateOptions = (engine, schema, obj, functionName) => {
  const message = `Check the options of ${functionName}`;
  return validateObject(engine, schema, obj, message, "Controller initialization error");
};
const validateObject = (engine, schema, obj, validationMessage, errorMessage) => {
  try {
    return schema.validate(obj, validationMessage);
  } catch (error) {
    engine.logger.error(error, errorMessage);
    throw error;
  }
};
function formatProdErrorMessage$1(code) {
  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject$1(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (process.env.NODE_ENV !== "production") {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore$1(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore$1)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$1(action)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject$1(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach((key) => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE)
    return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState2 = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (process.env.NODE_ENV !== "production") {
      if (typeof reducers[key] === "undefined") {
        warning(`No reducer provided for key "${key}"`);
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (process.env.NODE_ENV !== "production") {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (process.env.NODE_ENV !== "production") {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState) => {
    const store = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage$1(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject$1(action) && "type" in action && typeof action.type === "string";
}
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (process.env.NODE_ENV !== "production") {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto2 = getPrototypeOf(value);
  if (proto2 === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value))
    die(15, value);
  return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain2 = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain2) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto2 = getPrototypeOf(base);
    if (proto2 !== null && isPlain2) {
      return { ...base };
    }
    const obj = Object.create(proto2);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: { value: dontMutateFrozenCollections },
      add: { value: dontMutateFrozenCollections },
      clear: { value: dontMutateFrozenCollections },
      delete: { value: dontMutateFrozenCollections }
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey])
    plugins[pluginKey] = implementation;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (process.env.NODE_ENV !== "production" && childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res2 = finalize(rootScope, childValue, path);
    set(targetObject, prop, res2);
    if (isDraft(res2)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray2 = Array.isArray(base);
  const state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray2) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto2 = getPrototypeOf(source);
  while (proto2) {
    const desc = Object.getOwnPropertyDescriptor(proto2, prop);
    if (desc)
      return desc;
    proto2 = getPrototypeOf(proto2);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
function enablePatches() {
  const errorOffset = 16;
  if (process.env.NODE_ENV !== "production") {
    errors.push(
      'Sets cannot have "replace" patches.',
      function(op) {
        return "Unsupported patch operation: " + op;
      },
      function(path) {
        return "Cannot apply patch, path doesn't resolve: " + path;
      },
      "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    );
  }
  const REPLACE = "replace";
  const ADD = "add";
  const REMOVE = "remove";
  function generatePatches_(state, basePath2, patches, inversePatches) {
    switch (state.type_) {
      case 0:
      case 2:
        return generatePatchesFromAssigned(
          state,
          basePath2,
          patches,
          inversePatches
        );
      case 1:
        return generateArrayPatches(state, basePath2, patches, inversePatches);
      case 3:
        return generateSetPatches(
          state,
          basePath2,
          patches,
          inversePatches
        );
    }
  }
  function generateArrayPatches(state, basePath2, patches, inversePatches) {
    let { base_, assigned_ } = state;
    let copy_ = state.copy_;
    if (copy_.length < base_.length) {
      [base_, copy_] = [copy_, base_];
      [patches, inversePatches] = [inversePatches, patches];
    }
    for (let i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        const path = basePath2.concat([i]);
        patches.push({
          op: REPLACE,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    }
    for (let i = base_.length; i < copy_.length; i++) {
      const path = basePath2.concat([i]);
      patches.push({
        op: ADD,
        path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i])
      });
    }
    for (let i = copy_.length - 1; base_.length <= i; --i) {
      const path = basePath2.concat([i]);
      inversePatches.push({
        op: REMOVE,
        path
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath2, patches, inversePatches) {
    const { base_, copy_ } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get(base_, key);
      const value = get(copy_, key);
      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE)
        return;
      const path = basePath2.concat(key);
      patches.push(op === REMOVE ? { op, path } : { op, path, value });
      inversePatches.push(
        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
      );
    });
  }
  function generateSetPatches(state, basePath2, patches, inversePatches) {
    let { base_, copy_ } = state;
    let i = 0;
    base_.forEach((value) => {
      if (!copy_.has(value)) {
        const path = basePath2.concat([i]);
        patches.push({
          op: REMOVE,
          path,
          value
        });
        inversePatches.unshift({
          op: ADD,
          path,
          value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach((value) => {
      if (!base_.has(value)) {
        const path = basePath2.concat([i]);
        patches.push({
          op: ADD,
          path,
          value
        });
        inversePatches.unshift({
          op: REMOVE,
          path,
          value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach((patch) => {
      const { path, op } = patch;
      let base = draft;
      for (let i = 0; i < path.length - 1; i++) {
        const parentType = getArchtype(base);
        let p = path[i];
        if (typeof p !== "string" && typeof p !== "number") {
          p = "" + p;
        }
        if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
          die(errorOffset + 3);
        if (typeof base === "function" && p === "prototype")
          die(errorOffset + 3);
        base = get(base, p);
        if (typeof base !== "object")
          die(errorOffset + 2, path.join("/"));
      }
      const type = getArchtype(base);
      const value = deepClonePatchValue(patch.value);
      const key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2:
              return base.set(key, value);
            case 3:
              die(errorOffset);
            default:
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2:
              return base.set(key, value);
            case 3:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1:
              return base.splice(key, 1);
            case 2:
              return base.delete(key);
            case 3:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(errorOffset + 1, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj))
      return obj;
    if (Array.isArray(obj))
      return obj.map(deepClonePatchValue);
    if (isMap(obj))
      return new Map(
        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
      );
    if (isSet(obj))
      return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj)
      cloned[key] = deepClonePatchValue(obj[key]);
    if (has(obj, DRAFTABLE))
      cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else
      return obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(
  immer
);
var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ({ stack } = e);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options2, inputSelectorArgs) => {
  const { memoize, memoizeOptions } = options2;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e) {
      ({ stack } = e);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options2 = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options2;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = lastResult?.deref?.() ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (process.env.NODE_ENV !== "production") {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var hasMatchFunction = (v) => {
  return v && typeof v.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(0) : "prepareAction did not return an object");
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options2 = {}) {
  if (process.env.NODE_ENV === "production") {
    return () => (next) => (action) => next(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options2;
  return () => (next) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next(action);
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn) {
      const started = Date.now();
      try {
        return fn();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map, key, compute) {
  if (map.has(key)) return map.get(key);
  return map.set(key, compute(key)).get(key);
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (let key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (let key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key in keysToDetect) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware(options2 = {}) {
  if (process.env.NODE_ENV === "production") {
    return () => (next) => (action) => next(action);
  } else {
    let stringify2 = function(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
    }, getSerialize2 = function(serializer, decycler) {
      let stack = [], keys2 = [];
      if (!decycler) decycler = function(_, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys2.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys2.splice(thisPos, Infinity, key) : keys2.push(key);
          if (~stack.indexOf(value)) value = decycler.call(this, key, value);
        } else stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
      };
    };
    let {
      isImmutable = isImmutableDefault,
      ignoredPaths,
      warnAfter = 32
    } = options2;
    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return ({
      getState
    }) => {
      let state = getState();
      let tracker = track(state);
      let result;
      return (next) => (action) => {
        const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        const dispatchedAction = next(action);
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  }
}
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject$1(val);
}
function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache2) {
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache2?.has(value)) return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache2);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache2 && isNestedFrozen(value)) cache2.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value)) return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null) continue;
    if (!isNestedFrozen(nestedValue)) return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options2 = {}) {
  if (process.env.NODE_ENV === "production") {
    return () => (next) => (action) => next(action);
  } else {
    const {
      isSerializable = isPlain,
      getEntries,
      ignoredActions = [],
      ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths = [],
      warnAfter = 32,
      ignoreState = false,
      ignoreActions = false,
      disableCache = false
    } = options2;
    const cache2 = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (storeAPI) => (next) => (action) => {
      if (!isAction(action)) {
        return next(action);
      }
      const result = next(action);
      const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
        measureUtils.measureTime(() => {
          const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache2);
          if (foundActionNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundActionNonSerializableValue;
            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
          }
        });
      }
      if (!ignoreState) {
        measureUtils.measureTime(() => {
          const state = storeAPI.getState();
          const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache2);
          if (foundStateNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundStateNonSerializableValue;
            console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        });
        measureUtils.warnIfExceeded();
      }
      return result;
    };
  }
}
function isBoolean(x) {
  return typeof x === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options2) {
  const {
    thunk: thunk$1 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options2 ?? {};
  let middlewareArray = new Tuple();
  if (thunk$1) {
    if (isBoolean(thunk$1)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
    }
  }
  if (process.env.NODE_ENV !== "production") {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = () => (payload) => ({
  payload,
  meta: {
    [SHOULD_AUTOBATCH]: true
  }
});
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options2 = {
  type: "raf"
}) => (next) => (...args) => {
  const store = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options2.type === "tick" ? queueMicrotask : options2.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options2.type === "callback" ? options2.queueNotification : createQueueWithTimer(options2.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l) => l());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      try {
        notifying = !action?.meta?.[SHOULD_AUTOBATCH];
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options2) {
  const {
    autoBatch = true
  } = options2 ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore$1(options2) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options2 || {};
  let rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$1(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  }
  if (process.env.NODE_ENV !== "production" && middleware && typeof middleware !== "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
    if (process.env.NODE_ENV !== "production" && !Array.isArray(finalMiddleware)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (process.env.NODE_ENV !== "production" && finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: process.env.NODE_ENV !== "production",
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (process.env.NODE_ENV !== "production" && enhancers && typeof enhancers !== "function") {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
  }
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (process.env.NODE_ENV !== "production" && !Array.isArray(storeEnhancers)) {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
  }
  if (process.env.NODE_ENV !== "production" && storeEnhancers.some((item) => typeof item !== "function")) {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
  }
  if (process.env.NODE_ENV !== "production" && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore$1(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (actionMatchers.length > 0) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState2, mapOrBuilderCallback) {
  if (process.env.NODE_ENV !== "production") {
    if (typeof mapOrBuilderCallback === "object") {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    }
  }
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = () => freezeDraftable(initialState2());
  } else {
    const frozenInitialState = freezeDraftable(initialState2);
    getInitialState = () => frozenInitialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer2
    }) => reducer2)];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers) {
  return (action) => {
    return matchers.some((matcher) => matches(matcher, action));
  };
}
function isAllOf(...matchers) {
  return (action) => {
    return matchers.every((matcher) => matches(matcher, action));
  };
}
function hasExpectedRequestMetadata(action, validStatus) {
  if (!action || !action.meta) return false;
  const hasValidRequestId = typeof action.meta.requestId === "string";
  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
  return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a) {
  return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
}
function isPending(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["pending"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isPending()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));
}
function isRejected(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejected()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));
}
function isRejectedWithValue(...asyncThunks) {
  const hasFlag = (action) => {
    return action && action.meta && action.meta.rejectedWithValue;
  };
  if (asyncThunks.length === 0) {
    return isAllOf(isRejected(...asyncThunks), hasFlag);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejectedWithValue()(asyncThunks[0]);
  }
  return isAllOf(isRejected(...asyncThunks), hasFlag);
}
function isFulfilled(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["fulfilled"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isFulfilled()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));
}
function isAsyncThunkAction(...asyncThunks) {
  if (asyncThunks.length === 0) {
    return (action) => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isAsyncThunkAction()(asyncThunks[0]);
  }
  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
  let id2 = "";
  let i = size;
  while (i--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class {
  constructor(payload, meta2) {
    this.payload = payload;
    this.meta = meta2;
  }
  /*
  type-only property to distinguish between RejectWithValue and FulfillWithMeta
  does not exist at runtime
  */
  _type;
};
var FulfillWithMeta = class {
  constructor(payload, meta2) {
    this.payload = payload;
    this.meta = meta2;
  }
  /*
  type-only property to distinguish between RejectWithValue and FulfillWithMeta
  does not exist at runtime
  */
  _type;
};
var miniSerializeError = (value) => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
var createAsyncThunk = /* @__PURE__ */ (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options2) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta2) => ({
      payload,
      meta: {
        ...meta2 || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta2) => ({
      payload: void 0,
      meta: {
        ...meta2 || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta2) => ({
      payload,
      error: (options2 && options2.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...meta2 || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: error?.name === "AbortError",
        condition: error?.name === "ConditionError"
      }
    }));
    function actionCreator(arg) {
      return (dispatch, getState, extra) => {
        const requestId = options2?.idGenerator ? options2.idGenerator(arg) : nanoid();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        const promise = (async function() {
          let finalAction;
          try {
            let conditionResult = options2?.condition?.(arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, options2?.getPendingMeta?.({
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta2) => {
                return new RejectWithValue(value, meta2);
              },
              fulfillWithValue: (value, meta2) => {
                return new FulfillWithMeta(value, meta2);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err2) {
            finalAction = err2 instanceof RejectWithValue ? rejected(null, requestId, arg, err2.payload, err2.meta) : rejected(err2, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options2 && !options2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        })();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function getType(slice, actionKey) {
  return `${slice}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
  return function createSlice2(options2) {
    const {
      name,
      reducerPath = name
    } = options2;
    if (!name) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
    }
    if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
      if (options2.initialState === void 0) {
        console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
      }
    }
    const reducers = (typeof options2.reducers === "function" ? options2.reducers(buildReducerCreators()) : options2.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer2) {
        context.sliceCaseReducersByName[name2] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options2.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (process.env.NODE_ENV !== "production") {
        if (typeof options2.extraReducers === "object") {
          throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options2.extraReducers === "function" ? executeReducerBuilderCallback(options2.extraReducers) : [options2.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options2.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m of actionMatchers) {
          builder.addMatcher(m.matcher, m.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          } else if (process.env.NODE_ENV !== "production") {
            throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map = {};
          for (const [name2, selector] of Object.entries(options2.selectors ?? {})) {
            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);
          }
          return map;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice = {
      name,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config);
        return {
          ...slice,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (process.env.NODE_ENV !== "production") {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options: options2
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options2);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop,
    pending: pending || noop,
    rejected: rejected || noop,
    settled: settled || noop
  });
}
function noop() {
}
function formatProdErrorMessage(code) {
  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
const REGEX$1 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function validate$2(uuid) {
  return typeof uuid === "string" && REGEX$1.test(uuid);
}
const byteToHex$1 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex$1.push((i + 256).toString(16).slice(1));
}
function unsafeStringify$1(arr, offset = 0) {
  return (byteToHex$1[arr[offset + 0]] + byteToHex$1[arr[offset + 1]] + byteToHex$1[arr[offset + 2]] + byteToHex$1[arr[offset + 3]] + "-" + byteToHex$1[arr[offset + 4]] + byteToHex$1[arr[offset + 5]] + "-" + byteToHex$1[arr[offset + 6]] + byteToHex$1[arr[offset + 7]] + "-" + byteToHex$1[arr[offset + 8]] + byteToHex$1[arr[offset + 9]] + "-" + byteToHex$1[arr[offset + 10]] + byteToHex$1[arr[offset + 11]] + byteToHex$1[arr[offset + 12]] + byteToHex$1[arr[offset + 13]] + byteToHex$1[arr[offset + 14]] + byteToHex$1[arr[offset + 15]]).toLowerCase();
}
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng$1() {
  if (poolPtr > rnds8Pool.length - 16) {
    randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const native$1 = { randomUUID: randomUUID$1 };
function v4$1(options2, buf, offset) {
  if (native$1.randomUUID && true && !options2) {
    return native$1.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random ?? options2.rng?.() ?? rng$1();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify$1(rnds);
}
function createExplorerMessenger() {
  const isBrowser2 = typeof window !== "undefined";
  return {
    sendMessage(message) {
      isBrowser2 && window.postMessage(message, "*");
    }
  };
}
function emit({ config, environment, event, listenerManager }) {
  const { url, token, mode } = config;
  const isEnabled = mode !== "disabled";
  if (isEnabled) {
    listenerManager.call(event);
    environment.send(url, token, event);
  }
}
const clientIdKey = "visitorId";
function createClientIdManager(environmentManager) {
  return {
    getClientId: () => {
      const environment = environmentManager.get();
      const storage = environment.storage;
      const existingClientId = storage.getItem(clientIdKey);
      const clientId = existingClientId && validate$2(existingClientId) ? existingClientId : environment.generateUUID();
      storage.setItem(clientIdKey, clientId);
      return clientId;
    }
  };
}
const version$1 = "1.2.7";
const UTF8_HIGH_BIT$1 = 128;
const UTF8_HEADER_2$1 = 192;
const UTF8_HEADER_3$1 = 224;
const UTF8_HEADER_4$1 = 240;
const UTF8_HEADER_4_MASK = 248;
function utf8ByteCountFromFirstByte$1(firstByte) {
  if ((firstByte & UTF8_HEADER_4_MASK) === UTF8_HEADER_4$1) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_4$1) === UTF8_HEADER_3$1) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_3$1) === UTF8_HEADER_2$1) {
    return 2;
  }
  return 1;
}
function truncateUrl$1(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT$1) != UTF8_HIGH_BIT$1) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_2$1) != UTF8_HIGH_BIT$1) {
      if (limit - end >= utf8ByteCountFromFirstByte$1(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
function getEventConfig(config) {
  const { trackingId } = config;
  return { trackingId };
}
function getSource(config) {
  return (config.source || []).concat([`relay@${version$1}`]);
}
function createMeta(type, config, environment, clientIdManager) {
  const { getReferrer: getReferrer2, getLocation, getUserAgent } = environment;
  const eventConfig = getEventConfig(config);
  const clientId = clientIdManager.getClientId();
  return Object.freeze({
    type,
    config: eventConfig,
    ts: Date.now(),
    source: getSource(config),
    clientId,
    userAgent: getUserAgent(),
    referrer: truncate(getReferrer2()),
    location: truncate(getLocation())
  });
}
function truncate(url) {
  const limit = 1024;
  return url !== null ? truncateUrl$1(url, limit) : null;
}
function createRelayEvent(type, payload, config, environment, clientIdManager) {
  return {
    ...payload,
    meta: createMeta(type, config, environment, clientIdManager)
  };
}
const ANY_EVENT_TYPE = "*";
function createListenerManager() {
  const listeners = [];
  function getListenerIndex({ type, callback }) {
    return listeners.findIndex((listener) => listener.type === type && listener.callback === callback);
  }
  function isMatchesType(listener, type) {
    return listener.type === "*" || type === listener.type;
  }
  function add(listener) {
    if (getListenerIndex(listener) < 0) {
      listeners.push(listener);
    }
    return () => remove(listener.type, listener.callback);
  }
  function call(event) {
    listeners.forEach((listener) => {
      if (isMatchesType(listener, event.meta.type)) {
        try {
          listener.callback(event);
        } catch (e) {
          console.error(e);
        }
      }
    });
  }
  function removeMultiple(type) {
    if (type === ANY_EVENT_TYPE) {
      listeners.length = 0;
    } else {
      for (let i = listeners.length - 1; i >= 0; i--) {
        if (listeners[i].type === type) {
          listeners.splice(i, 1);
        }
      }
    }
  }
  function removeOne(listener) {
    const index = getListenerIndex(listener);
    if (index >= 0) {
      listeners.splice(index, 1);
    }
  }
  function remove(type, callback) {
    if (callback) {
      removeOne({ type, callback });
    } else {
      removeMultiple(type);
    }
  }
  return {
    add,
    call,
    remove
  };
}
function pick({ url, token, trackingId, ...rest }) {
  return Object.freeze({
    url,
    token,
    trackingId,
    ...!!rest.mode && { mode: rest.mode },
    ...!!rest.source && { source: rest.source },
    ...!!rest.environment && { environment: rest.environment }
  });
}
function createConfigManager(initialConfig) {
  let _config = pick(initialConfig);
  return {
    get: () => _config,
    update: (updatedConfig) => {
      _config = pick({ ..._config, ...updatedConfig });
    }
  };
}
const cookieManager = createCookieManager();
function createCookieManager() {
  const prefix = "coveo_";
  const getDomain = (host) => {
    const parts = host.split(".").slice(-2);
    return parts.length == 2 ? parts.join(".") : "";
  };
  return {
    getItem(key) {
      const cookiePrefix = `${prefix}${key}=`;
      const cookieArray = document.cookie.split(";");
      for (const cookie of cookieArray) {
        const prettifyCookie = cookie.replace(/^\s+/, "");
        if (prettifyCookie.lastIndexOf(cookiePrefix, 0) === 0) {
          return prettifyCookie.substring(cookiePrefix.length, prettifyCookie.length);
        }
      }
      return null;
    },
    setItem(key, data, expire) {
      const domain = getDomain(window.location.hostname);
      const expireSection = `;expires=${new Date((/* @__PURE__ */ new Date()).getTime() + expire).toUTCString()}`;
      const domainSection = domain ? `;domain=${domain}` : "";
      document.cookie = `${prefix}${key}=${data}${expireSection}${domainSection};path=/;SameSite=Lax`;
    },
    removeItem(key) {
      this.setItem(key, "", -1);
    }
  };
}
function createBrowserStorage() {
  return {
    getItem(key) {
      return cookieManager.getItem(key) || localStorage.getItem(key);
    },
    removeItem(key) {
      cookieManager.removeItem(key);
      localStorage.removeItem(key);
    },
    setItem(key, data) {
      const oneYear = 31556952e3;
      localStorage.setItem(key, data);
      cookieManager.setItem(key, data, oneYear);
    }
  };
}
function getReferrer() {
  const referrer = document.referrer;
  return referrer === "" ? null : referrer;
}
function buildBrowserEnvironment() {
  return {
    runtime: "browser",
    send: (url, token, event) => {
      const response = navigator.sendBeacon(`${url}?access_token=${token}`, new Blob([JSON.stringify([event])], {
        type: "application/json"
      }));
      const messenger = createExplorerMessenger();
      messenger.sendMessage({ kind: "EVENT_PROTOCOL", event, url, token });
      if (!response) {
        throw new Error(`Failed to send the event(s) because the payload size exceeded the maximum allowed size (32 KB). Please contact support if the problem persists.`);
      }
    },
    getReferrer: () => getReferrer(),
    getLocation: () => window.location.href,
    getUserAgent: () => navigator.userAgent,
    generateUUID: () => v4$1(),
    storage: createBrowserStorage()
  };
}
function localStorageAvailable() {
  try {
    const x = "__storage_test__";
    localStorage.setItem(x, x);
    localStorage.removeItem(x);
    return true;
  } catch (e) {
    return e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    localStorage && localStorage.length !== 0;
  }
}
function createNullStorage() {
  return {
    getItem() {
      return null;
    },
    removeItem() {
      return;
    },
    setItem() {
      return;
    }
  };
}
function buildNullEnvironment() {
  return {
    runtime: "null",
    send: () => void 0,
    getReferrer: () => null,
    getLocation: () => null,
    getUserAgent: () => null,
    generateUUID: () => "",
    storage: createNullStorage()
  };
}
function buildEnvironment(configManager) {
  const active = configManager.get().mode !== "disabled";
  const environmentFromConfig = configManager.get().environment;
  const nullEnvironment = buildNullEnvironment();
  if (active && environmentFromConfig) {
    return {
      storage: nullEnvironment.storage,
      ...environmentFromConfig,
      runtime: "custom"
    };
  }
  if (active && isBrowser$1() && localStorageAvailable()) {
    return buildBrowserEnvironment();
  }
  return nullEnvironment;
}
function isBrowser$1() {
  try {
    return typeof window === "object";
  } catch {
    return false;
  }
}
function createEnvironmentManager(configManager) {
  return {
    get: () => Object.freeze(buildEnvironment(configManager))
  };
}
function createRelay(initialConfig) {
  const configManager = createConfigManager(initialConfig);
  const listenerManager = createListenerManager();
  const environmentManager = createEnvironmentManager(configManager);
  const clientIdManager = createClientIdManager(environmentManager);
  return {
    emit: (type, payload) => {
      const config = configManager.get();
      const environment = environmentManager.get();
      const event = createRelayEvent(type, payload, config, environment, clientIdManager);
      return emit({
        config,
        environment,
        event,
        listenerManager
      });
    },
    getMeta: (type) => createMeta(type, configManager.get(), environmentManager.get(), clientIdManager),
    on: (type, callback) => listenerManager.add({ type, callback }),
    off: (type, callback) => listenerManager.remove(type, callback),
    updateConfig: (config) => configManager.update(config),
    version: version$1
  };
}
function isBrowser() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
const VERSION = "3.35.0";
const COVEO_FRAMEWORK = ["@coveo/atomic", "@coveo/quantic"];
const getAnalyticsSource = createSelector((state) => state.source, (source) => Object.entries(source).map(([frameworkName, frameworkVersion]) => `${frameworkName}@${frameworkVersion}`).concat(`@coveo/headless@${VERSION}`));
const getRelayInstanceFromState = createSelector((state) => state.configuration.organizationId, (state) => state.configuration.environment, (state) => state.configuration.accessToken, (state) => state.configuration.analytics, (state) => getAnalyticsSource(state.configuration.analytics), (_state, navigatorContextProvider) => navigatorContextProvider, (organizationId, platformEnvironment, token, { trackingId, apiBaseUrl, enabled }, source, navigatorContextProvider) => {
  const environment = getEnvironment(navigatorContextProvider);
  return createRelay({
    mode: enabled ? "emit" : "disabled",
    url: apiBaseUrl ?? getAnalyticsNextApiBaseUrl(organizationId, platformEnvironment),
    token,
    trackingId: trackingId ?? null,
    source,
    environment
  });
});
const noopRelayEnvironment = {
  generateUUID: () => "",
  getLocation: () => null,
  getReferrer: () => null,
  getUserAgent: () => null,
  send: () => {
  },
  storage: {
    getItem: () => null,
    setItem: () => {
    },
    removeItem: () => {
    }
  }
};
const getEnvironment = (customProvider) => {
  if (!customProvider) {
    return void 0;
  }
  const customContext = customProvider();
  const baseEnvironment = isBrowser() ? buildBrowserEnvironment() : noopRelayEnvironment;
  return {
    ...baseEnvironment,
    generateUUID: () => customContext.clientId,
    getLocation: () => customContext.location,
    getReferrer: () => customContext.referrer,
    getUserAgent: () => customContext.userAgent
  };
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var EventType;
(function(EventType2) {
  EventType2["search"] = "search";
  EventType2["click"] = "click";
  EventType2["custom"] = "custom";
  EventType2["view"] = "view";
  EventType2["collect"] = "collect";
})(EventType || (EventType = {}));
function hasWindow() {
  return typeof window !== "undefined";
}
function hasNavigator$1() {
  return typeof navigator !== "undefined";
}
function hasDocument() {
  return typeof document !== "undefined";
}
function hasLocalStorage$1() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage$1() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage$1() {
  return hasNavigator$1() && navigator.cookieEnabled;
}
const eventTypesForDefaultValues = [EventType.click, EventType.custom, EventType.search, EventType.view];
const addDefaultValues = (eventType, payload) => {
  return eventTypesForDefaultValues.indexOf(eventType) !== -1 ? Object.assign({ language: hasDocument() ? document.documentElement.lang : "unknown", userAgent: hasNavigator$1() ? navigator.userAgent : "unknown" }, payload) : payload;
};
let Cookie$1 = class Cookie {
  static set(name, value, expire) {
    var domain, expirationDate, domainParts, host;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    host = window.location.hostname;
    if (host.indexOf(".") === -1) {
      writeCookie$1(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie$1(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    var cookiePrefix = name + "=";
    var cookieArray = document.cookie.split(";");
    for (var i = 0; i < cookieArray.length; i++) {
      var cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    Cookie.set(name, "", -1);
  }
};
function writeCookie$1(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}
function getAvailableStorage$1() {
  if (hasLocalStorage$1()) {
    return localStorage;
  }
  if (hasCookieStorage$1()) {
    return new CookieStorage$1();
  }
  if (hasSessionStorage$1()) {
    return sessionStorage;
  }
  return new NullStorage$1();
}
let CookieStorage$1 = class CookieStorage {
  getItem(key) {
    return Cookie$1.get(`${CookieStorage.prefix}${key}`);
  }
  removeItem(key) {
    Cookie$1.erase(`${CookieStorage.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie$1.set(`${CookieStorage.prefix}${key}`, data, expire);
  }
};
CookieStorage$1.prefix = "coveo_";
class CookieAndLocalStorage {
  constructor() {
    this.cookieStorage = new CookieStorage$1();
  }
  getItem(key) {
    return localStorage.getItem(key) || this.cookieStorage.getItem(key);
  }
  removeItem(key) {
    this.cookieStorage.removeItem(key);
    localStorage.removeItem(key);
  }
  setItem(key, data) {
    localStorage.setItem(key, data);
    this.cookieStorage.setItem(key, data, 31556926e3);
  }
}
let NullStorage$1 = class NullStorage {
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, data) {
  }
};
const STORE_KEY$1 = "__coveo.analytics.history";
const MAX_NUMBER_OF_HISTORY_ELEMENTS$1 = 20;
const MIN_THRESHOLD_FOR_DUPLICATE_VALUE$1 = 1e3 * 60;
const MAX_VALUE_SIZE$1 = 75;
let HistoryStore$1 = class HistoryStore {
  constructor(store) {
    this.store = store || getAvailableStorage$1();
  }
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    let currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory != null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  addElementAsync(elem) {
    return __awaiter(this, void 0, void 0, function* () {
      elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
      elem = this.cropQueryElement(this.stripEmptyQuery(elem));
      let currentHistory = yield this.getHistoryWithInternalTimeAsync();
      if (currentHistory != null) {
        if (this.isValidEntry(elem)) {
          this.setHistory([elem].concat(currentHistory));
        }
      } else {
        this.setHistory([elem]);
      }
    });
  }
  getHistory() {
    const history2 = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history2));
  }
  getHistoryAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      const history2 = yield this.getHistoryWithInternalTimeAsync();
      return this.stripEmptyQueries(this.stripInternalTime(history2));
    });
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY$1);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  getHistoryWithInternalTimeAsync() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const elements = yield this.store.getItem(STORE_KEY$1);
        if (elements) {
          return JSON.parse(elements);
        } else {
          return [];
        }
      } catch (e) {
        return [];
      }
    });
  }
  setHistory(history2) {
    try {
      this.store.setItem(STORE_KEY$1, JSON.stringify(history2.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS$1)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY$1);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    let currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE$1);
    }
    return part;
  }
  isValidEntry(elem) {
    let lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value == elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE$1;
    }
    return true;
  }
  stripInternalTime(history2) {
    if (Array.isArray(history2)) {
      return history2.map((part) => {
        const { name, time: time2, value } = part;
        return { name, time: time2, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time: time2, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time: time2 };
    }
    return part;
  }
  stripEmptyQueries(history2) {
    return history2.map((part) => this.stripEmptyQuery(part));
  }
};
const enhanceViewEvent = (eventType, payload) => __awaiter(void 0, void 0, void 0, function* () {
  if (eventType === EventType.view) {
    yield addPageViewToHistory(payload.contentIdValue);
    return Object.assign({ location: window.location.toString(), referrer: document.referrer, title: document.title }, payload);
  }
  return payload;
});
const addPageViewToHistory = (pageViewValue) => __awaiter(void 0, void 0, void 0, function* () {
  const store = new HistoryStore$1();
  const historyElement = {
    name: "PageView",
    value: pageViewValue,
    time: (/* @__PURE__ */ new Date()).toISOString()
  };
  yield store.addElementAsync(historyElement);
});
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function parse(uuid) {
  if (!validate$1(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
const URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err2) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options2, buf, offset) {
  if (native.randomUUID && true && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
const v5 = v35("v5", 80, sha1);
var uuidv5 = v5;
const libVersion = "2.30.49";
const BasePluginEventTypes = {
  pageview: "pageview",
  event: "event"
};
class CoveoLinkParam {
  constructor(clientId, timestamp) {
    if (!validate$1(clientId))
      throw Error("Not a valid uuid");
    this.clientId = clientId;
    this.creationDate = Math.floor(timestamp / 1e3);
  }
  toString() {
    return this.clientId.replace(/-/g, "") + "." + this.creationDate.toString();
  }
  get expired() {
    const age = Math.floor(Date.now() / 1e3) - this.creationDate;
    return age < 0 || age > CoveoLinkParam.expirationTime;
  }
  validate(referrerString, referrerList) {
    return !this.expired && this.matchReferrer(referrerString, referrerList);
  }
  matchReferrer(referrerString, referrerList) {
    try {
      const url = new URL(referrerString);
      return referrerList.some((value) => {
        const hostRegExp = new RegExp(value.replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*") + "$");
        return hostRegExp.test(url.host);
      });
    } catch (error) {
      return false;
    }
  }
  static fromString(input) {
    const parts = input.split(".");
    if (parts.length !== 2) {
      return null;
    }
    const [clientIdPart, creationDate] = parts;
    if (clientIdPart.length !== 32 || isNaN(parseInt(creationDate))) {
      return null;
    }
    const clientId = clientIdPart.substring(0, 8) + "-" + clientIdPart.substring(8, 12) + "-" + clientIdPart.substring(12, 16) + "-" + clientIdPart.substring(16, 20) + "-" + clientIdPart.substring(20, 32);
    if (validate$1(clientId)) {
      return new CoveoLinkParam(clientId, Number.parseInt(creationDate) * 1e3);
    } else {
      return null;
    }
  }
}
CoveoLinkParam.cvo_cid = "cvo_cid";
CoveoLinkParam.expirationTime = 120;
const keysOf = Object.keys;
function isObject$1(o) {
  return o !== null && typeof o === "object" && !Array.isArray(o);
}
const UTF8_HIGH_BIT = 128;
const UTF8_HEADER_2 = 192;
const UTF8_HEADER_3 = 224;
const UTF8_HEADER_4 = 240;
function utf8ByteCountFromFirstByte(firstByte) {
  if ((firstByte & 248) === UTF8_HEADER_4) {
    return 4;
  }
  if ((firstByte & UTF8_HEADER_4) === UTF8_HEADER_3) {
    return 3;
  }
  if ((firstByte & UTF8_HEADER_3) === UTF8_HEADER_2) {
    return 2;
  }
  return 1;
}
function truncateUrl(input, limit) {
  if (limit < 0 || input.length <= limit) {
    return input;
  }
  let end = input.indexOf("%", limit - 2);
  if (end < 0 || end > limit) {
    end = limit;
  } else {
    limit = end;
  }
  while (end > 2 && input.charAt(end - 3) == "%") {
    const peekByte = Number.parseInt(input.substring(end - 2, end), 16);
    if ((peekByte & UTF8_HIGH_BIT) != UTF8_HIGH_BIT) {
      break;
    }
    end -= 3;
    if ((peekByte & UTF8_HEADER_2) != UTF8_HIGH_BIT) {
      if (limit - end >= utf8ByteCountFromFirstByte(peekByte) * 3) {
        end = limit;
      }
      break;
    }
  }
  return input.substring(0, end);
}
const ticketKeysMapping = {
  id: "svc_ticket_id",
  subject: "svc_ticket_subject",
  description: "svc_ticket_description",
  category: "svc_ticket_category",
  productId: "svc_ticket_product_id",
  custom: "svc_ticket_custom"
};
const ticketKeysMappingValues = keysOf(ticketKeysMapping).map((key) => ticketKeysMapping[key]);
const ticketSubKeysMatchGroup = [...ticketKeysMappingValues].join("|");
const ticketKeyRegex = new RegExp(`^(${ticketSubKeysMatchGroup}$)`);
const serviceActionsKeysMapping = {
  svcAction: "svc_action",
  svcActionData: "svc_action_data"
};
const isTicketKey = (key) => ticketKeyRegex.test(key);
const isServiceKey = [isTicketKey];
const productKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  price: "pr",
  quantity: "qt",
  coupon: "cc",
  position: "ps",
  group: "group"
};
const impressionKeysMapping = {
  id: "id",
  name: "nm",
  brand: "br",
  category: "ca",
  variant: "va",
  position: "ps",
  price: "pr",
  group: "group"
};
const productActionsKeysMapping = {
  action: "pa",
  list: "pal",
  listSource: "pls"
};
const transactionActionsKeysMapping = {
  id: "ti",
  revenue: "tr",
  tax: "tt",
  shipping: "ts",
  coupon: "tcc",
  affiliation: "ta",
  step: "cos",
  option: "col"
};
const coveoCommerceExtensionKeys = [
  "loyaltyCardId",
  "loyaltyTier",
  "thirdPartyPersona",
  "companyName",
  "favoriteStore",
  "storeName",
  "userIndustry",
  "userRole",
  "userDepartment",
  "businessUnit"
];
const quoteActionsKeysMapping = {
  id: "quoteId",
  affiliation: "quoteAffiliation"
};
const reviewActionsKeysMapping = {
  id: "reviewId",
  rating: "reviewRating",
  comment: "reviewComment"
};
const commerceActionKeysMappingPerAction = {
  add: productActionsKeysMapping,
  bookmark_add: productActionsKeysMapping,
  bookmark_remove: productActionsKeysMapping,
  click: productActionsKeysMapping,
  checkout: productActionsKeysMapping,
  checkout_option: productActionsKeysMapping,
  detail: productActionsKeysMapping,
  impression: productActionsKeysMapping,
  remove: productActionsKeysMapping,
  refund: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  purchase: Object.assign(Object.assign({}, productActionsKeysMapping), transactionActionsKeysMapping),
  quickview: productActionsKeysMapping,
  quote: Object.assign(Object.assign({}, productActionsKeysMapping), quoteActionsKeysMapping),
  review: Object.assign(Object.assign({}, productActionsKeysMapping), reviewActionsKeysMapping)
};
const productKeysMappingValues = keysOf(productKeysMapping).map((key) => productKeysMapping[key]);
const impressionKeysMappingValues = keysOf(impressionKeysMapping).map((key) => impressionKeysMapping[key]);
const productActionsKeysMappingValues = keysOf(productActionsKeysMapping).map((key) => productActionsKeysMapping[key]);
const transactionActionsKeysMappingValues = keysOf(transactionActionsKeysMapping).map((key) => transactionActionsKeysMapping[key]);
const reviewKeysMappingValues = keysOf(reviewActionsKeysMapping).map((key) => reviewActionsKeysMapping[key]);
const quoteKeysMappingValues = keysOf(quoteActionsKeysMapping).map((key) => quoteActionsKeysMapping[key]);
const productSubKeysMatchGroup = [...productKeysMappingValues, "custom"].join("|");
const impressionSubKeysMatchGroup = [...impressionKeysMappingValues, "custom"].join("|");
const productPrefixMatchGroup = "(pr[0-9]+)";
const impressionPrefixMatchGroup = "(il[0-9]+pi[0-9]+)";
const productKeyRegex = new RegExp(`^${productPrefixMatchGroup}(${productSubKeysMatchGroup})$`);
const impressionKeyRegex = new RegExp(`^(${impressionPrefixMatchGroup}(${impressionSubKeysMatchGroup}))|(il[0-9]+nm)$`);
const productActionsKeyRegex = new RegExp(`^(${productActionsKeysMappingValues.join("|")})$`);
const transactionActionsKeyRegex = new RegExp(`^(${transactionActionsKeysMappingValues.join("|")})$`);
const customProductKeyRegex = new RegExp(`^${productPrefixMatchGroup}custom$`);
const customImpressionKeyRegex = new RegExp(`^${impressionPrefixMatchGroup}custom$`);
const coveoCommerceExtensionKeysRegex = new RegExp(`^(${[...coveoCommerceExtensionKeys, ...reviewKeysMappingValues, ...quoteKeysMappingValues].join("|")})$`);
const isProductKey = (key) => productKeyRegex.test(key);
const isImpressionKey = (key) => impressionKeyRegex.test(key);
const isProductActionsKey = (key) => productActionsKeyRegex.test(key);
const isTransactionActionsKeyRegex = (key) => transactionActionsKeyRegex.test(key);
const isCoveoCommerceExtensionKey = (key) => coveoCommerceExtensionKeysRegex.test(key);
const isCommerceKey = [
  isImpressionKey,
  isProductKey,
  isProductActionsKey,
  isTransactionActionsKeyRegex,
  isCoveoCommerceExtensionKey
];
const isCustomCommerceKey = [customProductKeyRegex, customImpressionKeyRegex];
const globalParamKeysMapping = {
  anonymizeIp: "aip"
};
const eventKeysMapping = {
  eventCategory: "ec",
  eventAction: "ea",
  eventLabel: "el",
  eventValue: "ev",
  page: "dp",
  visitorId: "cid",
  clientId: "cid",
  userId: "uid",
  currencyCode: "cu"
};
const contextInformationMapping = {
  hitType: "t",
  pageViewId: "pid",
  encoding: "de",
  location: "dl",
  referrer: "dr",
  screenColor: "sd",
  screenResolution: "sr",
  title: "dt",
  userAgent: "ua",
  language: "ul",
  eventId: "z",
  time: "tm"
};
const coveoExtensionsKeys = [
  "contentId",
  "contentIdKey",
  "contentType",
  "searchHub",
  "tab",
  "searchUid",
  "permanentId",
  "contentLocale",
  "trackingId"
];
const baseMeasurementProtocolKeysMapping = Object.assign(Object.assign(Object.assign(Object.assign({}, globalParamKeysMapping), eventKeysMapping), contextInformationMapping), coveoExtensionsKeys.reduce((all, key) => Object.assign(Object.assign({}, all), { [key]: key }), {}));
const measurementProtocolKeysMapping = Object.assign(Object.assign({}, baseMeasurementProtocolKeysMapping), serviceActionsKeysMapping);
const convertKeysToMeasurementProtocol = (params) => {
  const keysMappingForAction = !!params.action && commerceActionKeysMappingPerAction[params.action] || {};
  return keysOf(params).reduce((mappedKeys, key) => {
    const newKey = keysMappingForAction[key] || measurementProtocolKeysMapping[key] || key;
    return Object.assign(Object.assign({}, mappedKeys), { [newKey]: params[key] });
  }, {});
};
const measurementProtocolKeysMappingValues = keysOf(measurementProtocolKeysMapping).map((key) => measurementProtocolKeysMapping[key]);
const isKnownMeasurementProtocolKey = (key) => measurementProtocolKeysMappingValues.indexOf(key) !== -1;
const isCustomKey = (key) => key === "custom";
const isMeasurementProtocolKey = (key) => {
  return [...isCommerceKey, ...isServiceKey, isKnownMeasurementProtocolKey, isCustomKey].some((test) => test(key));
};
const convertCustomMeasurementProtocolKeys = (data) => {
  return keysOf(data).reduce((all, current2) => {
    const match = getFirstCustomMeasurementProtocolKeyMatch(current2);
    if (match) {
      return Object.assign(Object.assign({}, all), convertCustomObject(match, data[current2]));
    } else {
      return Object.assign(Object.assign({}, all), { [current2]: data[current2] });
    }
  }, {});
};
const getFirstCustomMeasurementProtocolKeyMatch = (key) => {
  let matchedKey = void 0;
  [...isCustomCommerceKey].every((regex) => {
    var _a;
    matchedKey = (_a = regex.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
    return !Boolean(matchedKey);
  });
  return matchedKey;
};
const convertCustomObject = (prefix, customData) => {
  return keysOf(customData).reduce((allCustom, currentCustomKey) => Object.assign(Object.assign({}, allCustom), { [`${prefix}${currentCustomKey}`]: customData[currentCustomKey] }), {});
};
class AnalyticsBeaconClient {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, originalPayload) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isAvailable()) {
        throw new Error(`navigator.sendBeacon is not supported in this browser. Consider adding a polyfill like "sendbeacon-polyfill".`);
      }
      const { baseUrl, preprocessRequest } = this.opts;
      const paramsFragments = yield this.getQueryParamsForEventType(eventType);
      const { url, payload } = yield this.preProcessRequestAsPotentialJSONString(`${baseUrl}/analytics/${eventType}?${paramsFragments}`, originalPayload, preprocessRequest);
      const parsedRequestData = this.encodeForEventType(eventType, payload);
      const body = new Blob([parsedRequestData], {
        type: "application/x-www-form-urlencoded"
      });
      navigator.sendBeacon(url, body);
      return;
    });
  }
  isAvailable() {
    return "sendBeacon" in navigator;
  }
  deleteHttpCookieVisitorId() {
    return Promise.resolve();
  }
  preProcessRequestAsPotentialJSONString(originalURL, originalPayload, preprocessRequest) {
    return __awaiter(this, void 0, void 0, function* () {
      let returnedUrl = originalURL;
      let returnedPayload = originalPayload;
      if (preprocessRequest) {
        const processedRequest = yield preprocessRequest({ url: originalURL, body: JSON.stringify(originalPayload) }, "analyticsBeacon");
        const { url: processedURL, body: processedBody } = processedRequest;
        returnedUrl = processedURL || originalURL;
        try {
          returnedPayload = JSON.parse(processedBody);
        } catch (e) {
          console.error("Unable to process the request body as a JSON string", e);
        }
      }
      return {
        payload: returnedPayload,
        url: returnedUrl
      };
    });
  }
  encodeForEventType(eventType, payload) {
    return this.isEventTypeLegacy(eventType) ? this.encodeEventToJson(eventType, payload) : this.encodeEventToJson(eventType, payload, this.opts.token);
  }
  getQueryParamsForEventType(eventType) {
    return __awaiter(this, void 0, void 0, function* () {
      const { token, visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return [
        token && this.isEventTypeLegacy(eventType) ? `access_token=${token}` : "",
        visitorId ? `visitorId=${visitorId}` : "",
        "discardVisitInfo=true"
      ].filter((p) => !!p).join("&");
    });
  }
  isEventTypeLegacy(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  encodeEventToJson(eventType, payload, access_token) {
    let encoded = `${eventType}Event=${encodeURIComponent(JSON.stringify(payload))}`;
    if (access_token) {
      encoded = `access_token=${encodeURIComponent(access_token)}&${encoded}`;
    }
    return encoded;
  }
}
class NoopAnalyticsClient {
  sendEvent(_, __) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
}
const fetch$1 = globalThis.fetch;
class AnalyticsFetchClient {
  constructor(opts) {
    this.opts = opts;
  }
  sendEvent(eventType, payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl, visitorIdProvider, preprocessRequest } = this.opts;
      const visitorIdParam = this.shouldAppendVisitorId(eventType) ? yield this.getVisitorIdParam() : "";
      const defaultOptions = {
        url: `${baseUrl}/analytics/${eventType}${visitorIdParam}`,
        credentials: "include",
        mode: "cors",
        headers: this.getHeaders(),
        method: "POST",
        body: JSON.stringify(payload)
      };
      const _a = Object.assign(Object.assign({}, defaultOptions), preprocessRequest ? yield preprocessRequest(defaultOptions, "analyticsFetch") : {}), { url } = _a, fetchData = __rest(_a, ["url"]);
      let response;
      try {
        response = yield fetch$1(url, fetchData);
      } catch (error) {
        console.error("An error has occured when sending the event.", error);
        return;
      }
      if (response.ok) {
        const visit = yield response.json();
        if (visit.visitorId) {
          visitorIdProvider.setCurrentVisitorId(visit.visitorId);
        }
        return visit;
      } else {
        try {
          response.json();
        } catch (_b) {
        }
        console.error(`An error has occured when sending the "${eventType}" event.`, response, payload);
        throw new Error(`An error has occurred when sending the "${eventType}" event. Check the console logs for more details.`);
      }
    });
  }
  deleteHttpCookieVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      const { baseUrl } = this.opts;
      const url = `${baseUrl}/analytics/visit`;
      yield fetch$1(url, { headers: this.getHeaders(), method: "DELETE" });
    });
  }
  shouldAppendVisitorId(eventType) {
    return [EventType.click, EventType.custom, EventType.search, EventType.view].indexOf(eventType) !== -1;
  }
  getVisitorIdParam() {
    return __awaiter(this, void 0, void 0, function* () {
      const { visitorIdProvider } = this.opts;
      const visitorId = yield visitorIdProvider.getCurrentVisitorId();
      return visitorId ? `?visitor=${visitorId}` : "";
    });
  }
  getHeaders() {
    const { token } = this.opts;
    return Object.assign(Object.assign({}, token ? { Authorization: `Bearer ${token}` } : {}), { "Content-Type": `application/json` });
  }
}
class BrowserRuntime {
  constructor(clientOptions, getUnprocessedRequests) {
    if (hasLocalStorage$1() && hasCookieStorage$1()) {
      this.storage = new CookieAndLocalStorage();
    } else if (hasLocalStorage$1()) {
      this.storage = localStorage;
    } else {
      console.warn("BrowserRuntime detected no valid storage available.", this);
      this.storage = new NullStorage$1();
    }
    this.client = new AnalyticsFetchClient(clientOptions);
    this.beaconClient = new AnalyticsBeaconClient(clientOptions);
    window.addEventListener("beforeunload", () => {
      const requests = getUnprocessedRequests();
      for (let { eventType, payload } of requests) {
        this.beaconClient.sendEvent(eventType, payload);
      }
    });
  }
  getClientDependingOnEventType(eventType) {
    return eventType === "click" && this.beaconClient.isAvailable() ? this.beaconClient : this.client;
  }
}
class NodeJSRuntime {
  constructor(clientOptions, storage) {
    this.storage = storage || new NullStorage$1();
    this.client = new AnalyticsFetchClient(clientOptions);
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
}
class NoopRuntime {
  constructor() {
    this.storage = new NullStorage$1();
    this.client = new NoopAnalyticsClient();
  }
  getClientDependingOnEventType(eventType) {
    return this.client;
  }
}
const API_KEY_PREFIX = "xx";
const isApiKey = (token) => (token === null || token === void 0 ? void 0 : token.startsWith(API_KEY_PREFIX)) || false;
const ReactNativeRuntimeWarning = `
        We've detected you're using React Native but have not provided the corresponding runtime, 
        for an optimal experience please use the "coveo.analytics/react-native" subpackage.
        Follow the Readme on how to set it up: https://github.com/coveo/coveo.analytics.js#using-react-native
    `;
function isReactNative() {
  return typeof navigator != "undefined" && navigator.product == "ReactNative";
}
const doNotTrackValues = ["1", 1, "yes", true];
function doNotTrack() {
  const checks = [];
  if (hasWindow()) {
    checks.push(window.doNotTrack);
  }
  if (hasNavigator$1()) {
    checks.push(navigator.doNotTrack, navigator.msDoNotTrack, navigator.globalPrivacyControl);
  }
  return checks.some((value) => doNotTrackValues.indexOf(value) !== -1);
}
const Version = "v15";
const Endpoints = {
  default: "https://analytics.cloud.coveo.com/rest/ua"
};
function buildBaseUrl(endpoint = Endpoints.default, apiVersion = Version, isCustomEndpoint = false) {
  endpoint = endpoint.replace(/\/$/, "");
  if (isCustomEndpoint) {
    return `${endpoint}/${apiVersion}`;
  }
  const hasUARestEndpoint = endpoint.endsWith("/rest") || endpoint.endsWith("/rest/ua");
  return `${endpoint}${hasUARestEndpoint ? "" : "/rest"}/${apiVersion}`;
}
const COVEO_NAMESPACE = "38824e1f-37f5-42d3-8372-a4b8fa9df946";
class CoveoAnalyticsClient {
  get defaultOptions() {
    return {
      endpoint: Endpoints.default,
      isCustomEndpoint: false,
      token: "",
      version: Version,
      beforeSendHooks: [],
      afterSendHooks: []
    };
  }
  get version() {
    return libVersion;
  }
  constructor(opts) {
    this.acceptedLinkReferrers = [];
    if (!opts) {
      throw new Error("You have to pass options to this constructor");
    }
    this.options = Object.assign(Object.assign({}, this.defaultOptions), opts);
    this.visitorId = "";
    this.bufferedRequests = [];
    this.beforeSendHooks = [enhanceViewEvent, addDefaultValues].concat(this.options.beforeSendHooks);
    this.afterSendHooks = this.options.afterSendHooks;
    this.eventTypeMapping = {};
    const clientsOptions = {
      baseUrl: this.baseUrl,
      token: this.options.token,
      visitorIdProvider: this,
      preprocessRequest: this.options.preprocessRequest
    };
    if (doNotTrack()) {
      this.runtime = new NoopRuntime();
    } else {
      this.runtime = this.options.runtimeEnvironment || this.initRuntime(clientsOptions);
    }
    this.addEventTypeMapping(EventType.view, { newEventType: EventType.view, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.click, { newEventType: EventType.click, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.custom, { newEventType: EventType.custom, addClientIdParameter: true });
    this.addEventTypeMapping(EventType.search, { newEventType: EventType.search, addClientIdParameter: true });
  }
  initRuntime(clientsOptions) {
    if (hasWindow() && hasDocument()) {
      return new BrowserRuntime(clientsOptions, () => {
        const copy = [...this.bufferedRequests];
        this.bufferedRequests = [];
        return copy;
      });
    } else if (isReactNative()) {
      console.warn(ReactNativeRuntimeWarning);
    }
    return new NodeJSRuntime(clientsOptions);
  }
  get storage() {
    return this.runtime.storage;
  }
  determineVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return hasWindow() && this.extractClientIdFromLink(window.location.href) || (yield this.storage.getItem("visitorId")) || v4();
      } catch (err2) {
        console.log("Could not get visitor ID from the current runtime environment storage. Using a random ID instead.", err2);
        return v4();
      }
    });
  }
  getCurrentVisitorId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.visitorId) {
        const id2 = yield this.determineVisitorId();
        yield this.setCurrentVisitorId(id2);
      }
      return this.visitorId;
    });
  }
  setCurrentVisitorId(visitorId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.visitorId = visitorId;
      yield this.storage.setItem("visitorId", visitorId);
    });
  }
  setClientId(value, namespace) {
    return __awaiter(this, void 0, void 0, function* () {
      if (validate$1(value)) {
        this.setCurrentVisitorId(value.toLowerCase());
      } else {
        if (!namespace) {
          throw Error("Cannot generate uuid client id without a specific namespace string.");
        }
        this.setCurrentVisitorId(uuidv5(value, uuidv5(namespace, COVEO_NAMESPACE)));
      }
    });
  }
  getParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.resolveParameters(eventType, ...payload);
    });
  }
  getPayload(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      return yield this.resolvePayloadForParameters(eventType, parametersToSend);
    });
  }
  get currentVisitorId() {
    const visitorId = this.visitorId || this.storage.getItem("visitorId");
    if (typeof visitorId !== "string") {
      this.setCurrentVisitorId(v4());
    }
    return this.visitorId;
  }
  set currentVisitorId(visitorId) {
    this.visitorId = visitorId;
    this.storage.setItem("visitorId", visitorId);
  }
  extractClientIdFromLink(urlString) {
    if (doNotTrack()) {
      return null;
    }
    try {
      const linkParam = new URL(urlString).searchParams.get(CoveoLinkParam.cvo_cid);
      if (linkParam == null) {
        return null;
      }
      const linker = CoveoLinkParam.fromString(linkParam);
      if (!linker || !hasDocument() || !linker.validate(document.referrer, this.acceptedLinkReferrers)) {
        return null;
      }
      return linker.clientId;
    } catch (error) {
    }
    return null;
  }
  resolveParameters(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { variableLengthArgumentsNames = [], addVisitorIdParameter = false, usesMeasurementProtocol = false, addClientIdParameter = false } = this.eventTypeMapping[eventType] || {};
      const processVariableArgumentNamesStep = (currentPayload) => variableLengthArgumentsNames.length > 0 ? this.parseVariableArgumentsPayload(variableLengthArgumentsNames, currentPayload) : currentPayload[0];
      const addVisitorIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, currentPayload), { visitorId: addVisitorIdParameter ? yield this.getCurrentVisitorId() : "" });
      });
      const addClientIdStep = (currentPayload) => __awaiter(this, void 0, void 0, function* () {
        if (addClientIdParameter) {
          return Object.assign(Object.assign({}, currentPayload), { clientId: yield this.getCurrentVisitorId() });
        }
        return currentPayload;
      });
      const setAnonymousUserStep = (currentPayload) => usesMeasurementProtocol ? this.ensureAnonymousUserWhenUsingApiKey(currentPayload) : currentPayload;
      const processBeforeSendHooksStep = (currentPayload) => this.beforeSendHooks.reduce((promisePayload, current2) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield promisePayload;
        return yield current2(eventType, payload2);
      }), currentPayload);
      const parametersToSend = yield [
        processVariableArgumentNamesStep,
        addVisitorIdStep,
        addClientIdStep,
        setAnonymousUserStep,
        processBeforeSendHooksStep
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload2 = yield payloadPromise;
        return yield step(payload2);
      }), Promise.resolve(payload));
      return parametersToSend;
    });
  }
  resolvePayloadForParameters(eventType, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const { usesMeasurementProtocol = false } = this.eventTypeMapping[eventType] || {};
      const addTrackingIdStep = (currentPayload) => this.setTrackingIdIfTrackingIdNotPresent(currentPayload);
      const cleanPayloadStep = (currentPayload) => this.removeEmptyPayloadValues(currentPayload, eventType);
      const validateParams = (currentPayload) => this.validateParams(currentPayload, eventType);
      const processMeasurementProtocolConversionStep = (currentPayload) => usesMeasurementProtocol ? convertKeysToMeasurementProtocol(currentPayload) : currentPayload;
      const removeUnknownParameters = (currentPayload) => usesMeasurementProtocol ? this.removeUnknownParameters(currentPayload) : currentPayload;
      const processCustomParameters = (currentPayload) => usesMeasurementProtocol ? this.processCustomParameters(currentPayload) : this.mapCustomParametersToCustomData(currentPayload);
      const payloadToSend = yield [
        addTrackingIdStep,
        cleanPayloadStep,
        validateParams,
        processMeasurementProtocolConversionStep,
        removeUnknownParameters,
        processCustomParameters
      ].reduce((payloadPromise, step) => __awaiter(this, void 0, void 0, function* () {
        const payload = yield payloadPromise;
        return yield step(payload);
      }), Promise.resolve(parameters));
      return payloadToSend;
    });
  }
  makeEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      const { newEventType: eventTypeToSend = eventType } = this.eventTypeMapping[eventType] || {};
      const parametersToSend = yield this.resolveParameters(eventType, ...payload);
      const payloadToSend = yield this.resolvePayloadForParameters(eventType, parametersToSend);
      return {
        eventType: eventTypeToSend,
        payload: payloadToSend,
        log: (remainingPayload) => __awaiter(this, void 0, void 0, function* () {
          this.bufferedRequests.push({
            eventType: eventTypeToSend,
            payload: Object.assign(Object.assign({}, payloadToSend), remainingPayload)
          });
          yield Promise.all(this.afterSendHooks.map((hook) => hook(eventType, Object.assign(Object.assign({}, parametersToSend), remainingPayload))));
          yield this.deferExecution();
          return yield this.sendFromBuffer();
        })
      };
    });
  }
  sendEvent(eventType, ...payload) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeEvent(eventType, ...payload)).log({});
    });
  }
  deferExecution() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  sendFromBuffer() {
    return __awaiter(this, void 0, void 0, function* () {
      const popped = this.bufferedRequests.shift();
      if (popped) {
        const { eventType, payload } = popped;
        return this.runtime.getClientDependingOnEventType(eventType).sendEvent(eventType, payload);
      }
    });
  }
  clear() {
    this.storage.removeItem("visitorId");
    const store = new HistoryStore$1();
    store.clear();
  }
  deleteHttpOnlyVisitorId() {
    this.runtime.client.deleteHttpCookieVisitorId();
  }
  makeSearchEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.search, request);
    });
  }
  sendSearchEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeSearchEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeClickEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.click, request);
    });
  }
  sendClickEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { searchQueryUid } = _a, preparedRequest = __rest(_a, ["searchQueryUid"]);
      return (yield this.makeClickEvent(preparedRequest)).log({ searchQueryUid });
    });
  }
  makeCustomEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.custom, request);
    });
  }
  sendCustomEvent(_a) {
    return __awaiter(this, void 0, void 0, function* () {
      var { lastSearchQueryUid } = _a, preparedRequest = __rest(_a, ["lastSearchQueryUid"]);
      return (yield this.makeCustomEvent(preparedRequest)).log({ lastSearchQueryUid });
    });
  }
  makeViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.makeEvent(EventType.view, request);
    });
  }
  sendViewEvent(request) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeViewEvent(request)).log({});
    });
  }
  getVisit() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/visit`);
      const visit = yield response.json();
      this.visitorId = visit.visitorId;
      return visit;
    });
  }
  getHealth() {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(`${this.baseUrl}/analytics/monitoring/health`);
      return yield response.json();
    });
  }
  registerBeforeSendEventHook(hook) {
    this.beforeSendHooks.push(hook);
  }
  registerAfterSendEventHook(hook) {
    this.afterSendHooks.push(hook);
  }
  addEventTypeMapping(eventType, eventConfig) {
    this.eventTypeMapping[eventType] = eventConfig;
  }
  setAcceptedLinkReferrers(hosts) {
    if (Array.isArray(hosts) && hosts.every((host) => typeof host == "string"))
      this.acceptedLinkReferrers = hosts;
    else
      throw Error("Parameter should be an array of domain strings");
  }
  parseVariableArgumentsPayload(fieldsOrder, payload) {
    const parsedArguments = {};
    for (let i = 0, length = payload.length; i < length; i++) {
      const currentArgument = payload[i];
      if (typeof currentArgument === "string") {
        parsedArguments[fieldsOrder[i]] = currentArgument;
      } else if (typeof currentArgument === "object") {
        return Object.assign(Object.assign({}, parsedArguments), currentArgument);
      }
    }
    return parsedArguments;
  }
  isKeyAllowedEmpty(evtType, key) {
    const keysThatCanBeEmpty = {
      [EventType.search]: ["queryText"]
    };
    const match = keysThatCanBeEmpty[evtType] || [];
    return match.indexOf(key) !== -1;
  }
  removeEmptyPayloadValues(payload, eventType) {
    const isNotEmptyValue = (value) => typeof value !== "undefined" && value !== null && value !== "";
    return Object.keys(payload).filter((key) => this.isKeyAllowedEmpty(eventType, key) || isNotEmptyValue(payload[key])).reduce((newPayload, key) => Object.assign(Object.assign({}, newPayload), { [key]: payload[key] }), {});
  }
  removeUnknownParameters(payload) {
    const newPayload = Object.keys(payload).filter((key) => {
      if (isMeasurementProtocolKey(key)) {
        return true;
      } else {
        console.log(key, "is not processed by coveoua");
      }
    }).reduce((newPayload2, key) => Object.assign(Object.assign({}, newPayload2), { [key]: payload[key] }), {});
    return newPayload;
  }
  processCustomParameters(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    let lowercasedCustom = {};
    if (custom && isObject$1(custom)) {
      lowercasedCustom = this.lowercaseKeys(custom);
    }
    const newPayload = convertCustomMeasurementProtocolKeys(rest);
    return Object.assign(Object.assign({}, lowercasedCustom), newPayload);
  }
  mapCustomParametersToCustomData(payload) {
    const { custom } = payload, rest = __rest(payload, ["custom"]);
    if (custom && isObject$1(custom)) {
      const lowercasedCustom = this.lowercaseKeys(custom);
      return Object.assign(Object.assign({}, rest), { customData: Object.assign(Object.assign({}, lowercasedCustom), payload.customData) });
    } else {
      return payload;
    }
  }
  lowercaseKeys(custom) {
    const keys2 = Object.keys(custom);
    let result = {};
    keys2.forEach((key) => {
      result[key.toLowerCase()] = custom[key];
    });
    return result;
  }
  validateParams(payload, eventType) {
    const { anonymizeIp } = payload, rest = __rest(payload, ["anonymizeIp"]);
    if (anonymizeIp !== void 0) {
      if (["0", "false", "undefined", "null", "{}", "[]", ""].indexOf(`${anonymizeIp}`.toLowerCase()) == -1) {
        rest.anonymizeIp = 1;
      }
    }
    if (eventType == EventType.view || eventType == EventType.click || eventType == EventType.search || eventType == EventType.custom) {
      rest.originLevel3 = this.limit(rest.originLevel3, 1024);
    }
    if (eventType == EventType.view) {
      rest.location = this.limit(rest.location, 1024);
    }
    if (eventType == "pageview" || eventType == "event") {
      rest.referrer = this.limit(rest.referrer, 2048);
      rest.location = this.limit(rest.location, 2048);
      rest.page = this.limit(rest.page, 2048);
    }
    return rest;
  }
  ensureAnonymousUserWhenUsingApiKey(payload) {
    const { userId } = payload, rest = __rest(payload, ["userId"]);
    if (isApiKey(this.options.token) && !userId) {
      rest["userId"] = "anonymous";
      return rest;
    } else {
      return payload;
    }
  }
  setTrackingIdIfTrackingIdNotPresent(payload) {
    const { trackingId } = payload, rest = __rest(payload, ["trackingId"]);
    if (trackingId) {
      return payload;
    }
    if (rest.hasOwnProperty("custom") && isObject$1(rest.custom)) {
      if (rest.custom.hasOwnProperty("context_website") || rest.custom.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.custom.context_website || rest.custom.siteName;
      }
    }
    if (rest.hasOwnProperty("customData") && isObject$1(rest.customData)) {
      if (rest.customData.hasOwnProperty("context_website") || rest.customData.hasOwnProperty("siteName")) {
        rest["trackingId"] = rest.customData.context_website || rest.customData.siteName;
      }
    }
    return rest;
  }
  limit(input, length) {
    return typeof input === "string" ? truncateUrl(input, length) : input;
  }
  get baseUrl() {
    return buildBaseUrl(this.options.endpoint, this.options.version, this.options.isCustomEndpoint);
  }
}
var InsightEvents;
(function(InsightEvents2) {
  InsightEvents2["contextChanged"] = "contextChanged";
  InsightEvents2["expandToFullUI"] = "expandToFullUI";
  InsightEvents2["openUserActions"] = "openUserActions";
  InsightEvents2["showPrecedingSessions"] = "showPrecedingSessions";
  InsightEvents2["showFollowingSessions"] = "showFollowingSessions";
  InsightEvents2["clickViewedDocument"] = "clickViewedDocument";
  InsightEvents2["clickPageView"] = "clickPageView";
  InsightEvents2["createArticle"] = "createArticle";
})(InsightEvents || (InsightEvents = {}));
var SearchPageEvents$1;
(function(SearchPageEvents2) {
  SearchPageEvents2["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents2["interfaceChange"] = "interfaceChange";
  SearchPageEvents2["didyoumeanAutomatic"] = "didyoumeanAutomatic";
  SearchPageEvents2["didyoumeanClick"] = "didyoumeanClick";
  SearchPageEvents2["resultsSort"] = "resultsSort";
  SearchPageEvents2["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents2["searchboxClear"] = "searchboxClear";
  SearchPageEvents2["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents2["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents2["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents2["documentQuickview"] = "documentQuickview";
  SearchPageEvents2["documentOpen"] = "documentOpen";
  SearchPageEvents2["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents2["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents2["searchFromLink"] = "searchFromLink";
  SearchPageEvents2["triggerNotify"] = "notify";
  SearchPageEvents2["triggerExecute"] = "execute";
  SearchPageEvents2["triggerQuery"] = "query";
  SearchPageEvents2["undoTriggerQuery"] = "undoQuery";
  SearchPageEvents2["triggerRedirect"] = "redirect";
  SearchPageEvents2["pagerResize"] = "pagerResize";
  SearchPageEvents2["pagerNumber"] = "pagerNumber";
  SearchPageEvents2["pagerNext"] = "pagerNext";
  SearchPageEvents2["pagerPrevious"] = "pagerPrevious";
  SearchPageEvents2["pagerScrolling"] = "pagerScrolling";
  SearchPageEvents2["staticFilterClearAll"] = "staticFilterClearAll";
  SearchPageEvents2["staticFilterSelect"] = "staticFilterSelect";
  SearchPageEvents2["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents2["facetClearAll"] = "facetClearAll";
  SearchPageEvents2["facetSearch"] = "facetSearch";
  SearchPageEvents2["facetSelect"] = "facetSelect";
  SearchPageEvents2["facetSelectAll"] = "facetSelectAll";
  SearchPageEvents2["facetDeselect"] = "facetDeselect";
  SearchPageEvents2["facetExclude"] = "facetExclude";
  SearchPageEvents2["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents2["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents2["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents2["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents2["queryError"] = "query";
  SearchPageEvents2["queryErrorBack"] = "errorBack";
  SearchPageEvents2["queryErrorClear"] = "errorClearQuery";
  SearchPageEvents2["queryErrorRetry"] = "errorRetry";
  SearchPageEvents2["recommendation"] = "recommendation";
  SearchPageEvents2["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents2["recommendationOpen"] = "recommendationOpen";
  SearchPageEvents2["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents2["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents2["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents2["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents2["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents2["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents2["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents2["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents2["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents2["showMoreSmartSnippetSuggestion"] = "showMoreSmartSnippetSuggestion";
  SearchPageEvents2["showLessSmartSnippetSuggestion"] = "showLessSmartSnippetSuggestion";
  SearchPageEvents2["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents2["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents2["openSmartSnippetInlineLink"] = "openSmartSnippetInlineLink";
  SearchPageEvents2["openSmartSnippetSuggestionInlineLink"] = "openSmartSnippetSuggestionInlineLink";
  SearchPageEvents2["recentQueryClick"] = "recentQueriesClick";
  SearchPageEvents2["clearRecentQueries"] = "clearRecentQueries";
  SearchPageEvents2["recentResultClick"] = "recentResultClick";
  SearchPageEvents2["clearRecentResults"] = "clearRecentResults";
  SearchPageEvents2["noResultsBack"] = "noResultsBack";
  SearchPageEvents2["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents2["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents2["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents2["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents2["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents2["caseAttach"] = "caseAttach";
  SearchPageEvents2["caseDetach"] = "caseDetach";
  SearchPageEvents2["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents2["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents2["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents2["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents2["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents2["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents2["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents2["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents2["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents2["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents2["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents2["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents2["rephraseGeneratedAnswer"] = "rephraseGeneratedAnswer";
  SearchPageEvents2["generatedAnswerFeedbackSubmitV2"] = "generatedAnswerFeedbackSubmitV2";
  SearchPageEvents2["generatedAnswerCitationClick"] = "generatedAnswerCitationClick";
})(SearchPageEvents$1 || (SearchPageEvents$1 = {}));
const CustomEventsTypes = {
  [SearchPageEvents$1.triggerNotify]: "queryPipelineTriggers",
  [SearchPageEvents$1.triggerExecute]: "queryPipelineTriggers",
  [SearchPageEvents$1.triggerQuery]: "queryPipelineTriggers",
  [SearchPageEvents$1.triggerRedirect]: "queryPipelineTriggers",
  [SearchPageEvents$1.queryErrorBack]: "errors",
  [SearchPageEvents$1.queryErrorClear]: "errors",
  [SearchPageEvents$1.queryErrorRetry]: "errors",
  [SearchPageEvents$1.pagerNext]: "getMoreResults",
  [SearchPageEvents$1.pagerPrevious]: "getMoreResults",
  [SearchPageEvents$1.pagerNumber]: "getMoreResults",
  [SearchPageEvents$1.pagerResize]: "getMoreResults",
  [SearchPageEvents$1.pagerScrolling]: "getMoreResults",
  [SearchPageEvents$1.facetSearch]: "facet",
  [SearchPageEvents$1.facetShowLess]: "facet",
  [SearchPageEvents$1.facetShowMore]: "facet",
  [SearchPageEvents$1.recommendation]: "recommendation",
  [SearchPageEvents$1.likeSmartSnippet]: "smartSnippet",
  [SearchPageEvents$1.dislikeSmartSnippet]: "smartSnippet",
  [SearchPageEvents$1.expandSmartSnippet]: "smartSnippet",
  [SearchPageEvents$1.collapseSmartSnippet]: "smartSnippet",
  [SearchPageEvents$1.openSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents$1.closeSmartSnippetFeedbackModal]: "smartSnippet",
  [SearchPageEvents$1.sendSmartSnippetReason]: "smartSnippet",
  [SearchPageEvents$1.expandSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents$1.collapseSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents$1.showMoreSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents$1.showLessSmartSnippetSuggestion]: "smartSnippetSuggestions",
  [SearchPageEvents$1.clearRecentQueries]: "recentQueries",
  [SearchPageEvents$1.recentResultClick]: "recentlyClickedDocuments",
  [SearchPageEvents$1.clearRecentResults]: "recentlyClickedDocuments",
  [SearchPageEvents$1.showLessFoldedResults]: "folding",
  [SearchPageEvents$1.caseDetach]: "case",
  [SearchPageEvents$1.likeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents$1.dislikeGeneratedAnswer]: "generatedAnswer",
  [SearchPageEvents$1.openGeneratedAnswerSource]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerStreamEnd]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerSourceHover]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerCopyToClipboard]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerHideAnswers]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerShowAnswers]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerExpand]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerCollapse]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerFeedbackSubmit]: "generatedAnswer",
  [SearchPageEvents$1.generatedAnswerFeedbackSubmitV2]: "generatedAnswer",
  [InsightEvents.expandToFullUI]: "interface",
  [InsightEvents.openUserActions]: "User Actions",
  [InsightEvents.showPrecedingSessions]: "User Actions",
  [InsightEvents.showFollowingSessions]: "User Actions",
  [InsightEvents.clickViewedDocument]: "User Actions",
  [InsightEvents.clickPageView]: "User Actions",
  [InsightEvents.createArticle]: "createArticle"
};
class NoopAnalytics {
  constructor() {
    this.runtime = new NoopRuntime();
    this.currentVisitorId = "";
  }
  getPayload() {
    return Promise.resolve();
  }
  getParameters() {
    return Promise.resolve();
  }
  makeEvent(eventType) {
    return Promise.resolve({ eventType, payload: null, log: () => Promise.resolve() });
  }
  sendEvent() {
    return Promise.resolve();
  }
  makeSearchEvent() {
    return this.makeEvent(EventType.search);
  }
  sendSearchEvent() {
    return Promise.resolve();
  }
  makeClickEvent() {
    return this.makeEvent(EventType.click);
  }
  sendClickEvent() {
    return Promise.resolve();
  }
  makeCustomEvent() {
    return this.makeEvent(EventType.custom);
  }
  sendCustomEvent() {
    return Promise.resolve();
  }
  makeViewEvent() {
    return this.makeEvent(EventType.view);
  }
  sendViewEvent() {
    return Promise.resolve();
  }
  getVisit() {
    return Promise.resolve({ id: "", visitorId: "" });
  }
  getHealth() {
    return Promise.resolve({ status: "" });
  }
  registerBeforeSendEventHook() {
  }
  registerAfterSendEventHook() {
  }
  addEventTypeMapping() {
  }
  get version() {
    return libVersion;
  }
}
function filterConsecutiveRepeatedValues(rawData) {
  let prev = "";
  return rawData.filter((value) => {
    const isDifferent = value !== prev;
    prev = value;
    return isDifferent;
  });
}
function removeSemicolons(rawData) {
  return rawData.map((value) => {
    return value.replace(/;/g, "");
  });
}
function getDataString(data) {
  const ANALYTICS_LENGTH_LIMIT = 256;
  const formattedData = data.join(";");
  if (formattedData.length <= ANALYTICS_LENGTH_LIMIT) {
    return formattedData;
  }
  return getDataString(data.slice(1));
}
const formatArrayForCoveoCustomData = (rawData) => {
  const dataWithoutSemicolons = removeSemicolons(rawData);
  const dataWithoutRepeatedValues = filterConsecutiveRepeatedValues(dataWithoutSemicolons);
  return getDataString(dataWithoutRepeatedValues);
};
function formatOmniboxMetadata(meta2) {
  const partialQueries = typeof meta2.partialQueries === "string" ? meta2.partialQueries : formatArrayForCoveoCustomData(meta2.partialQueries);
  const suggestions = typeof meta2.suggestions === "string" ? meta2.suggestions : formatArrayForCoveoCustomData(meta2.suggestions);
  return Object.assign(Object.assign({}, meta2), {
    partialQueries,
    suggestions
  });
}
class CoveoSearchPageClient {
  constructor(opts, provider) {
    this.opts = opts;
    this.provider = provider;
    const shouldDisableAnalytics = opts.enableAnalytics === false || doNotTrack();
    this.coveoAnalyticsClient = shouldDisableAnalytics ? new NoopAnalytics() : new CoveoAnalyticsClient(opts);
  }
  disable() {
    this.coveoAnalyticsClient = new NoopAnalytics();
  }
  enable() {
    this.coveoAnalyticsClient = new CoveoAnalyticsClient(this.opts);
  }
  makeInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents$1.interfaceLoad);
  }
  logInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationInterfaceLoad() {
    return this.makeSearchEvent(SearchPageEvents$1.recommendationInterfaceLoad);
  }
  logRecommendationInterfaceLoad() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationInterfaceLoad()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendation() {
    return this.makeCustomEvent(SearchPageEvents$1.recommendation);
  }
  logRecommendation() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendation()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecommendationOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents$1.recommendationOpen, info, identifier);
  }
  logRecommendationOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecommendationOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterClearAll(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.staticFilterClearAll, meta2);
  }
  logStaticFilterClearAll(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterClearAll(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterSelect(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.staticFilterSelect, meta2);
  }
  logStaticFilterSelect(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterSelect(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeStaticFilterDeselect(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.staticFilterDeselect, meta2);
  }
  logStaticFilterDeselect(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeStaticFilterDeselect(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFetchMoreResults() {
    return this.makeCustomEvent(SearchPageEvents$1.pagerScrolling, { type: "getMoreResults" });
  }
  logFetchMoreResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFetchMoreResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeInterfaceChange(metadata) {
    return this.makeSearchEvent(SearchPageEvents$1.interfaceChange, metadata);
  }
  logInterfaceChange(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeInterfaceChange(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanAutomatic() {
    return this.makeSearchEvent(SearchPageEvents$1.didyoumeanAutomatic);
  }
  logDidYouMeanAutomatic() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanAutomatic()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDidYouMeanClick() {
    return this.makeSearchEvent(SearchPageEvents$1.didyoumeanClick);
  }
  logDidYouMeanClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDidYouMeanClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeResultsSort(metadata) {
    return this.makeSearchEvent(SearchPageEvents$1.resultsSort, metadata);
  }
  logResultsSort(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeResultsSort(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxSubmit() {
    return this.makeSearchEvent(SearchPageEvents$1.searchboxSubmit);
  }
  logSearchboxSubmit() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxSubmit()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxClear() {
    return this.makeSearchEvent(SearchPageEvents$1.searchboxClear);
  }
  logSearchboxClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchboxAsYouType() {
    return this.makeSearchEvent(SearchPageEvents$1.searchboxAsYouType);
  }
  logSearchboxAsYouType() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchboxAsYouType()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbFacet(metadata) {
    return this.makeSearchEvent(SearchPageEvents$1.breadcrumbFacet, metadata);
  }
  logBreadcrumbFacet(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbFacet(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeBreadcrumbResetAll() {
    return this.makeSearchEvent(SearchPageEvents$1.breadcrumbResetAll);
  }
  logBreadcrumbResetAll() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeBreadcrumbResetAll()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentQuickview(info, identifier) {
    return this.makeClickEvent(SearchPageEvents$1.documentQuickview, info, identifier);
  }
  logDocumentQuickview(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentQuickview(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDocumentOpen(info, identifier) {
    return this.makeClickEvent(SearchPageEvents$1.documentOpen, info, identifier);
  }
  logDocumentOpen(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDocumentOpen(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxAnalytics(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.omniboxAnalytics, formatOmniboxMetadata(meta2));
  }
  logOmniboxAnalytics(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxAnalytics(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOmniboxFromLink(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.omniboxFromLink, formatOmniboxMetadata(meta2));
  }
  logOmniboxFromLink(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOmniboxFromLink(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchFromLink() {
    return this.makeSearchEvent(SearchPageEvents$1.searchFromLink);
  }
  logSearchFromLink() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchFromLink()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerNotify(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.triggerNotify, meta2);
  }
  logTriggerNotify(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerNotify(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerExecute(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.triggerExecute, meta2);
  }
  logTriggerExecute(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerExecute(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerQuery() {
    return this.makeCustomEvent(SearchPageEvents$1.triggerQuery, { query: this.provider.getSearchEventRequestPayload().queryText }, "queryPipelineTriggers");
  }
  logTriggerQuery() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerQuery()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeUndoTriggerQuery(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.undoTriggerQuery, meta2);
  }
  logUndoTriggerQuery(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeUndoTriggerQuery(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeTriggerRedirect(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.triggerRedirect, Object.assign(Object.assign({}, meta2), { query: this.provider.getSearchEventRequestPayload().queryText }));
  }
  logTriggerRedirect(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeTriggerRedirect(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerResize(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.pagerResize, meta2);
  }
  logPagerResize(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerResize(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNumber(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.pagerNumber, meta2);
  }
  logPagerNumber(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNumber(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerNext(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.pagerNext, meta2);
  }
  logPagerNext(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerNext(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerPrevious(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.pagerPrevious, meta2);
  }
  logPagerPrevious(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerPrevious(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makePagerScrolling() {
    return this.makeCustomEvent(SearchPageEvents$1.pagerScrolling);
  }
  logPagerScrolling() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makePagerScrolling()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetClearAll(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetClearAll, meta2);
  }
  logFacetClearAll(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetClearAll(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSearch(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetSearch, meta2);
  }
  logFacetSearch(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSearch(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelect(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetSelect, meta2);
  }
  logFacetSelect(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelect(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetDeselect(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetDeselect, meta2);
  }
  logFacetDeselect(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetDeselect(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetExclude(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetExclude, meta2);
  }
  logFacetExclude(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetExclude(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUnexclude(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetUnexclude, meta2);
  }
  logFacetUnexclude(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUnexclude(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetSelectAll(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetSelectAll, meta2);
  }
  logFacetSelectAll(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetSelectAll(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetUpdateSort(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.facetUpdateSort, meta2);
  }
  logFacetUpdateSort(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetUpdateSort(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowMore(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.facetShowMore, meta2);
  }
  logFacetShowMore(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowMore(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeFacetShowLess(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.facetShowLess, meta2);
  }
  logFacetShowLess(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeFacetShowLess(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryError(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.queryError, meta2);
  }
  logQueryError(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryError(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents$1.queryErrorBack);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents$1.queryErrorBack);
        })
      };
    });
  }
  logQueryErrorBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents$1.queryErrorRetry);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents$1.queryErrorRetry);
        })
      };
    });
  }
  logQueryErrorRetry() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorRetry()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      const customEventBuilder = yield this.makeCustomEvent(SearchPageEvents$1.queryErrorClear);
      return {
        description: customEventBuilder.description,
        log: () => __awaiter(this, void 0, void 0, function* () {
          yield customEventBuilder.log({ searchUID: this.provider.getSearchUID() });
          return this.logSearchEvent(SearchPageEvents$1.queryErrorClear);
        })
      };
    });
  }
  logQueryErrorClear() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeQueryErrorClear()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeLikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents$1.likeSmartSnippet);
  }
  logLikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents$1.dislikeSmartSnippet);
  }
  logDislikeSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeExpandSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents$1.expandSmartSnippet);
  }
  logExpandSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippet() {
    return this.makeCustomEvent(SearchPageEvents$1.collapseSmartSnippet);
  }
  logCollapseSmartSnippet() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippet()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents$1.openSmartSnippetFeedbackModal);
  }
  logOpenSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCloseSmartSnippetFeedbackModal() {
    return this.makeCustomEvent(SearchPageEvents$1.closeSmartSnippetFeedbackModal);
  }
  logCloseSmartSnippetFeedbackModal() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCloseSmartSnippetFeedbackModal()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSmartSnippetFeedbackReason(reason, details) {
    return this.makeCustomEvent(SearchPageEvents$1.sendSmartSnippetReason, { reason, details });
  }
  logSmartSnippetFeedbackReason(reason, details) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSmartSnippetFeedbackReason(reason, details)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeExpandSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents$1.expandSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logExpandSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeExpandSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCollapseSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents$1.collapseSmartSnippetSuggestion, "documentId" in snippet ? snippet : { documentId: snippet });
  }
  logCollapseSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCollapseSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents$1.showMoreSmartSnippetSuggestion, snippet);
  }
  logShowMoreSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessSmartSnippetSuggestion(snippet) {
    return this.makeCustomEvent(SearchPageEvents$1.showLessSmartSnippetSuggestion, snippet);
  }
  logShowLessSmartSnippetSuggestion(snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessSmartSnippetSuggestion(snippet)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSource(info, identifier) {
    return this.makeClickEvent(SearchPageEvents$1.openSmartSnippetSource, info, identifier);
  }
  logOpenSmartSnippetSource(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSource(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenSmartSnippetSuggestionSource(info, snippet) {
    return this.makeClickEvent(SearchPageEvents$1.openSmartSnippetSuggestionSource, info, { contentIDKey: snippet.documentId.contentIdKey, contentIDValue: snippet.documentId.contentIdValue }, snippet);
  }
  makeCopyToClipboard(info, identifier) {
    return this.makeClickEvent(SearchPageEvents$1.copyToClipboard, info, identifier);
  }
  logCopyToClipboard(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCopyToClipboard(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  logOpenSmartSnippetSuggestionSource(info, snippet) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionSource(info, snippet)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return this.makeClickEvent(SearchPageEvents$1.openSmartSnippetInlineLink, info, { contentIDKey: identifierAndLink.contentIDKey, contentIDValue: identifierAndLink.contentIDValue }, identifierAndLink);
  }
  logOpenSmartSnippetInlineLink(info, identifierAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetInlineLink(info, identifierAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return this.makeClickEvent(SearchPageEvents$1.openSmartSnippetSuggestionInlineLink, info, {
      contentIDKey: snippetAndLink.documentId.contentIdKey,
      contentIDValue: snippetAndLink.documentId.contentIdValue
    }, snippetAndLink);
  }
  logOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenSmartSnippetSuggestionInlineLink(info, snippetAndLink)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRecentQueryClick() {
    return this.makeSearchEvent(SearchPageEvents$1.recentQueryClick);
  }
  logRecentQueryClick() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentQueryClick()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentQueries() {
    return this.makeCustomEvent(SearchPageEvents$1.clearRecentQueries);
  }
  logClearRecentQueries() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentQueries()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRecentResultClick(info, identifier) {
    return this.makeCustomEvent(SearchPageEvents$1.recentResultClick, { info, identifier });
  }
  logRecentResultClick(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRecentResultClick(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeClearRecentResults() {
    return this.makeCustomEvent(SearchPageEvents$1.clearRecentResults);
  }
  logClearRecentResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClearRecentResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeNoResultsBack() {
    return this.makeSearchEvent(SearchPageEvents$1.noResultsBack);
  }
  logNoResultsBack() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeNoResultsBack()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowMoreFoldedResults(info, identifier) {
    return this.makeClickEvent(SearchPageEvents$1.showMoreFoldedResults, info, identifier);
  }
  logShowMoreFoldedResults(info, identifier) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowMoreFoldedResults(info, identifier)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeShowLessFoldedResults() {
    return this.makeCustomEvent(SearchPageEvents$1.showLessFoldedResults);
  }
  logShowLessFoldedResults() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeShowLessFoldedResults()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeEventDescription(preparedEvent, actionCause) {
    var _a;
    return { actionCause, customData: (_a = preparedEvent.payload) === null || _a === void 0 ? void 0 : _a.customData };
  }
  makeCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      this.coveoAnalyticsClient.getParameters;
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const request = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), { eventType, eventValue: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEvent(event_1, metadata_1) {
    return __awaiter(this, arguments, void 0, function* (event, metadata, eventType = CustomEventsTypes[event]) {
      return (yield this.makeCustomEvent(event, metadata, eventType)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      const payload = Object.assign(Object.assign({}, yield this.getBaseEventRequest(customData)), {
        eventType,
        eventValue
      });
      const preparedEvent = yield this.coveoAnalyticsClient.makeCustomEvent(payload);
      return {
        description: this.makeEventDescription(preparedEvent, eventValue),
        log: ({ searchUID }) => preparedEvent.log({ lastSearchQueryUid: searchUID })
      };
    });
  }
  logCustomEventWithType(eventValue, eventType, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeCustomEventWithType(eventValue, eventType, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  logSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeSearchEvent(event, metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeSearchEvent(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = yield this.getBaseSearchEventRequest(event, metadata);
      const preparedEvent = yield this.coveoAnalyticsClient.makeSearchEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  makeClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const request = Object.assign(Object.assign(Object.assign({}, info), yield this.getBaseEventRequest(Object.assign(Object.assign({}, identifier), metadata))), { queryPipeline: this.provider.getPipeline(), actionCause: event });
      const preparedEvent = yield this.coveoAnalyticsClient.makeClickEvent(request);
      return {
        description: this.makeEventDescription(preparedEvent, event),
        log: ({ searchUID }) => preparedEvent.log({ searchQueryUid: searchUID })
      };
    });
  }
  logClickEvent(event, info, identifier, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeClickEvent(event, info, identifier, metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  getBaseSearchEventRequest(event, metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      return Object.assign(Object.assign(Object.assign({}, yield this.getBaseEventRequest(Object.assign(Object.assign({}, metadata), (_b = (_a = this.provider).getGeneratedAnswerMetadata) === null || _b === void 0 ? void 0 : _b.call(_a)))), this.provider.getSearchEventRequestPayload()), { queryPipeline: this.provider.getPipeline(), actionCause: event });
    });
  }
  getBaseEventRequest(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      const customData = Object.assign(Object.assign({}, this.provider.getBaseMetadata()), metadata);
      return Object.assign(Object.assign(Object.assign({}, this.getOrigins()), this.getSplitTestRun()), { customData, language: this.provider.getLanguage(), facetState: this.provider.getFacetState ? this.provider.getFacetState() : [], anonymous: this.provider.getIsAnonymous(), clientId: yield this.getClientId() });
    });
  }
  getOrigins() {
    var _a, _b;
    return {
      originContext: (_b = (_a = this.provider).getOriginContext) === null || _b === void 0 ? void 0 : _b.call(_a),
      originLevel1: this.provider.getOriginLevel1(),
      originLevel2: this.provider.getOriginLevel2(),
      originLevel3: this.provider.getOriginLevel3()
    };
  }
  getClientId() {
    return this.coveoAnalyticsClient instanceof CoveoAnalyticsClient ? this.coveoAnalyticsClient.getCurrentVisitorId() : void 0;
  }
  getSplitTestRun() {
    const splitTestRunName = this.provider.getSplitTestRunName ? this.provider.getSplitTestRunName() : "";
    const splitTestRunVersion = this.provider.getSplitTestRunVersion ? this.provider.getSplitTestRunVersion() : "";
    return Object.assign(Object.assign({}, splitTestRunName && { splitTestRunName }), splitTestRunVersion && { splitTestRunVersion });
  }
  makeLikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.likeGeneratedAnswer, metadata);
  }
  logLikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeLikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeDislikeGeneratedAnswer(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.dislikeGeneratedAnswer, metadata);
  }
  logDislikeGeneratedAnswer(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeDislikeGeneratedAnswer(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeOpenGeneratedAnswerSource(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.openGeneratedAnswerSource, metadata);
  }
  logOpenGeneratedAnswerSource(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeOpenGeneratedAnswerSource(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCitationClick(info, citation) {
    return this.makeClickEvent(SearchPageEvents$1.generatedAnswerCitationClick, Object.assign(Object.assign({}, info), { documentPosition: 1 }), { contentIDKey: citation.documentId.contentIdKey, contentIDValue: citation.documentId.contentIdValue }, citation);
  }
  logGeneratedAnswerCitationClick(info, citation) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCitationClick(info, citation)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerSourceHover(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerSourceHover, metadata);
  }
  logGeneratedAnswerSourceHover(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerSourceHover(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerCopyToClipboard(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerCopyToClipboard, metadata);
  }
  logGeneratedAnswerCopyToClipboard(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCopyToClipboard(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerHideAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerHideAnswers, metadata);
  }
  logGeneratedAnswerHideAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerHideAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerShowAnswers(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerShowAnswers, metadata);
  }
  logGeneratedAnswerShowAnswers(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerShowAnswers(metadata)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerExpand(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerExpand, metadata);
  }
  logGeneratedAnswerExpand(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerExpand(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerCollapse(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerCollapse, metadata);
  }
  logGeneratedAnswerCollapse(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerCollapse(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerFeedbackSubmit(meta2) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerFeedbackSubmit, meta2);
  }
  logGeneratedAnswerFeedbackSubmit(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmit(meta2)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeGeneratedAnswerFeedbackSubmitV2(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerFeedbackSubmitV2, metadata);
  }
  logGeneratedAnswerFeedbackSubmitV2(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerFeedbackSubmitV2(meta2)).log({
        searchUID: this.provider.getSearchUID()
      });
    });
  }
  makeRephraseGeneratedAnswer(meta2) {
    return this.makeSearchEvent(SearchPageEvents$1.rephraseGeneratedAnswer, meta2);
  }
  logRephraseGeneratedAnswer(meta2) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRephraseGeneratedAnswer(meta2)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeRetryGeneratedAnswer() {
    return this.makeSearchEvent(SearchPageEvents$1.retryGeneratedAnswer);
  }
  logRetryGeneratedAnswer() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeRetryGeneratedAnswer()).log({ searchUID: this.provider.getSearchUID() });
    });
  }
  makeGeneratedAnswerStreamEnd(metadata) {
    return this.makeCustomEvent(SearchPageEvents$1.generatedAnswerStreamEnd, metadata);
  }
  logGeneratedAnswerStreamEnd(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.makeGeneratedAnswerStreamEnd(metadata)).log({ searchUID: this.provider.getSearchUID() });
    });
  }
}
const SVCPluginEventTypes = Object.assign({}, BasePluginEventTypes);
Object.keys(SVCPluginEventTypes).map((key) => SVCPluginEventTypes[key]);
var CaseAssistEvents;
(function(CaseAssistEvents2) {
  CaseAssistEvents2["click"] = "click";
  CaseAssistEvents2["flowStart"] = "flowStart";
})(CaseAssistEvents || (CaseAssistEvents = {}));
var CaseAssistActions;
(function(CaseAssistActions2) {
  CaseAssistActions2["enterInterface"] = "ticket_create_start";
  CaseAssistActions2["fieldUpdate"] = "ticket_field_update";
  CaseAssistActions2["fieldSuggestionClick"] = "ticket_classification_click";
  CaseAssistActions2["documentSuggestionClick"] = "documentSuggestionClick";
  CaseAssistActions2["documentSuggestionQuickview"] = "documentSuggestionQuickview";
  CaseAssistActions2["suggestionRate"] = "suggestion_rate";
  CaseAssistActions2["nextCaseStep"] = "ticket_next_stage";
  CaseAssistActions2["caseCancelled"] = "ticket_cancel";
  CaseAssistActions2["caseSolved"] = "ticket_cancel";
  CaseAssistActions2["caseCreated"] = "ticket_create";
})(CaseAssistActions || (CaseAssistActions = {}));
var CaseCancelledReasons;
(function(CaseCancelledReasons2) {
  CaseCancelledReasons2["quit"] = "Quit";
  CaseCancelledReasons2["solved"] = "Solved";
})(CaseCancelledReasons || (CaseCancelledReasons = {}));
const getSearchHubInitialState = () => "default";
const getLanguage = (state) => {
  const langKey = state.configuration.search.locale.split("-")[0];
  if (!langKey || langKey.length !== 2) {
    return "en";
  }
  return langKey;
};
class BaseAnalyticsProvider {
  getState;
  state;
  constructor(getState) {
    this.getState = getState;
    this.state = getState();
  }
  getLanguage() {
    return getLanguage(this.state);
  }
  getBaseMetadata() {
    const { context, configuration: configuration2 } = this.state;
    const contextValues = context?.contextValues || {};
    const formattedObject = {};
    for (const [key, value] of Object.entries(contextValues)) {
      const formattedKey = `context_${key}`;
      formattedObject[formattedKey] = value;
    }
    if (configuration2.analytics.analyticsMode === "legacy") {
      formattedObject.coveoHeadlessVersion = VERSION;
    }
    return formattedObject;
  }
  getOriginContext() {
    return this.state.configuration.analytics.originContext;
  }
  getOriginLevel1() {
    return this.state.searchHub || getSearchHubInitialState();
  }
  getOriginLevel2() {
    return this.state.configuration.analytics.originLevel2;
  }
  getOriginLevel3() {
    return this.state.configuration.analytics.originLevel3;
  }
  getIsAnonymous() {
    return this.state.configuration.analytics.anonymous;
  }
}
const getVisitorID = (options2) => new CoveoAnalyticsClient(options2).getCurrentVisitorId();
const wrapPreprocessRequest = (logger, preprocessRequest) => {
  return typeof preprocessRequest === "function" ? (...args) => {
    const untaintedOutput = clone(args[0]);
    try {
      return preprocessRequest.apply(preprocessRequest, args);
    } catch (e) {
      logger.error(e, "Error in analytics preprocessRequest. Returning original request.");
      return untaintedOutput;
    }
  } : void 0;
};
const wrapAnalyticsClientSendEventHook = (logger, hook) => {
  return (...args) => {
    const untaintedOutput = clone(args[1]);
    try {
      return hook.apply(hook, args);
    } catch (e) {
      logger.error(e, "Error in analytics hook. Returning original request.");
      return untaintedOutput;
    }
  };
};
const DESIRED_COUNT_MINIMUM = 1;
const DESIRED_COUNT_MAXIMUM = 20;
const DESIRED_COUNT_DEFAULT = 5;
const NUMBER_OF_VALUE_MINIMUM = 1;
const NUMBER_OF_VALUE_DEFAULT = 8;
function getAutomaticFacetSetInitialState() {
  return {
    desiredCount: DESIRED_COUNT_DEFAULT,
    numberOfValues: NUMBER_OF_VALUE_DEFAULT,
    set: {}
  };
}
function isFacetResponse(state, response) {
  return !!response && response.facetId in state.facetSet;
}
const baseFacetResponseSelector = (state, id2) => state.search?.response.facets.find((response) => response.facetId === id2);
const facetRequestSelector$1 = (state, id2) => state.facetSet[id2]?.request;
const facetResponseSelector$2 = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  return isFacetResponse(state, response) ? response : void 0;
};
const facetResponseActiveValuesSelector = (state, facetId2) => facetResponseSelector$2(state, facetId2)?.values.filter((value) => value.state !== "idle") || [];
const isFacetLoadingResponseSelector$2 = (state) => state.search.isLoading;
function partitionIntoParentsAndValues(nestedValues) {
  if (!nestedValues) {
    return { parents: [], values: [] };
  }
  let parents = [];
  let values = nestedValues;
  while (values.length && values[0].children.length) {
    parents = [...parents, ...values];
    values = values[0].children;
  }
  const selectedLeafValue = values.find((v) => v.state === "selected");
  if (selectedLeafValue) {
    parents = [...parents, selectedLeafValue];
    values = [];
  }
  return { parents, values };
}
function findActiveValueAncestry(valuesAsTree) {
  const { activeValue, ancestryMap } = getActiveValueAndAncestryFromValueTree(valuesAsTree);
  return activeValue ? getActiveValueAncestry(activeValue, ancestryMap) : [];
}
function getActiveValueAndAncestryFromValueTree(valuesAsTrees) {
  const valueToVisit = [...valuesAsTrees];
  const ancestryMap = /* @__PURE__ */ new Map();
  while (valueToVisit.length > 0) {
    const currentValue = valueToVisit.shift();
    if (currentValue.state === "selected") {
      return { activeValue: currentValue, ancestryMap };
    }
    if (ancestryMap) {
      for (const childValue of currentValue.children) {
        ancestryMap.set(childValue, currentValue);
      }
    }
    valueToVisit.unshift(...currentValue.children);
  }
  return {};
}
function getActiveValueAncestry(activeValue, valueToParentMap) {
  const activeValueAncestry = [];
  if (!activeValue) {
    return [];
  }
  let lastParent = activeValue;
  do {
    activeValueAncestry.unshift(lastParent);
    lastParent = valueToParentMap.get(lastParent);
  } while (lastParent);
  return activeValueAncestry;
}
function isCategoryFacetResponse$1(state, response) {
  return !!response && response.facetId in state.categoryFacetSet;
}
const categoryFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isCategoryFacetResponse$1(state, response)) {
    return response;
  }
  return void 0;
};
const categoryFacetRequestSelector = (state, id2) => {
  return state.categoryFacetSet[id2]?.request;
};
const categoryFacetResponseSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = categoryFacetResponseSelector(state, facetId2);
  return findActiveValueAncestry(facetResponse?.values ?? []);
};
const categoryFacetRequestSelectedValuesSelector = (state, facetId2) => {
  const facetRequest = categoryFacetRequestSelector(state, facetId2);
  return findActiveValueAncestry(facetRequest?.currentValues ?? []);
};
function getCategoryFacetSetInitialState() {
  return {};
}
function getDateFacetSetSliceInitialState(request) {
  return { request };
}
function getDateFacetSetInitialState() {
  return {};
}
function getNumericFacetSetSliceInitialState(request) {
  return { request };
}
function getNumericFacetSetInitialState() {
  return {};
}
function getFacetSetSliceInitialState(request) {
  return { request, hasBreadcrumbs: true };
}
function getFacetSetInitialState() {
  return {};
}
const buildFacetBaseMetadata = (facetId2, state) => {
  const facet = getFacetRequest(state, facetId2);
  const facetField = facet ? facet.field : "";
  const facetTitle = getFacetTitle(facetField, facetId2);
  return { facetId: facetId2, facetField, facetTitle };
};
function buildFacetSelectionChangeMetadata(payload, state) {
  const { facetId: facetId2, facetValue } = payload;
  const base = buildFacetBaseMetadata(facetId2, state);
  const facetType = getFacetType(state, facetId2);
  return {
    ...base,
    facetValue: facetType === "hierarchical" ? getCategoryFacetSelectedValue(state, facetId2) : facetValue
  };
}
function getStateNeededForFacetMetadata(s) {
  return {
    facetSet: s.facetSet ?? getFacetSetInitialState(),
    categoryFacetSet: s.categoryFacetSet ?? getCategoryFacetSetInitialState(),
    dateFacetSet: s.dateFacetSet ?? getDateFacetSetInitialState(),
    numericFacetSet: s.numericFacetSet ?? getNumericFacetSetInitialState(),
    automaticFacetSet: s.automaticFacetSet ?? getAutomaticFacetSetInitialState()
  };
}
const buildFacetStateMetadata = (state) => {
  const facetState = [];
  getFacetRequests$1(state).forEach((facetRequest, facetIndex) => {
    const facetType = getFacetType(state, facetRequest.facetId);
    const facetRequestAnalytics = mapFacetRequestToAnalytics(facetRequest, facetIndex + 1);
    if (isCategoryFacetRequest$1(facetRequest)) {
      const hasSelectedValue = !!categoryFacetRequestSelectedValuesSelector(state, facetRequest.facetId).length;
      if (!hasSelectedValue) {
        return;
      }
      facetState.push({
        ...facetRequestAnalytics,
        ...mapCategoryFacetValueToAnalytics(state, facetRequest.facetId),
        facetType,
        state: "selected"
      });
      return;
    }
    facetRequest.currentValues.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(facetValue, facetValueIndex + 1, facetType);
      const facetDisplayValueAnalytics = isSpecificFacetRequest(facetRequest) ? mapFacetDisplayValueToAnalytics(facetValue) : mapRangeDisplayFacetValueToAnalytics(facetValue);
      facetState.push({
        ...facetRequestAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  getAutomaticFacets$3(state).forEach((facet, facetIndex) => {
    const facetAnalytics = mapAutomaticFacetToAnalytics(facet, facetIndex + 1);
    facet.values.forEach((facetValue, facetValueIndex) => {
      if (facetValue.state === "idle") {
        return;
      }
      const facetValueAnalytics = mapFacetValueToAnalytics(facetValue, facetValueIndex + 1, "specific");
      const facetDisplayValueAnalytics = mapFacetDisplayValueToAnalytics(facetValue);
      facetState.push({
        ...facetAnalytics,
        ...facetValueAnalytics,
        ...facetDisplayValueAnalytics
      });
    });
  });
  return facetState;
};
const isSpecificFacetRequest = (request) => request.type === "specific";
const isCategoryFacetRequest$1 = (request) => request.type === "hierarchical";
const getFacetRequests$1 = (state) => {
  return [
    ...Object.values(state.facetSet),
    ...Object.values(state.categoryFacetSet),
    ...Object.values(state.dateFacetSet),
    ...Object.values(state.numericFacetSet)
  ].map((facet) => facet.request);
};
const getAutomaticFacets$3 = (state) => {
  return [...Object.values(state.automaticFacetSet.set)].map((facet) => facet.response);
};
const mapFacetValueToAnalytics = (facetValue, valuePosition, facetType) => {
  return {
    state: facetValue.state,
    valuePosition,
    facetType
  };
};
const mapRangeDisplayFacetValueToAnalytics = (facetValue) => {
  return {
    displayValue: `${facetValue.start}..${facetValue.end}`,
    value: `${facetValue.start}..${facetValue.end}`,
    start: facetValue.start,
    end: facetValue.end,
    endInclusive: facetValue.endInclusive
  };
};
const mapFacetDisplayValueToAnalytics = (facetValue) => {
  return {
    displayValue: facetValue.value,
    value: facetValue.value
  };
};
const getCategoryFacetSelectedValue = (state, facetId2) => {
  const selectedCategoryFacetValues = categoryFacetRequestSelectedValuesSelector(state, facetId2);
  return selectedCategoryFacetValues.map((selectedCategoryFacetValue) => selectedCategoryFacetValue.value).join(";");
};
const mapCategoryFacetValueToAnalytics = (state, facetId2) => {
  const valuePosition = 1;
  const value = getCategoryFacetSelectedValue(state, facetId2);
  return {
    value,
    valuePosition,
    displayValue: value
  };
};
const mapAutomaticFacetToAnalytics = (facet, facetPosition) => {
  return {
    title: getFacetTitle(facet.field, facet.field),
    field: facet.field,
    id: facet.field,
    facetPosition
  };
};
const mapFacetRequestToAnalytics = (request, facetPosition) => {
  return {
    title: getFacetTitle(request.field, request.facetId),
    field: request.field,
    id: request.facetId,
    facetPosition
  };
};
const getFacetTitle = (field2, facetId2) => {
  return `${field2}_${facetId2}`;
};
const getFacetRequest = (state, facetId2) => {
  return state.facetSet[facetId2]?.request || state.categoryFacetSet[facetId2]?.request || state.dateFacetSet[facetId2]?.request || state.numericFacetSet[facetId2]?.request || state.automaticFacetSet.set[facetId2]?.response;
};
const getFacetType = (state, facetId2) => {
  const facet = getFacetRequest(state, facetId2);
  return facet ? facet.type : "specific";
};
const generativeQuestionAnsweringIdSelector = (state) => {
  if (isGeneratedAnswerSection(state)) {
    return state.generatedAnswer?.answerId;
  }
  if (isSearchSection(state)) {
    return state.search?.response?.extendedResults?.generativeQuestionAnsweringId;
  }
  return void 0;
};
const isGeneratedAnswerSection = (state) => "answer" in state && "generatedAnswer" in state && !isNullOrUndefined(state.generatedAnswer?.answerConfigurationId);
const isSearchSection = (state) => "search" in state && state.search !== void 0 && typeof state.search === "object";
const selectFieldsToIncludeInCitation = (state) => state.generatedAnswer?.fieldsToIncludeInCitations;
createSelector((state) => state.generatedAnswer?.citations, (_state, citationId) => citationId, (citations, citationId) => citations?.find((citation) => citation.id === citationId));
const getQueryInitialState = () => ({
  q: "",
  enableQuerySyntax: false
});
var SortOrder;
(function(SortOrder2) {
  SortOrder2["Ascending"] = "ascending";
  SortOrder2["Descending"] = "descending";
})(SortOrder || (SortOrder = {}));
var SortBy$1;
(function(SortBy2) {
  SortBy2["Relevancy"] = "relevancy";
  SortBy2["QRE"] = "qre";
  SortBy2["Date"] = "date";
  SortBy2["Field"] = "field";
  SortBy2["NoSort"] = "nosort";
})(SortBy$1 || (SortBy$1 = {}));
const buildCriterionExpression$1 = (criterion) => {
  if (isArray$2(criterion)) {
    return criterion.map((c) => buildCriterionExpression$1(c)).join(",");
  }
  switch (criterion.by) {
    case SortBy$1.Relevancy:
    case SortBy$1.QRE:
    case SortBy$1.NoSort:
      return criterion.by;
    case SortBy$1.Date:
      return `date ${criterion.order}`;
    case SortBy$1.Field:
      return `@${criterion.field} ${criterion.order}`;
    default:
      return "";
  }
};
const buildRelevanceSortCriterion$1 = () => ({
  by: SortBy$1.Relevancy
});
const buildDateSortCriterion = (order) => ({
  by: SortBy$1.Date,
  order
});
const buildFieldSortCriterion = (field2, order) => ({
  by: SortBy$1.Field,
  order,
  field: field2
});
const criterionDefinition$1 = new RecordValue({
  values: {
    by: new EnumValue({ enum: SortBy$1, required: true }),
    order: new EnumValue({ enum: SortOrder }),
    field: new StringValue()
  }
});
function getSortCriteriaInitialState() {
  return buildCriterionExpression$1(buildRelevanceSortCriterion$1());
}
class Cookie2 {
  static set(name, value, expire) {
    let domain, expirationDate, domainParts;
    if (expire) {
      expirationDate = /* @__PURE__ */ new Date();
      expirationDate.setTime(expirationDate.getTime() + expire);
    }
    const host = window.location.hostname;
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
    if (ipv4Regex.test(host) || ipv6Regex.test(host)) {
      writeCookie(name, value, expirationDate);
    } else if (host.indexOf(".") === -1) {
      writeCookie(name, value, expirationDate);
    } else {
      domainParts = host.split(".");
      domain = domainParts[domainParts.length - 2] + "." + domainParts[domainParts.length - 1];
      writeCookie(name, value, expirationDate, domain);
    }
  }
  static get(name) {
    const cookiePrefix = name + "=";
    const cookieArray = document.cookie.split(";");
    for (let i = 0; i < cookieArray.length; i++) {
      let cookie = cookieArray[i];
      cookie = cookie.replace(/^\s+/, "");
      if (cookie.lastIndexOf(cookiePrefix, 0) === 0) {
        return cookie.substring(cookiePrefix.length, cookie.length);
      }
    }
    return null;
  }
  static erase(name) {
    Cookie2.set(name, "", -1);
  }
}
function writeCookie(name, value, expirationDate, domain) {
  document.cookie = `${name}=${value}` + (expirationDate ? `;expires=${expirationDate.toUTCString()}` : "") + (domain ? `;domain=${domain}` : "") + ";path=/;SameSite=Lax";
}
function hasNavigator() {
  return typeof navigator !== "undefined";
}
function hasLocalStorage() {
  try {
    return typeof localStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasSessionStorage() {
  try {
    return typeof sessionStorage !== "undefined";
  } catch (error) {
    return false;
  }
}
function hasCookieStorage() {
  return Boolean(hasNavigator() && navigator.cookieEnabled);
}
function getAvailableStorage() {
  if (hasLocalStorage()) {
    return localStorage;
  }
  if (hasCookieStorage()) {
    return new CookieStorage2();
  }
  if (hasSessionStorage()) {
    return sessionStorage;
  }
  return new NullStorage2();
}
class CookieStorage2 {
  static prefix = "coveo_";
  getItem(key) {
    return Cookie2.get(`${CookieStorage2.prefix}${key}`);
  }
  removeItem(key) {
    Cookie2.erase(`${CookieStorage2.prefix}${key}`);
  }
  setItem(key, data, expire) {
    Cookie2.set(`${CookieStorage2.prefix}${key}`, data, expire);
  }
}
class NullStorage2 {
  getItem(_key) {
    return null;
  }
  removeItem(_key) {
  }
  setItem(_key, _data) {
  }
}
const STORE_KEY = "__coveo.analytics.history";
const MAX_NUMBER_OF_HISTORY_ELEMENTS = 20;
const MIN_THRESHOLD_FOR_DUPLICATE_VALUE = 1e3 * 60;
const MAX_VALUE_SIZE = 75;
class HistoryStore2 {
  static instance = null;
  static getInstance(store) {
    if (!HistoryStore2.instance) {
      HistoryStore2.instance = new HistoryStore2(store);
    }
    return HistoryStore2.instance;
  }
  store;
  constructor(store) {
    this.store = store || getAvailableStorage();
  }
  /**
   * @deprecated Synchronous method is deprecated, use addElementAsync instead. This method will NOT work with react-native.
   */
  addElement(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = this.getHistoryWithInternalTime();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  async addElementAsync(elem) {
    elem.internalTime = (/* @__PURE__ */ new Date()).getTime();
    elem = this.cropQueryElement(this.stripEmptyQuery(elem));
    const currentHistory = await this.getHistoryWithInternalTimeAsync();
    if (currentHistory !== null) {
      if (this.isValidEntry(elem)) {
        this.setHistory([elem].concat(currentHistory));
      }
    } else {
      this.setHistory([elem]);
    }
  }
  /**
   * @deprecated Synchronous method is deprecated, use getHistoryAsync instead. This method will NOT work with react-native.
   */
  getHistory() {
    const history2 = this.getHistoryWithInternalTime();
    return this.stripEmptyQueries(this.stripInternalTime(history2));
  }
  async getHistoryAsync() {
    const history2 = await this.getHistoryWithInternalTimeAsync();
    return this.stripEmptyQueries(this.stripInternalTime(history2));
  }
  getHistoryWithInternalTime() {
    try {
      const elements = this.store.getItem(STORE_KEY);
      if (elements && typeof elements === "string") {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  async getHistoryWithInternalTimeAsync() {
    try {
      const elements = await this.store.getItem(STORE_KEY);
      if (elements) {
        return JSON.parse(elements);
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
  }
  setHistory(history2) {
    try {
      this.store.setItem(STORE_KEY, JSON.stringify(history2.slice(0, MAX_NUMBER_OF_HISTORY_ELEMENTS)));
    } catch (e) {
    }
  }
  clear() {
    try {
      this.store.removeItem(STORE_KEY);
    } catch (e) {
    }
  }
  getMostRecentElement() {
    const currentHistory = this.getHistoryWithInternalTime();
    if (Array.isArray(currentHistory)) {
      const sorted = currentHistory.sort((first, second) => {
        return (second.internalTime || 0) - (first.internalTime || 0);
      });
      return sorted[0];
    }
    return null;
  }
  cropQueryElement(part) {
    if (part.name && part.value && part.name.toLowerCase() === "query") {
      part.value = part.value.slice(0, MAX_VALUE_SIZE);
    }
    return part;
  }
  isValidEntry(elem) {
    const lastEntry = this.getMostRecentElement();
    if (lastEntry && lastEntry.value === elem.value) {
      return (elem.internalTime || 0) - (lastEntry.internalTime || 0) > MIN_THRESHOLD_FOR_DUPLICATE_VALUE;
    }
    return true;
  }
  stripInternalTime(history2) {
    if (Array.isArray(history2)) {
      return history2.map((part) => {
        const { name, time: time2, value } = part;
        return { name, time: time2, value };
      });
    }
    return [];
  }
  stripEmptyQuery(part) {
    const { name, time: time2, value } = part;
    if (name && typeof value === "string" && name.toLowerCase() === "query" && value.trim() === "") {
      return { name, time: time2 };
    }
    return part;
  }
  stripEmptyQueries(history2) {
    return history2.map((part) => this.stripEmptyQuery(part));
  }
}
class SearchAnalyticsProvider extends BaseAnalyticsProvider {
  static fallbackPipelineName = "default";
  getFacetState() {
    return buildFacetStateMetadata(getStateNeededForFacetMetadata(this.getState()));
  }
  getPipeline() {
    return this.state.pipeline || this.state.search?.response.pipeline || SearchAnalyticsProvider.fallbackPipelineName;
  }
  getSearchEventRequestPayload() {
    return {
      queryText: this.queryText,
      responseTime: this.responseTime,
      results: this.resultURIs,
      numberOfResults: this.numberOfResults
    };
  }
  getSearchUID() {
    const newState = this.getState();
    return newState.search?.searchResponseId || newState.search?.response.searchUid || getSearchInitialState().response.searchUid;
  }
  getSplitTestRunName() {
    return this.state.search?.response.splitTestRun;
  }
  getSplitTestRunVersion() {
    const hasSplitTestRun = !!this.getSplitTestRunName();
    const effectivePipelineWithSplitTestRun = this.state.search?.response.pipeline || this.state.pipeline || SearchAnalyticsProvider.fallbackPipelineName;
    return hasSplitTestRun ? effectivePipelineWithSplitTestRun : void 0;
  }
  getBaseMetadata() {
    const state = this.getState();
    const baseObject = super.getBaseMetadata();
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    if (generativeQuestionAnsweringId) {
      baseObject.generativeQuestionAnsweringId = generativeQuestionAnsweringId;
    }
    return baseObject;
  }
  getFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetValue,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetClearAllMetadata(facetId2) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetUpdateSortMetadata(facetId2, criteria2) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      criteria: criteria2,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getRangeBreadcrumbFacetMetadata(facetId2, facetValue) {
    const facetRequest = this.getFacetRequest(facetId2);
    const facetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      facetId: facetId2,
      facetField,
      facetRangeEnd: facetValue.end,
      facetRangeEndInclusive: facetValue.endInclusive,
      facetRangeStart: facetValue.start,
      facetTitle: `${facetField}_${facetId2}`
    };
  }
  getFacetRequest = (id2) => {
    return this.state.facetSet?.[id2]?.request || this.state.categoryFacetSet?.[id2]?.request || this.state.dateFacetSet?.[id2]?.request || this.state.numericFacetSet?.[id2]?.request || this.state.automaticFacetSet?.set[id2]?.response;
  };
  getResultSortMetadata() {
    return {
      ...this.getBaseMetadata(),
      resultsSortBy: this.state.sortCriteria ?? getSortCriteriaInitialState()
    };
  }
  getStaticFilterToggleMetadata(staticFilterId, staticFilterValue) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId,
      staticFilterValue
    };
  }
  getStaticFilterClearAllMetadata(staticFilterId) {
    return {
      ...this.getBaseMetadata(),
      staticFilterId
    };
  }
  getUndoTriggerQueryMetadata(undoneQuery) {
    return {
      ...this.getBaseMetadata(),
      undoneQuery
    };
  }
  getCategoryBreadcrumbFacetMetadata(categoryFacetId, categoryFacetPath) {
    const facetRequest = this.getFacetRequest(categoryFacetId);
    const categoryFacetField = facetRequest?.field ?? "";
    return {
      ...this.getBaseMetadata(),
      categoryFacetId,
      categoryFacetField,
      categoryFacetPath,
      categoryFacetTitle: `${categoryFacetField}_${categoryFacetId}`
    };
  }
  getOmniboxAnalyticsMetadata(id2, suggestion) {
    const querySuggest = this.state.querySuggest?.[id2];
    const suggestions = querySuggest.completions.map((completion) => completion.expression);
    const lastIndex = querySuggest.partialQueries.length - 1;
    const partialQuery = querySuggest.partialQueries[lastIndex] || "";
    const querySuggestResponseId = querySuggest.responseId;
    return {
      ...this.getBaseMetadata(),
      suggestionRanking: suggestions.indexOf(suggestion),
      partialQuery,
      partialQueries: querySuggest.partialQueries.length > 0 ? querySuggest.partialQueries : "",
      suggestions: suggestions.length > 0 ? suggestions : "",
      querySuggestResponseId
    };
  }
  getInterfaceChangeMetadata() {
    return {
      ...this.getBaseMetadata(),
      interfaceChangeTo: this.state.configuration.analytics.originLevel2
    };
  }
  getOmniboxFromLinkMetadata(metadata) {
    return {
      ...this.getBaseMetadata(),
      ...metadata
    };
  }
  getGeneratedAnswerMetadata() {
    const state = this.getState();
    const formattedObject = {};
    if (state.generatedAnswer?.isVisible !== void 0) {
      formattedObject.showGeneratedAnswer = state.generatedAnswer.isVisible;
    }
    return formattedObject;
  }
  get resultURIs() {
    return this.results?.map((r) => ({
      documentUri: r.uri,
      documentUriHash: r.raw.urihash
    }));
  }
  get results() {
    return this.state.search?.response.results;
  }
  get queryText() {
    return this.state.query?.q || getQueryInitialState().q;
  }
  get responseTime() {
    return this.state.search?.duration || getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.state.search?.response.totalCountFiltered || getSearchInitialState().response.totalCountFiltered;
  }
}
const configureLegacyAnalytics = ({ logger, getState, analyticsClientMiddleware = (_, p) => p, preprocessRequest, provider }) => {
  const state = getState();
  const token = state.configuration.accessToken;
  const endpoint = state.configuration.analytics.apiBaseUrl ?? getOrganizationEndpoint(state.configuration.organizationId, state.configuration.environment, "analytics");
  const runtimeEnvironment = state.configuration.analytics.runtimeEnvironment;
  const enableAnalytics2 = state.configuration.analytics.enabled;
  const client = new CoveoSearchPageClient({
    token,
    endpoint,
    runtimeEnvironment,
    preprocessRequest: wrapPreprocessRequest(logger, preprocessRequest),
    beforeSendHooks: [
      wrapAnalyticsClientSendEventHook(logger, analyticsClientMiddleware),
      (type, payload) => {
        logger.info({
          ...payload,
          type,
          endpoint,
          token
        }, "Analytics request");
        return payload;
      }
    ]
  }, provider);
  if (!enableAnalytics2) {
    client.disable();
  }
  return client;
};
const getPageID = () => {
  const actions2 = HistoryStore2.getInstance().getHistory();
  const lastPageView = actions2.reverse().find((action) => {
    return action.name === "PageView" && action.value;
  });
  if (!lastPageView) {
    return "";
  }
  return lastPageView.value;
};
function getAllIncludedResultsFrom(relevantResult) {
  const foldedResults = getChildResultsRecursively(relevantResult);
  const parentResults = [relevantResult, ...foldedResults].filter((result) => result.parentResult).map((result) => result.parentResult);
  const resultsInCollection = removeDuplicates([relevantResult, ...foldedResults, ...parentResults], (result) => result.uniqueId);
  return resultsInCollection;
}
function getChildResultsRecursively(result) {
  if (!result.childResults) {
    return [];
  }
  return result.childResults.flatMap((childResult) => [
    childResult,
    ...getChildResultsRecursively(childResult)
  ]);
}
const getPipelineInitialState = () => "";
function makeBasicNewSearchAnalyticsAction(actionCause, getState) {
  return {
    ...new SearchAnalyticsProvider(getState).getBaseMetadata(),
    actionCause,
    type: actionCause
  };
}
function makeInstantlyCallable(action) {
  return Object.assign(action, { instantlyCallable: true });
}
function makePreparableAnalyticsAction(prefix, buildEvent) {
  const createAnalyticsAction = (body) => makeInstantlyCallable(createAsyncThunk(prefix, body));
  const rootAction = createAnalyticsAction(async (_, { getState, extra }) => {
    const { analyticsClientMiddleware, preprocessRequest, logger } = extra;
    return await (await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    })).log({ state: getState(), extra });
  });
  const prepare = async ({ getState, analyticsClientMiddleware, preprocessRequest, logger }) => {
    const { description, log } = await buildEvent({
      getState,
      analyticsClientMiddleware,
      preprocessRequest,
      logger
    });
    return {
      description,
      action: createAnalyticsAction(async (_, { getState: getNewState, extra: newExtra }) => {
        return await log({ state: getNewState(), extra: newExtra });
      })
    };
  };
  Object.assign(rootAction, {
    prepare
  });
  return rootAction;
}
const makeAnalyticsActionFactory = (configurator, legacyGetBuilderConverter, providerClass) => {
  function makeAnalyticsAction2(...params) {
    const options2 = params.length === 1 ? {
      ...params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[0].__legacy__getBuilder),
      analyticsConfigurator: configurator,
      providerClass
    } : {
      prefix: params[0],
      __legacy__getBuilder: legacyGetBuilderConverter(params[1]),
      __legacy__provider: params[2],
      analyticsConfigurator: configurator,
      providerClass
    };
    return internalMakeAnalyticsAction(options2);
  }
  return makeAnalyticsAction2;
};
const shouldSendLegacyEvent = (state) => state.configuration.analytics.analyticsMode === "legacy";
const shouldSendNextEvent = (state) => state.configuration.analytics.analyticsMode === "next";
const internalMakeAnalyticsAction = ({ prefix, __legacy__getBuilder, __legacy__provider, analyticsPayloadBuilder, analyticsType, analyticsConfigurator, providerClass }) => {
  __legacy__provider ??= (getState) => new providerClass(getState);
  return makePreparableAnalyticsAction(prefix, async ({ getState, analyticsClientMiddleware, preprocessRequest, logger }) => {
    const loggers = [];
    const analyticsAction = {
      log: async ({ state: state2 }) => {
        for (const log of loggers) {
          await log(state2);
        }
      }
    };
    const state = getState();
    const client = analyticsConfigurator({
      getState,
      logger,
      analyticsClientMiddleware,
      preprocessRequest,
      provider: __legacy__provider(getState)
    });
    const builder = await __legacy__getBuilder(client, getState());
    analyticsAction.description = builder?.description;
    loggers.push(async (state2) => {
      if (shouldSendLegacyEvent(state2)) {
        await logLegacyEvent(builder, __legacy__provider, state2, logger, client.coveoAnalyticsClient);
      }
    });
    const { emit: emit2 } = getRelayInstanceFromState(state);
    loggers.push(async (state2) => {
      if (shouldSendNextEvent(state2) && analyticsType && analyticsPayloadBuilder) {
        const payload = analyticsPayloadBuilder(state2);
        await logNextEvent(emit2, analyticsType, payload);
      }
    });
    return analyticsAction;
  });
};
async function logLegacyEvent(builder, __legacy__provider, state, logger, client) {
  __legacy__provider(() => state);
  const response = await builder?.log({
    searchUID: __legacy__provider(() => state).getSearchUID()
  });
  logger.info({ client, response }, "Analytics response");
}
const makeAnalyticsAction = makeAnalyticsActionFactory((options2) => configureLegacyAnalytics({
  ...options2,
  provider: options2.provider || new SearchAnalyticsProvider(options2.getState)
}), (original2) => original2, SearchAnalyticsProvider);
const partialDocumentInformation = (result, state) => {
  const paginationBasedIndex = (index) => index + (state.pagination?.firstResult ?? 0);
  let resultIndex = -1;
  const parentResults = state.search?.results;
  resultIndex = findPositionWithUniqueId(result, parentResults);
  if (resultIndex < 0) {
    resultIndex = findPositionInChildResults(result, parentResults);
  }
  if (resultIndex < 0) {
    resultIndex = 0;
  }
  return buildPartialDocumentInformation(result, paginationBasedIndex(resultIndex), state);
};
const partialRecommendationInformation = (result, state) => {
  const resultIndex = state.recommendation?.recommendations.findIndex(({ uniqueId }) => result.uniqueId === uniqueId) || 0;
  return buildPartialDocumentInformation(result, resultIndex, state);
};
function buildPartialDocumentInformation(result, resultIndex, state) {
  const collection = result.raw.collection;
  const collectionName = typeof collection === "string" ? collection : "default";
  return {
    collectionName,
    documentAuthor: getDocumentAuthor(result),
    documentPosition: resultIndex + 1,
    documentTitle: result.title,
    documentUri: result.uri,
    documentUriHash: result.raw.urihash,
    documentUrl: result.clickUri,
    rankingModifier: result.rankingModifier || "",
    sourceName: getSourceName(result),
    queryPipeline: state.pipeline || getPipelineInitialState()
  };
}
const documentIdentifier = (result) => {
  if (!result.raw.permanentid) {
    console.warn("Missing field permanentid on result. This might cause many issues with your Coveo deployment. See https://docs.coveo.com/en/1913 and https://docs.coveo.com/en/1640 for more information.", result);
  }
  return {
    contentIDKey: "permanentid",
    contentIDValue: result.raw.permanentid || ""
  };
};
const rawPartialDefinition = {
  urihash: new StringValue(),
  sourcetype: new StringValue(),
  permanentid: new StringValue()
};
const resultPartialDefinition = {
  uniqueId: requiredNonEmptyString,
  raw: new RecordValue({ values: rawPartialDefinition }),
  title: requiredNonEmptyString,
  uri: requiredNonEmptyString,
  clickUri: requiredNonEmptyString,
  rankingModifier: new StringValue({ required: false, emptyAllowed: true })
};
function partialRawPayload(raw) {
  return Object.assign({}, ...Object.keys(rawPartialDefinition).map((key) => ({ [key]: raw[key] })));
}
function partialResultPayload(result) {
  return Object.assign({}, ...Object.keys(resultPartialDefinition).map((key) => ({
    [key]: result[key]
  })), { raw: partialRawPayload(result.raw) });
}
function getDocumentAuthor(result) {
  const author = result.raw.author;
  if (isNullOrUndefined(author)) {
    return "unknown";
  }
  return Array.isArray(author) ? author.join(";") : `${author}`;
}
function getSourceName(result) {
  const source = result.raw.source;
  if (isNullOrUndefined(source)) {
    return "unknown";
  }
  return source;
}
const validateResultPayload = (result) => new Schema(resultPartialDefinition).validate(partialResultPayload(result));
function findPositionInChildResults(targetResult, parentResults) {
  for (const [i, parent] of parentResults.entries()) {
    const children = getAllIncludedResultsFrom(parent);
    const childIndex = findPositionWithUniqueId(targetResult, children);
    if (childIndex !== -1) {
      return i;
    }
  }
  return -1;
}
function findPositionWithUniqueId(targetResult, results = []) {
  return results.findIndex(({ uniqueId }) => uniqueId === targetResult.uniqueId);
}
async function logNextEvent(emitEvent, type, payload) {
  await emitEvent(type, payload);
  return;
}
var SearchPageEvents;
(function(SearchPageEvents2) {
  SearchPageEvents2["interfaceLoad"] = "interfaceLoad";
  SearchPageEvents2["interfaceChange"] = "interfaceChange";
  SearchPageEvents2["didYouMeanAutomatic"] = "didYouMeanAutomatic";
  SearchPageEvents2["didYouMeanClick"] = "didYouMeanClick";
  SearchPageEvents2["resultsSort"] = "resultsSort";
  SearchPageEvents2["searchboxSubmit"] = "searchboxSubmit";
  SearchPageEvents2["searchboxAsYouType"] = "searchboxAsYouType";
  SearchPageEvents2["breadcrumbFacet"] = "breadcrumbFacet";
  SearchPageEvents2["breadcrumbResetAll"] = "breadcrumbResetAll";
  SearchPageEvents2["documentOpen"] = "documentOpen";
  SearchPageEvents2["omniboxAnalytics"] = "omniboxAnalytics";
  SearchPageEvents2["omniboxFromLink"] = "omniboxFromLink";
  SearchPageEvents2["searchFromLink"] = "searchFromLink";
  SearchPageEvents2["triggerQuery"] = "query";
  SearchPageEvents2["browseResults"] = "browseResults";
  SearchPageEvents2["staticFilterDeselect"] = "staticFilterDeselect";
  SearchPageEvents2["facetClearAll"] = "facetClearAll";
  SearchPageEvents2["facetSelect"] = "facetSelect";
  SearchPageEvents2["facetDeselect"] = "facetDeselect";
  SearchPageEvents2["facetExclude"] = "facetExclude";
  SearchPageEvents2["facetUnexclude"] = "facetUnexclude";
  SearchPageEvents2["facetUpdateSort"] = "facetUpdateSort";
  SearchPageEvents2["documentSuggestion"] = "documentSuggestion";
  SearchPageEvents2["facetShowMore"] = "showMoreFacetResults";
  SearchPageEvents2["facetShowLess"] = "showLessFacetResults";
  SearchPageEvents2["queryError"] = "query";
  SearchPageEvents2["recommendationInterfaceLoad"] = "recommendationInterfaceLoad";
  SearchPageEvents2["likeSmartSnippet"] = "likeSmartSnippet";
  SearchPageEvents2["dislikeSmartSnippet"] = "dislikeSmartSnippet";
  SearchPageEvents2["expandSmartSnippet"] = "expandSmartSnippet";
  SearchPageEvents2["collapseSmartSnippet"] = "collapseSmartSnippet";
  SearchPageEvents2["openSmartSnippetFeedbackModal"] = "openSmartSnippetFeedbackModal";
  SearchPageEvents2["closeSmartSnippetFeedbackModal"] = "closeSmartSnippetFeedbackModal";
  SearchPageEvents2["sendSmartSnippetReason"] = "sendSmartSnippetReason";
  SearchPageEvents2["expandSmartSnippetSuggestion"] = "expandSmartSnippetSuggestion";
  SearchPageEvents2["collapseSmartSnippetSuggestion"] = "collapseSmartSnippetSuggestion";
  SearchPageEvents2["openSmartSnippetSource"] = "openSmartSnippetSource";
  SearchPageEvents2["openSmartSnippetSuggestionSource"] = "openSmartSnippetSuggestionSource";
  SearchPageEvents2["showMoreFoldedResults"] = "showMoreFoldedResults";
  SearchPageEvents2["showLessFoldedResults"] = "showLessFoldedResults";
  SearchPageEvents2["copyToClipboard"] = "copyToClipboard";
  SearchPageEvents2["caseSendEmail"] = "Case.SendEmail";
  SearchPageEvents2["feedItemTextPost"] = "FeedItem.TextPost";
  SearchPageEvents2["caseAttach"] = "caseAttach";
  SearchPageEvents2["caseDetach"] = "caseDetach";
  SearchPageEvents2["retryGeneratedAnswer"] = "retryGeneratedAnswer";
  SearchPageEvents2["likeGeneratedAnswer"] = "likeGeneratedAnswer";
  SearchPageEvents2["dislikeGeneratedAnswer"] = "dislikeGeneratedAnswer";
  SearchPageEvents2["openGeneratedAnswerSource"] = "openGeneratedAnswerSource";
  SearchPageEvents2["generatedAnswerStreamEnd"] = "generatedAnswerStreamEnd";
  SearchPageEvents2["contextChanged"] = "contextChanged";
  SearchPageEvents2["generatedAnswerSourceHover"] = "generatedAnswerSourceHover";
  SearchPageEvents2["generatedAnswerFeedbackSubmit"] = "generatedAnswerFeedbackSubmit";
  SearchPageEvents2["generatedAnswerHideAnswers"] = "generatedAnswerHideAnswers";
  SearchPageEvents2["generatedAnswerShowAnswers"] = "generatedAnswerShowAnswers";
  SearchPageEvents2["generatedAnswerExpand"] = "generatedAnswerExpand";
  SearchPageEvents2["generatedAnswerCollapse"] = "generatedAnswerCollapse";
  SearchPageEvents2["generatedAnswerCopyToClipboard"] = "generatedAnswerCopyToClipboard";
  SearchPageEvents2["expandToFullUI"] = "expandToFullUI";
  SearchPageEvents2["createArticle"] = "createArticle";
  SearchPageEvents2["recentQueriesClick"] = "recentQueriesClick";
  SearchPageEvents2["clearRecentQueries"] = "clearRecentQueries";
})(SearchPageEvents || (SearchPageEvents = {}));
const logInterfaceLoad = () => makeAnalyticsAction("analytics/interface/load", (client) => client.makeInterfaceLoad());
const logInterfaceChange = () => makeAnalyticsAction("analytics/interface/change", (client, state) => client.makeInterfaceChange({
  interfaceChangeTo: state.configuration.analytics.originLevel2
}));
const logSearchFromLink = () => makeAnalyticsAction("analytics/interface/searchFromLink", (client) => client.makeSearchFromLink());
const logOmniboxFromLink = (metadata) => makeAnalyticsAction("analytics/interface/omniboxFromLink", (client) => client.makeOmniboxFromLink(metadata));
const interfaceLoad = () => ({
  actionCause: SearchPageEvents.interfaceLoad
});
const interfaceChange = () => ({
  actionCause: SearchPageEvents.interfaceChange
});
const searchFromLink = () => ({
  actionCause: SearchPageEvents.searchFromLink
});
const omniboxFromLink = () => ({
  actionCause: SearchPageEvents.omniboxFromLink
});
const originSchemaOnConfigUpdate = () => nonEmptyString;
const originSchemaOnUpdate = () => requiredNonEmptyString;
const updateBasicConfiguration$1 = createAction("configuration/updateBasicConfiguration", (payload) => validatePayload(payload, {
  accessToken: nonEmptyString,
  environment: new StringValue({
    required: false,
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  }),
  organizationId: nonEmptyString
}));
const updateSearchConfiguration = createAction("configuration/updateSearchConfiguration", (payload) => {
  return validatePayload(payload, {
    proxyBaseUrl: new StringValue({ required: false, url: true }),
    pipeline: new StringValue({ required: false, emptyAllowed: true }),
    searchHub: nonEmptyString,
    timezone: nonEmptyString,
    locale: nonEmptyString,
    authenticationProviders: new ArrayValue({
      required: false,
      each: requiredNonEmptyString
    })
  });
});
const analyticsConfigurationSchema = {
  enabled: new BooleanValue({ default: true }),
  originContext: originSchemaOnConfigUpdate(),
  originLevel2: originSchemaOnConfigUpdate(),
  originLevel3: originSchemaOnConfigUpdate(),
  proxyBaseUrl: new StringValue({ required: false, url: true }),
  runtimeEnvironment: new Value(),
  anonymous: new BooleanValue({ default: false }),
  deviceId: nonEmptyString,
  userDisplayName: nonEmptyString,
  documentLocation: nonEmptyString,
  trackingId: optionalTrackingId,
  analyticsMode: new StringValue({
    constrainTo: ["legacy", "next"],
    required: false,
    default: "next"
  }),
  source: new RecordValue({
    options: { required: false },
    values: COVEO_FRAMEWORK.reduce((acc, framework) => {
      acc[framework] = optionalNonEmptyVersionString;
      return acc;
    }, {})
  })
};
const updateAnalyticsConfiguration$1 = createAction("configuration/updateAnalyticsConfiguration", (payload) => {
  return validatePayload(payload, analyticsConfigurationSchema);
});
const disableAnalytics$1 = createAction("configuration/analytics/disable");
const enableAnalytics$1 = createAction("configuration/analytics/enable");
const setOriginLevel2 = createAction("configuration/analytics/originlevel2", (payload) => validatePayload(payload, { originLevel2: originSchemaOnUpdate() }));
const setOriginLevel3 = createAction("configuration/analytics/originlevel3", (payload) => validatePayload(payload, { originLevel3: originSchemaOnUpdate() }));
const searchParametersDefinition$1 = {
  q: new StringValue(),
  enableQuerySyntax: new BooleanValue(),
  aq: new StringValue(),
  cq: new StringValue(),
  firstResult: new NumberValue({ min: 0 }),
  numberOfResults: new NumberValue({ min: 0 }),
  sortCriteria: new StringValue(),
  f: new RecordValue(),
  fExcluded: new RecordValue(),
  cf: new RecordValue(),
  nf: new RecordValue(),
  mnf: new RecordValue(),
  df: new RecordValue(),
  debug: new BooleanValue(),
  sf: new RecordValue(),
  tab: new StringValue(),
  af: new RecordValue()
};
const restoreSearchParameters$1 = createAction("searchParameters/restore", (payload) => validatePayload(payload, searchParametersDefinition$1));
const restoreTab = createAction("searchParameters/restoreTab", (payload) => validatePayload(payload, requiredNonEmptyString));
const enableDebug = createAction("debug/enable");
const disableDebug = createAction("debug/disable");
const getDebugInitialState = () => false;
const debugReducer = createReducer(getDebugInitialState(), (builder) => {
  builder.addCase(enableDebug, () => true).addCase(disableDebug, () => false).addCase(restoreSearchParameters$1, (state, action) => {
    return action.payload.debug ?? state;
  });
});
const undo$1 = createAction("history/undo");
const redo$1 = createAction("history/redo");
const snapshot = createAction("history/snapshot");
const back = createAsyncThunk("history/back", async (_, { dispatch }) => {
  dispatch(undo$1());
  await dispatch(change());
});
const forward = createAsyncThunk("history/forward", async (_, { dispatch }) => {
  dispatch(redo$1());
  await dispatch(change());
});
const change = createAsyncThunk("history/change", async (_, { getState }) => {
  const s = getState();
  return s.history.present;
});
const setPipeline = createAction("pipeline/set", (payload) => validatePayload(payload, new StringValue({ required: true, emptyAllowed: true })));
const pipelineReducer = createReducer(getPipelineInitialState(), (builder) => {
  builder.addCase(setPipeline, (_, action) => action.payload).addCase(change.fulfilled, (state, action) => action.payload?.pipeline ?? state).addCase(updateSearchConfiguration, (state, action) => action.payload.pipeline || state);
});
const deselectAllBreadcrumbs = createAction("breadcrumb/deselectAll");
const deselectAllNonBreadcrumbs = createAction("breadcrumb/deselectAllNonBreadcrumbs");
const updateFacetAutoSelection = createAction("facet/updateFacetAutoSelection", (payload) => validatePayload(payload, {
  allow: new BooleanValue({ required: true })
}));
class InstantResultsAnalyticsProvider extends SearchAnalyticsProvider {
  getState;
  constructor(getState) {
    super(getState);
    this.getState = getState;
  }
  get activeInstantResultQuery() {
    const state = this.getState().instantResults;
    for (const id2 in state) {
      for (const query2 in state[id2].cache) {
        if (state[id2].cache[query2].isActive) {
          return state[id2].q;
        }
      }
    }
    return null;
  }
  get activeInstantResultCache() {
    const state = this.getState().instantResults;
    for (const id2 in state) {
      for (const query2 in state[id2].cache) {
        if (state[id2].cache[query2].isActive) {
          return state[id2].cache[query2];
        }
      }
    }
    return null;
  }
  get results() {
    return this.activeInstantResultCache?.results;
  }
  get queryText() {
    return this.activeInstantResultQuery ?? getQueryInitialState().q;
  }
  get responseTime() {
    return this.activeInstantResultCache?.duration ?? getSearchInitialState().duration;
  }
  get numberOfResults() {
    return this.activeInstantResultCache?.totalCountFiltered ?? getSearchInitialState().response.totalCountFiltered;
  }
  getSearchUID() {
    const searchUid = this.activeInstantResultCache?.searchUid;
    return searchUid || super.getSearchUID();
  }
}
const logInstantResultsSearch = () => makeAnalyticsAction("analytics/instantResult/searchboxAsYouType", (client) => client.makeSearchboxAsYouType(), (getState) => new InstantResultsAnalyticsProvider(getState));
const searchboxAsYouType = () => ({
  actionCause: SearchPageEvents.searchboxAsYouType
});
const instantResultsRegisterDefinition = {
  id: requiredNonEmptyString
};
const instantResultsQueryDefinition = {
  ...instantResultsRegisterDefinition,
  q: requiredEmptyAllowedString
};
const registerInstantResults = createAction("instantResults/register", (payload) => validatePayload(payload, instantResultsRegisterDefinition));
const updateInstantResultsQuery = createAction("instantResults/updateQuery", (payload) => validatePayload(payload, instantResultsQueryDefinition));
const clearExpiredResults = createAction("instantResults/clearExpired", (payload) => validatePayload(payload, instantResultsRegisterDefinition));
const numberValue = new NumberValue({ required: true, min: 0 });
const registerNumberOfResults = createAction("pagination/registerNumberOfResults", (payload) => validatePayload(payload, numberValue));
const updateNumberOfResults = createAction("pagination/updateNumberOfResults", (payload) => validatePayload(payload, numberValue));
const registerPage = createAction("pagination/registerPage", (payload) => validatePayload(payload, numberValue));
const updatePage = createAction("pagination/updatePage", (payload) => validatePayload(payload, numberValue));
const nextPage$1 = createAction("pagination/nextPage");
const previousPage$1 = createAction("pagination/previousPage");
const updateQuery$2 = createAction("query/updateQuery", (payload) => validatePayload(payload, {
  q: new StringValue(),
  enableQuerySyntax: new BooleanValue()
}));
const fromAnalyticsStateToAnalyticsParams$1 = (s, navigatorContext, eventDescription) => {
  return {
    analytics: {
      clientId: navigatorContext.clientId,
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: navigatorContext.referrer,
      documentLocation: navigatorContext.location,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause
      },
      ...eventDescription && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.deviceId && { deviceId: s.deviceId },
      ...s.trackingId && { trackingId: s.trackingId },
      ...{
        capture: navigatorContext.capture ?? navigatorContext.clientId !== ""
      },
      ...{ source: getAnalyticsSource(s) }
    }
  };
};
const buildSearchAndFoldingLoadCollectionRequest$1 = (state, navigatorContext, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: navigatorContext.referrer,
    timezone: state.configuration.search.timezone,
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && fromAnalyticsStateToAnalyticsParams$1(state.configuration.analytics, navigatorContext, eventDescription),
    ...state.excerptLength && !isNullOrUndefined(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};
const fromAnalyticsStateToAnalyticsParams = async (s, eventDescription) => {
  const isNextAnalytics = s.analyticsMode === "next";
  return {
    analytics: {
      clientId: await getVisitorID(s),
      clientTimestamp: (/* @__PURE__ */ new Date()).toISOString(),
      documentReferrer: s.originLevel3,
      originContext: s.originContext,
      ...eventDescription && {
        actionCause: eventDescription.actionCause,
        customData: eventDescription.customData
      },
      ...eventDescription && !isNextAnalytics && {
        customData: eventDescription.customData
      },
      ...s.userDisplayName && { userDisplayName: s.userDisplayName },
      ...s.documentLocation && { documentLocation: s.documentLocation },
      ...s.deviceId && { deviceId: s.deviceId },
      ...getPageID() && { pageId: getPageID() },
      ...isNextAnalytics && s.trackingId && { trackingId: s.trackingId },
      ...{ capture: isNextAnalytics },
      ...isNextAnalytics && { source: getAnalyticsSource(s) }
    }
  };
};
const buildSearchAndFoldingLoadCollectionRequest = async (state, eventDescription) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    locale: state.configuration.search.locale,
    debug: state.debug,
    tab: state.configuration.analytics.originLevel2,
    referrer: state.configuration.analytics.originLevel3,
    timezone: state.configuration.search.timezone,
    ...state.configuration.analytics.enabled && {
      actionsHistory: HistoryStore2.getInstance().getHistory()
    },
    ...state.advancedSearchQueries?.aq && {
      aq: state.advancedSearchQueries.aq
    },
    ...state.advancedSearchQueries?.cq && {
      cq: state.advancedSearchQueries.cq
    },
    ...state.advancedSearchQueries?.lq && {
      lq: state.advancedSearchQueries.lq
    },
    ...state.advancedSearchQueries?.dq && {
      dq: state.advancedSearchQueries.dq
    },
    ...state.context && {
      context: state.context.contextValues
    },
    ...state.fields && !state.fields.fetchAllFields && {
      fieldsToInclude: state.fields.fieldsToInclude
    },
    ...state.dictionaryFieldContext && {
      dictionaryFieldContext: state.dictionaryFieldContext.contextValues
    },
    ...state.pipeline && {
      pipeline: state.pipeline
    },
    ...state.query && {
      q: state.query.q,
      enableQuerySyntax: state.query.enableQuerySyntax
    },
    ...state.searchHub && {
      searchHub: state.searchHub
    },
    ...state.sortCriteria && {
      sortCriteria: state.sortCriteria
    },
    ...state.configuration.analytics.enabled && await fromAnalyticsStateToAnalyticsParams(state.configuration.analytics, eventDescription),
    ...state.excerptLength && !isNullOrUndefined(state.excerptLength.length) && {
      excerptLength: state.excerptLength.length
    },
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};
const getAdvancedSearchQueriesInitialState = () => ({
  cq: "",
  cqWasSet: false,
  aq: "",
  aqWasSet: false,
  lq: "",
  lqWasSet: false,
  dq: "",
  dqWasSet: false,
  defaultFilters: {
    cq: "",
    aq: "",
    lq: "",
    dq: ""
  }
});
const logFetchMoreResults = () => makeAnalyticsAction("search/logFetchMoreResults", (client) => client.makeFetchMoreResults());
const logQueryError = (error) => makeAnalyticsAction("search/queryError", (client, state) => client.makeQueryError({
  query: state.query?.q || getQueryInitialState().q,
  aq: state.advancedSearchQueries?.aq || getAdvancedSearchQueriesInitialState().aq,
  cq: state.advancedSearchQueries?.cq || getAdvancedSearchQueriesInitialState().cq,
  dq: state.advancedSearchQueries?.dq || getAdvancedSearchQueriesInitialState().dq,
  errorType: error.type,
  errorMessage: error.message
}));
dayjs.extend(customParseFormat);
const API_DATE_FORMAT = "YYYY/MM/DD@HH:mm:ss";
const API_DATE_MINIMUM = "1401-01-01";
function parseDate$1(date, format) {
  const parsedDate = dayjs(date, format);
  if (!parsedDate.isValid() && !format) {
    return dayjs(date, API_DATE_FORMAT);
  }
  return parsedDate;
}
function formatDateForSearchApi(date) {
  return date.format(API_DATE_FORMAT);
}
function isSearchApiDate(date) {
  return formatDateForSearchApi(parseDate$1(date)) === date;
}
function validateAbsoluteDate(date, dateFormat) {
  const dayJSDate = parseDate$1(date, dateFormat);
  if (!dayJSDate.isValid()) {
    const provideFormat = ". Please provide a date format string in the configuration options. See https://day.js.org/docs/en/parse/string-format for more information.";
    const withFormat = ` with the format "${dateFormat}"`;
    throw new Error(`Could not parse the provided date "${date}"${dateFormat ? withFormat : provideFormat}`);
  }
  assertDateAboveAPIMinimum(dayJSDate);
}
function assertDateAboveAPIMinimum(date) {
  if (date.isBefore(API_DATE_MINIMUM)) {
    throw new Error(`Date is before year 1401, which is unsupported by the API: ${date}`);
  }
}
dayjs.extend(quarterOfYear);
const validRelativeDatePeriods = ["past", "now", "next"];
const validRelativeDateUnits = [
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year"
];
const buildRelativeDateDefinition = (period) => {
  const isNow = period === "now";
  return {
    amount: new NumberValue({ required: !isNow, min: 1 }),
    unit: new StringValue({
      required: !isNow,
      constrainTo: validRelativeDateUnits
    }),
    period: new StringValue({
      required: true,
      constrainTo: validRelativeDatePeriods
    })
  };
};
function validateRelativeDate(date) {
  if (typeof date === "string" && !isRelativeDateFormat(date)) {
    throw new Error(`The value "${date}" is not respecting the relative date format "period-amount-unit"`);
  }
  const relativeDate = typeof date === "string" ? parseRelativeDate(date) : date;
  new Schema(buildRelativeDateDefinition(relativeDate.period)).validate(relativeDate);
  const dayJsDate = relativeToAbsoluteDate(relativeDate);
  const stringifiedDate = JSON.stringify(relativeDate);
  if (!dayJsDate.isValid()) {
    throw new Error(`Date is invalid: ${stringifiedDate}`);
  }
  assertDateAboveAPIMinimum(dayJsDate);
}
function serializeRelativeDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
    case "next":
      return `${period}-${amount}-${unit}`;
    case "now":
      return period;
  }
}
function relativeToAbsoluteDate(relativeDate) {
  const { period, amount, unit } = relativeDate;
  switch (period) {
    case "past":
      return dayjs().subtract(amount, unit);
    case "next":
      return dayjs().add(amount, unit);
    case "now":
      return dayjs();
  }
}
function formatRelativeDateForSearchApi(relativeDate) {
  return formatDateForSearchApi(relativeToAbsoluteDate(parseRelativeDate(relativeDate)));
}
function splitDate(date) {
  return date.toLocaleLowerCase().split("-");
}
function isRelativeDateFormat(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return true;
  }
  if (!validRelativeDatePeriods.includes(period)) {
    return false;
  }
  if (!validRelativeDateUnits.includes(unit)) {
    return false;
  }
  const intAmount = parseInt(amount);
  if (Number.isNaN(intAmount) || intAmount <= 0) {
    return false;
  }
  return true;
}
function isRelativeDate(date) {
  return !!date && typeof date === "object" && "period" in date;
}
function parseRelativeDate(date) {
  const [period, amount, unit] = splitDate(date);
  if (period === "now") {
    return {
      period: "now"
    };
  }
  return {
    period,
    amount: amount ? parseInt(amount) : void 0,
    unit: unit ? unit : void 0
  };
}
function deserializeRelativeDate(date) {
  validateRelativeDate(date);
  return parseRelativeDate(date);
}
function isDateFacetRequest(request) {
  return request.type === "dateRange";
}
function formatStartFacetValue(value) {
  return `start${value}`;
}
function formatEndFacetValue(value) {
  return `end${value}`;
}
const initialSearchMappings = () => ({
  dateFacetValueMap: {}
});
function mapDateRangeRequest(value, facetId2, mappings) {
  let start = value.start;
  let end = value.end;
  if (isRelativeDateFormat(start)) {
    start = formatRelativeDateForSearchApi(start);
    mappings.dateFacetValueMap[facetId2][formatStartFacetValue(start)] = value.start;
  }
  if (isRelativeDateFormat(end)) {
    end = formatRelativeDateForSearchApi(end);
    mappings.dateFacetValueMap[facetId2][formatEndFacetValue(end)] = value.end;
  }
  return { ...value, start, end };
}
function mapFacetRequest(facetRequest, mappings) {
  if (isDateFacetRequest(facetRequest)) {
    const { facetId: facetId2, currentValues } = facetRequest;
    mappings.dateFacetValueMap[facetId2] = {};
    return {
      ...facetRequest,
      currentValues: currentValues.map((value) => mapDateRangeRequest(value, facetId2, mappings))
    };
  }
  return facetRequest;
}
function mapSearchRequest(searchRequest) {
  const mappings = initialSearchMappings();
  const request = {
    ...searchRequest,
    facets: searchRequest.facets?.map((facetRequest) => mapFacetRequest(facetRequest, mappings))
  };
  return { request, mappings };
}
function mapDateRangeResponse(value, facetId2, mappings) {
  return {
    ...value,
    start: mappings.dateFacetValueMap[facetId2][formatStartFacetValue(value.start)] || value.start,
    end: mappings.dateFacetValueMap[facetId2][formatEndFacetValue(value.end)] || value.end
  };
}
function isDateFacetResponse$1(facetResponse, mappings) {
  return facetResponse.facetId in mappings.dateFacetValueMap;
}
function mapFacetResponse(facetResponse, mappings) {
  if (isDateFacetResponse$1(facetResponse, mappings)) {
    return {
      ...facetResponse,
      values: facetResponse.values.map((value) => mapDateRangeResponse(value, facetResponse.facetId, mappings))
    };
  }
  return facetResponse;
}
function mapSearchResponse(response, mappings) {
  if ("success" in response) {
    const success = {
      ...response.success,
      facets: response.success.facets?.map((facetResponse) => mapFacetResponse(facetResponse, mappings))
    };
    return { success };
  }
  return response;
}
const enableDidYouMean = createAction("didYouMean/enable");
const disableDidYouMean = createAction("didYouMean/disable");
const disableAutomaticQueryCorrection = createAction("didYouMean/automaticCorrections/disable");
const enableAutomaticQueryCorrection = createAction("didYouMean/automaticCorrections/enable");
const applyDidYouMeanCorrection = createAction("didYouMean/correction", (payload) => validatePayload(payload, requiredNonEmptyString));
const setCorrectionMode = createAction("didYouMean/automaticCorrections/mode", (payload) => validatePayload(payload, new StringValue({
  constrainTo: ["next", "legacy"],
  emptyAllowed: false,
  required: true
})));
const logDidYouMeanClick = () => makeAnalyticsAction("analytics/didyoumean/click", (client) => client.makeDidYouMeanClick());
const logDidYouMeanAutomatic = () => makeAnalyticsAction("analytics/didyoumean/automatic", (client) => client.makeDidYouMeanAutomatic());
const didYouMeanClick = () => ({
  actionCause: SearchPageEvents.didYouMeanClick
});
const didYouMeanAutomatic = () => ({
  actionCause: SearchPageEvents.didYouMeanAutomatic
});
function getContextInitialState$1() {
  return {
    contextValues: {}
  };
}
function getDictionaryFieldContextInitialState() {
  return {
    contextValues: {}
  };
}
function getFacetOptionsSliceInitialState() {
  return { enabled: true, tabs: {} };
}
function getFacetOptionsInitialState() {
  return {
    freezeFacetOrder: false,
    facets: {}
  };
}
function getFacetOrderInitialState() {
  return [];
}
function getPaginationInitialState() {
  return {
    firstResult: 0,
    defaultNumberOfResults: 10,
    numberOfResults: 10,
    totalCountFiltered: 0
  };
}
function getQuerySetInitialState() {
  return {};
}
function getStaticFilterSetInitialState() {
  return {};
}
function getTabSetInitialState() {
  return {};
}
function getHistoryInitialState() {
  return extractHistory({});
}
function extractHistory(state) {
  return {
    context: state.context || getContextInitialState$1(),
    dictionaryFieldContext: state.dictionaryFieldContext || getDictionaryFieldContextInitialState(),
    facetSet: state.facetSet || getFacetSetInitialState(),
    numericFacetSet: state.numericFacetSet || getNumericFacetSetInitialState(),
    dateFacetSet: state.dateFacetSet || getDateFacetSetInitialState(),
    categoryFacetSet: state.categoryFacetSet || getCategoryFacetSetInitialState(),
    automaticFacetSet: state.automaticFacetSet ?? getAutomaticFacetSetInitialState(),
    pagination: state.pagination || getPaginationInitialState(),
    query: state.query || getQueryInitialState(),
    tabSet: state.tabSet || getTabSetInitialState(),
    advancedSearchQueries: state.advancedSearchQueries || getAdvancedSearchQueriesInitialState(),
    staticFilterSet: state.staticFilterSet || getStaticFilterSetInitialState(),
    querySet: state.querySet || getQuerySetInitialState(),
    sortCriteria: state.sortCriteria || getSortCriteriaInitialState(),
    pipeline: state.pipeline || getPipelineInitialState(),
    searchHub: state.searchHub || getSearchHubInitialState(),
    facetOptions: state.facetOptions || getFacetOptionsInitialState(),
    facetOrder: state.facetOrder ?? getFacetOrderInitialState(),
    debug: state.debug ?? getDebugInitialState()
  };
}
const logUndoTriggerQueryPayloadDefinition = new RecordValue({
  values: {
    undoneQuery: requiredEmptyAllowedString
  },
  options: { required: true }
});
const logTriggerQuery = () => makeAnalyticsAction("analytics/trigger/query", (client, state) => {
  if (state.triggers?.queryModification.newQuery) {
    return client.makeTriggerQuery();
  }
  return null;
});
const logUndoTriggerQuery = (payload) => makeAnalyticsAction("analytics/trigger/query/undo", (client) => {
  validatePayload(payload, logUndoTriggerQueryPayloadDefinition);
  return client.makeUndoTriggerQuery(payload);
});
const logNotifyTrigger = () => makeAnalyticsAction("analytics/trigger/notify", (client, state) => {
  if (!state.triggers?.notifications.length) {
    return null;
  }
  return client.makeTriggerNotify({
    notifications: state.triggers.notifications
  });
});
const logTriggerRedirect = () => makeAnalyticsAction("analytics/trigger/redirect", (client, state) => {
  if (state.triggers?.redirectTo) {
    return client.makeTriggerRedirect({
      redirectedTo: state.triggers.redirectTo
    });
  }
  return null;
});
const logTriggerExecute = () => makeAnalyticsAction("analytics/trigger/execute", (client, state) => {
  if (!state.triggers?.executions.length) {
    return null;
  }
  return client.makeTriggerExecute({
    executions: state.triggers.executions
  });
});
const updateIgnoreQueryTrigger$1 = createAction("trigger/query/ignore", (q) => validatePayload(q, new StringValue({ emptyAllowed: true, required: true })));
const applyQueryTriggerModification$1 = createAction("trigger/query/modification", (payload) => validatePayload(payload, new RecordValue({
  values: { originalQuery: nonEmptyString, modification: nonEmptyString }
})));
function getFacetRequests(state) {
  return Object.values(state).map((slice) => slice.request);
}
function sortFacets(facets, sortOrder) {
  const payloadMap = {};
  facets.forEach((f2) => {
    payloadMap[f2.facetId] = f2;
  });
  const sortedFacets = [];
  sortOrder.forEach((facetId2) => {
    if (facetId2 in payloadMap) {
      sortedFacets.push(payloadMap[facetId2]);
      delete payloadMap[facetId2];
    }
  });
  const remainingFacets = Object.values(payloadMap);
  return [...sortedFacets, ...remainingFacets];
}
function getRangeFacetRequests$1(state) {
  return getFacetRequests(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    if (request.generateAutomaticRanges && !hasActiveValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
const sortCriteriaMap = {
  alphanumericDescending: { type: "alphanumeric", order: "descending" },
  alphanumericNaturalDescending: {
    type: "alphanumericNatural",
    order: "descending"
  }
};
function getSpecificFacetRequests$1(state) {
  return getFacetRequests(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getAllFacets$1(state) {
  return [
    ...getSpecificFacetRequests$1(state.facetSet ?? {}),
    ...getRangeFacetRequests$1(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests$1(state.dateFacetSet ?? {}),
    ...getFacetRequests(state.categoryFacetSet ?? {})
  ];
}
function getAllEnabledFacets$1(state) {
  return getAllFacets$1(state).filter(({ facetId: facetId2 }) => state.facetOptions?.facets[facetId2]?.enabled ?? true);
}
function getFacets$3(state) {
  return sortFacets(getAllEnabledFacets$1(state), state.facetOrder ?? []);
}
const minimumPage = 1;
const maximumNumberOfResultsFromIndex = 5e3;
const buildSearchRequest$1 = async (state, eventDescription) => {
  const cq = buildConstantQuery$1(state);
  const facets = getFacets$3(state);
  const automaticFacets = getAutomaticFacets$2(state);
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest(state, eventDescription);
  const getNumberOfResultsWithinIndexLimit2 = () => {
    if (!state.pagination) {
      return void 0;
    }
    const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
    if (isOverIndexLimit) {
      return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
    }
    return state.pagination.numberOfResults;
  };
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit2(),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getAutomaticFacets$2(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest$1).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest$1(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function buildConstantQuery$1(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find((tab) => tab.isActive);
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = getStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}
function getStaticFilterExpressions(state) {
  const filters = Object.values(state.staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter((value) => value.state === "selected" && !!value.expression.trim());
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
}
let AsyncSearchThunkProcessor$2 = class AsyncSearchThunkProcessor {
  config;
  onUpdateQueryForCorrection;
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery$2({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options2) {
    const startedAt = Date.now();
    const response = mapSearchResponse(await this.extra.apiClient.search(request, options2), mappings);
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse$1(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !isNullOrUndefined(queryCorrection) && !isNullOrUndefined(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(originalFetchedResponse);
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse$1(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery,
      analyticsAction: logDidYouMeanAutomatic()
    };
  }
  logOriginalAnalyticsQueryBeforeAutoCorrection(originalFetchedResponse) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    this.analyticsAction?.()(this.dispatch, () => this.getStateAfterResponse(originalFetchedResponse.queryExecuted, originalFetchedResponse.duration, state, successResponse), this.extra);
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger$1(""));
      return null;
    }
    if (this.analyticsAction) {
      await this.dispatch(this.analyticsAction);
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse$1(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery,
      analyticsAction: logTriggerQuery()
    };
  }
  getStateAfterResponse(query2, duration, previousState, response) {
    return {
      ...previousState,
      query: {
        q: query2,
        enableQuerySyntax: previousState.query?.enableQuerySyntax ?? getQueryInitialState().enableQuerySyntax
      },
      search: {
        ...getSearchInitialState(),
        duration,
        response,
        results: response.results
      }
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery(),
      analyticsAction: this.analyticsAction
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const fetched = await this.fetchFromAPI(await buildSearchRequest$1(this.getState()), { origin: "mainSearch" });
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(applyQueryTriggerModification$1({
      newQuery: modified,
      originalQuery: this.getCurrentQuery()
    }));
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(await buildSearchRequest$1(this.getState()), { origin: "mainSearch" });
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get analyticsAction() {
    return this.config.analyticsAction;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};
createAsyncThunk("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  return await legacyExecuteSearch(state, config, searchAction);
});
createAsyncThunk("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchPage(state, config, searchAction);
});
createAsyncThunk("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  return await legacyFetchMoreResults(config, state);
});
createAsyncThunk("search/fetchFacetValues", async (searchAction, config) => {
  const state = config.getState();
  return await legacyFetchFacetValues(config, searchAction, state);
});
createAsyncThunk("search/fetchInstantResults", async (payload, config) => {
  return legacyFetchInstantResults(payload, config);
});
const buildFetchMoreRequest$1 = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest$1(state, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
const buildInstantResultSearchRequest$1 = async (state, q, numberOfResults) => {
  const sharedWithFoldingRequest = await buildSearchAndFoldingLoadCollectionRequest(state);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
const buildFetchFacetValuesRequest$1 = async (state, eventDescription) => {
  const mappedRequest = await buildSearchRequest$1(state, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
const addEntryInActionsHistory$1 = (state) => {
  if (state.configuration.analytics.enabled) {
    HistoryStore2.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
async function legacyFetchInstantResults(payload, config) {
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const state = config.getState();
  const processor = new AsyncSearchThunkProcessor$2({ ...config, analyticsAction: logInstantResultsSearch() }, (modification) => {
    config.dispatch(updateInstantResultsQuery({ q: modification, id: payload.id }));
  });
  const request = await buildInstantResultSearchRequest$1(state, q, maxResultsPerQuery);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      analyticsAction: processed.analyticsAction,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
}
async function legacyFetchPage(state, config, searchAction) {
  addEntryInActionsHistory$1(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor$2({
    ...config,
    analyticsAction: searchAction
  });
  const request = await buildSearchRequest$1(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchMoreResults(config, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await logFetchMoreResults().prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor$2({
    ...config,
    analyticsAction: logFetchMoreResults()
  });
  const request = await buildFetchMoreRequest$1(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
async function legacyFetchFacetValues(config, searchAction, state) {
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const processor = new AsyncSearchThunkProcessor$2({ ...config, analyticsAction: searchAction });
  const request = await buildFetchFacetValuesRequest$1(state, eventDescription);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
}
async function legacyExecuteSearch(state, config, searchAction) {
  addEntryInActionsHistory$1(state);
  const { analyticsClientMiddleware, preprocessRequest, logger } = config.extra;
  const { description: eventDescription } = await searchAction.prepare({
    getState: () => config.getState(),
    analyticsClientMiddleware,
    preprocessRequest,
    logger
  });
  const request = await buildSearchRequest$1(state, eventDescription);
  const processor = new AsyncSearchThunkProcessor$2({ ...config, analyticsAction: searchAction });
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
}
const selectStaticFilterExpressions = createSelector((state) => state.staticFilterSet, (staticFilterSet) => {
  const filters = Object.values(staticFilterSet || {});
  return filters.map((filter) => {
    const selected = filter.values.filter((value) => value.state === "selected" && !!value.expression.trim());
    const expression = selected.map((value) => value.expression).join(" OR ");
    return selected.length > 1 ? `(${expression})` : expression;
  });
});
const buildSearchRequest = async (state, navigatorContext, eventDescription) => {
  const cq = buildConstantQuery(state);
  const facets = getFacets$2(state);
  const automaticFacets = getAutomaticFacets$1(state);
  const sharedWithFoldingRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest(state, eventDescription) : buildSearchAndFoldingLoadCollectionRequest$1(state, navigatorContext, eventDescription);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...cq && { cq },
    ...facets.length && { facets },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    ...state.facetOptions && {
      facetOptions: { freezeFacetOrder: state.facetOptions.freezeFacetOrder }
    },
    ...state.folding?.enabled && {
      filterField: state.folding.fields.collection,
      childField: state.folding.fields.parent,
      parentField: state.folding.fields.child,
      filterFieldRange: state.folding.filterFieldRange
    },
    ...state.automaticFacetSet && {
      generateAutomaticFacets: {
        desiredCount: state.automaticFacetSet.desiredCount,
        numberOfValues: state.automaticFacetSet.numberOfValues,
        currentFacets: automaticFacets
      }
    },
    ...state.generatedAnswer && {
      pipelineRuleParameters: {
        mlGenerativeQuestionAnswering: {
          responseFormat: state.generatedAnswer.responseFormat,
          citationsFieldToInclude: state.generatedAnswer.fieldsToIncludeInCitations
        }
      }
    }
  });
};
function getNumberOfResultsWithinIndexLimit(state) {
  if (!state.pagination) {
    return void 0;
  }
  const isOverIndexLimit = state.pagination.firstResult + state.pagination.numberOfResults > maximumNumberOfResultsFromIndex;
  if (isOverIndexLimit) {
    return maximumNumberOfResultsFromIndex - state.pagination.firstResult;
  }
  return state.pagination.numberOfResults;
}
function getFacets$2(state) {
  return sortFacets(getAllEnabledFacets(state), state.facetOrder ?? []);
}
function getAutomaticFacets$1(state) {
  const facets = state.automaticFacetSet?.set;
  return facets ? Object.values(facets).map((facet) => facet.response).map(responseToAutomaticFacetRequest).filter((facetRequest) => facetRequest.currentValues.length > 0) : void 0;
}
function responseToAutomaticFacetRequest(response) {
  const { field: field2, label, values } = response;
  const selectedValues = values.filter((value) => value.state === "selected");
  return {
    field: field2,
    label,
    currentValues: selectedValues
  };
}
function getAllEnabledFacets(state) {
  return getAllFacets(state).filter(({ facetId: facetId2 }) => state.facetOptions?.facets[facetId2]?.enabled ?? true);
}
function getAllFacets(state) {
  return [
    ...getSpecificFacetRequests(state.facetSet ?? {}),
    ...getRangeFacetRequests(state.numericFacetSet ?? {}),
    ...getRangeFacetRequests(state.dateFacetSet ?? {}),
    ...getFacetRequests(state.categoryFacetSet ?? {})
  ];
}
function getSpecificFacetRequests(state) {
  return getFacetRequests(state).map((request) => {
    const sortCriteria = sortCriteriaMap[request.sortCriteria];
    if (sortCriteria) {
      return {
        ...request,
        sortCriteria
      };
    }
    return request;
  });
}
function getRangeFacetRequests(state) {
  return getFacetRequests(state).map((request) => {
    const currentValues = request.currentValues;
    const hasActiveValues = currentValues.some(({ state: state2 }) => state2 !== "idle");
    const hasPreviousStateValues = currentValues.some((value) => value.previousState);
    if (request.generateAutomaticRanges && !hasActiveValues && !hasPreviousStateValues) {
      return { ...request, currentValues: [] };
    }
    return request;
  });
}
function buildConstantQuery(state) {
  const cq = state.advancedSearchQueries?.cq.trim() || "";
  const activeTab = Object.values(state.tabSet || {}).find((tab) => tab.isActive);
  const tabExpression = activeTab?.expression.trim() || "";
  const filterExpressions = selectStaticFilterExpressions(state);
  return [cq, tabExpression, ...filterExpressions].filter((expression) => !!expression).join(" AND ");
}
let AsyncSearchThunkProcessor$1 = class AsyncSearchThunkProcessor2 {
  config;
  onUpdateQueryForCorrection;
  constructor(config, onUpdateQueryForCorrection = (modification) => {
    this.dispatch(updateQuery$2({ q: modification }));
  }) {
    this.config = config;
    this.onUpdateQueryForCorrection = onUpdateQueryForCorrection;
  }
  async fetchFromAPI({ mappings, request }, options2) {
    const startedAt = Date.now();
    const response = mapSearchResponse(await this.extra.apiClient.search(request, options2), mappings);
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().query?.q || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse$1(fetched.response)) {
      this.dispatch(logQueryError(fetched.response.error));
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { enableDidYouMean: enableDidYouMean2, automaticallyCorrectQuery } = state.didYouMean;
    const { results, queryCorrections, queryCorrection } = successResponse;
    if (!enableDidYouMean2 || !automaticallyCorrectQuery) {
      return null;
    }
    const shouldExecuteClassicDidYouMeanAutoCorrection = results.length === 0 && queryCorrections && queryCorrections.length !== 0;
    const shouldExecuteModernDidYouMeanAutoCorrection = !isNullOrUndefined(queryCorrection) && !isNullOrUndefined(queryCorrection.correctedQuery);
    const shouldExitWithNoAutoCorrection = !shouldExecuteClassicDidYouMeanAutoCorrection && !shouldExecuteModernDidYouMeanAutoCorrection;
    if (shouldExitWithNoAutoCorrection) {
      return null;
    }
    const ret = shouldExecuteClassicDidYouMeanAutoCorrection ? await this.processLegacyDidYouMeanAutoCorrection(fetched) : this.processModernDidYouMeanAutoCorrection(fetched);
    this.dispatch(snapshot(extractHistory(this.getState())));
    return ret;
  }
  async processLegacyDidYouMeanAutoCorrection(originalFetchedResponse) {
    const originalQuery = this.getCurrentQuery();
    const originalSearchSuccessResponse = this.getSuccessResponse(originalFetchedResponse);
    if (!originalSearchSuccessResponse.queryCorrections) {
      return null;
    }
    const { correctedQuery } = originalSearchSuccessResponse.queryCorrections[0];
    const retried = await this.automaticallyRetryQueryWithCorrection(correctedQuery);
    if (isErrorResponse$1(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success,
        queryCorrections: originalSearchSuccessResponse.queryCorrections
      },
      automaticallyCorrected: true,
      originalQuery
    };
  }
  processModernDidYouMeanAutoCorrection(originalFetchedResponse) {
    const successResponse = this.getSuccessResponse(originalFetchedResponse);
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery);
    return {
      ...originalFetchedResponse,
      response: {
        ...successResponse
      },
      queryExecuted: correctedQuery,
      automaticallyCorrected: true,
      originalQuery
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger$1(""));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse$1(retried.response)) {
      this.dispatch(logQueryError(retried.response.error));
      return this.rejectWithValue(retried.response.error);
    }
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      automaticallyCorrected: false,
      originalQuery
    };
  }
  processSuccessResponse(fetched) {
    this.dispatch(snapshot(extractHistory(this.getState())));
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      automaticallyCorrected: false,
      originalQuery: this.getCurrentQuery()
    };
  }
  getSuccessResponse(fetched) {
    if (isSuccessResponse(fetched.response)) {
      return fetched.response.success;
    }
    return null;
  }
  async automaticallyRetryQueryWithCorrection(correction) {
    this.onUpdateQueryForCorrection(correction);
    const state = this.getState();
    const { actionCause } = didYouMeanAutomatic();
    const fetched = await this.fetchFromAPI(await buildSearchRequest(state, this.extra.navigatorContext, {
      actionCause
    }), { origin: "mainSearch" });
    this.dispatch(applyDidYouMeanCorrection(correction));
    return fetched;
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(applyQueryTriggerModification$1({
      newQuery: modified,
      originalQuery: this.getCurrentQuery()
    }));
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI(await buildSearchRequest(this.getState(), this.extra.navigatorContext), { origin: "mainSearch" });
    return fetched;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.query?.q !== void 0 ? state.query.q : "";
  }
  get extra() {
    return this.config.extra;
  }
  getState() {
    return this.config.getState();
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
};
const prepareForSearchWithQuery = createAsyncThunk("search/prepareForSearchWithQuery", (payload, thunk2) => {
  const { dispatch } = thunk2;
  validatePayload(payload, {
    q: new StringValue(),
    enableQuerySyntax: new BooleanValue(),
    clearFilters: new BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deselectAllBreadcrumbs());
    dispatch(deselectAllNonBreadcrumbs());
  }
  dispatch(updateFacetAutoSelection({ allow: true }));
  dispatch(updateQuery$2({ q: payload.q, enableQuerySyntax: payload.enableQuerySyntax }));
  dispatch(updatePage(1));
});
const updateSearchAction = createAction("search/updateSearchAction");
const executeSearch$1 = createAsyncThunk("search/executeSearch", async (searchAction, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyExecuteSearch(state, config, searchAction.legacy);
  }
  addEntryInActionsHistory(state);
  const analyticsAction = searchAction.next ? buildSearchReduxAction(searchAction.next) : void 0;
  const request = await buildSearchRequest(state, config.extra.navigatorContext, analyticsAction);
  const processor = new AsyncSearchThunkProcessor$1({ ...config, analyticsAction: analyticsAction ?? {} });
  const fetched = await processor.fetchFromAPI(request, {
    origin: "mainSearch"
  });
  return await processor.process(fetched);
});
const fetchPage = createAsyncThunk("search/fetchPage", async (searchAction, config) => {
  const state = config.getState();
  addEntryInActionsHistory(state);
  if (state.configuration.analytics.analyticsMode === "legacy" || !searchAction.next) {
    return legacyFetchPage(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor$1({
    ...config,
    analyticsAction: searchAction.next
  });
  const request = await buildSearchRequest(state, config.extra.navigatorContext, searchAction.next);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
const fetchMoreResults = createAsyncThunk("search/fetchMoreResults", async (_, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchMoreResults(config, state);
  }
  const analyticsAction = makeBasicNewSearchAnalyticsAction(SearchPageEvents.browseResults, config.getState);
  const processor = new AsyncSearchThunkProcessor$1({
    ...config,
    analyticsAction
  });
  const request = await buildFetchMoreRequest(state, config.extra.navigatorContext, analyticsAction);
  const fetched = await processor.fetchFromAPI(request, { origin: "mainSearch" });
  return await processor.process(fetched);
});
const fetchFacetValues = createAsyncThunk("search/fetchFacetValues", async (searchAction, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyExecuteSearch(state, config, searchAction.legacy);
  }
  const processor = new AsyncSearchThunkProcessor$1({ ...config, analyticsAction: {} });
  const request = await buildFetchFacetValuesRequest(state, config.extra.navigatorContext);
  const fetched = await processor.fetchFromAPI(request, {
    origin: "facetValues"
  });
  return await processor.process(fetched);
});
const fetchInstantResults = createAsyncThunk("search/fetchInstantResults", async (payload, config) => {
  const state = config.getState();
  if (state.configuration.analytics.analyticsMode === "legacy") {
    return legacyFetchInstantResults(payload, config);
  }
  validatePayload(payload, {
    id: requiredNonEmptyString,
    q: requiredNonEmptyString,
    maxResultsPerQuery: new NumberValue({
      required: true,
      min: 1
    }),
    cacheTimeout: new NumberValue()
  });
  const { q, maxResultsPerQuery } = payload;
  const analyticsAction = buildSearchReduxAction(searchboxAsYouType());
  const request = await buildInstantResultSearchRequest(state, config.extra.navigatorContext, q, maxResultsPerQuery, analyticsAction);
  const processor = new AsyncSearchThunkProcessor$1({ ...config, analyticsAction }, (modification) => {
    config.dispatch(updateInstantResultsQuery({ q: modification, id: payload.id }));
  });
  const fetched = await processor.fetchFromAPI(request, {
    origin: "instantResults",
    disableAbortWarning: true
  });
  const processed = await processor.process(fetched);
  if ("response" in processed) {
    return {
      results: processed.response.results,
      searchUid: processed.response.searchUid,
      totalCountFiltered: processed.response.totalCountFiltered,
      duration: processed.duration
    };
  }
  return processed;
});
const buildFetchMoreRequest = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, navigatorContext, eventDescription);
  mappedRequest.request = {
    ...mappedRequest.request,
    firstResult: (state.pagination?.firstResult ?? 0) + (state.search?.results.length ?? 0)
  };
  return mappedRequest;
};
const buildInstantResultSearchRequest = async (state, navigatorContext, q, numberOfResults, eventDescription) => {
  const sharedWithFoldingRequest = buildSearchAndFoldingLoadCollectionRequest$1(state, navigatorContext, eventDescription);
  return mapSearchRequest({
    ...sharedWithFoldingRequest,
    ...state.didYouMean && {
      enableDidYouMean: state.didYouMean.enableDidYouMean
    },
    numberOfResults,
    q
  });
};
const buildFetchFacetValuesRequest = async (state, navigatorContext, eventDescription) => {
  const mappedRequest = await buildSearchRequest(state, navigatorContext, eventDescription);
  mappedRequest.request.numberOfResults = 0;
  return mappedRequest;
};
const addEntryInActionsHistory = (state) => {
  if (state.configuration.analytics.enabled) {
    HistoryStore2.getInstance().addElement({
      name: "Query",
      ...state.query?.q && {
        value: state.query.q
      },
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
};
const buildSearchReduxAction = (action) => ({
  actionCause: action.actionCause,
  type: action.actionCause
});
const getResultProperty = (result, property) => {
  const anyResult = result;
  if (!isNullOrUndefined(anyResult[property])) {
    return anyResult[property];
  }
  if (!isNullOrUndefined(result.raw[property])) {
    return result.raw[property];
  }
  return null;
};
function firstSearchExecutedSelector(state) {
  return state.search.response.searchUid !== "";
}
function resultFromFieldSelector(state, contentIdKey, contentIdValue) {
  return state.search.results.find((result) => getResultProperty(result, contentIdKey) === contentIdValue);
}
const selectSearchActionCause = createSelector((state) => state.search, (state) => {
  return state?.searchAction?.actionCause || "";
});
const setError = createAction("app/setError");
function handleRejectedSearch(state, action) {
  const error = action.payload ?? null;
  if (error) {
    state.response = getSearchInitialState().response;
    state.results = [];
    state.questionAnswer = emptyQuestionAnswer();
  }
  state.error = error;
  state.isLoading = false;
}
function handleFulfilledSearch(state, action) {
  state.error = null;
  state.response = action.payload.response;
  state.queryExecuted = action.payload.queryExecuted;
  state.duration = action.payload.duration;
  state.isLoading = false;
}
function handleFulfilledNewSearch(state, action) {
  handleFulfilledSearch(state, action);
  state.results = action.payload.response.results.map((result) => ({
    ...result,
    searchUid: action.payload.response.searchUid
  }));
  state.searchResponseId = action.payload.response.searchUid;
  state.questionAnswer = action.payload.response.questionAnswer;
  state.extendedResults = action.payload.response.extendedResults;
}
function handlePendingSearch(state, action) {
  state.isLoading = true;
  state.searchAction = action.meta.arg.next;
  state.requestId = action.meta.requestId;
}
function handlePendingFetchMoreResults(state, action) {
  state.isLoading = true;
  state.searchAction = { actionCause: SearchPageEvents.browseResults };
  state.requestId = action.meta.requestId;
}
const searchReducer = createReducer(getSearchInitialState(), (builder) => {
  builder.addCase(executeSearch$1.rejected, (state, action) => handleRejectedSearch(state, action));
  builder.addCase(fetchMoreResults.rejected, (state, action) => handleRejectedSearch(state, action));
  builder.addCase(fetchPage.rejected, (state, action) => handleRejectedSearch(state, action));
  builder.addCase(executeSearch$1.fulfilled, (state, action) => {
    handleFulfilledNewSearch(state, action);
  });
  builder.addCase(fetchMoreResults.fulfilled, (state, action) => {
    handleFulfilledSearch(state, action);
    state.results = [
      ...state.results,
      ...action.payload.response.results.map((result) => ({
        ...result,
        searchUid: action.payload.response.searchUid
      }))
    ];
  });
  builder.addCase(fetchPage.fulfilled, (state, action) => {
    handleFulfilledSearch(state, action);
    state.results = [
      ...action.payload.response.results.map((result) => ({
        ...result,
        searchUid: action.payload.response.searchUid
      }))
    ];
  });
  builder.addCase(fetchFacetValues.fulfilled, (state, action) => {
    state.response.facets = action.payload.response.facets;
    state.response.searchUid = action.payload.response.searchUid;
  });
  builder.addCase(executeSearch$1.pending, handlePendingSearch);
  builder.addCase(fetchMoreResults.pending, handlePendingFetchMoreResults);
  builder.addCase(fetchPage.pending, handlePendingSearch);
  builder.addCase(updateSearchAction, (state, action) => {
    state.searchAction = action.payload;
  });
  builder.addCase(setError, (state, action) => {
    state.error = action.payload;
    state.isLoading = false;
  });
});
const setSearchHub = createAction("searchHub/set", (payload) => validatePayload(payload, new StringValue({ required: true, emptyAllowed: true })));
const searchHubReducer = createReducer(getSearchHubInitialState(), (builder) => {
  builder.addCase(setSearchHub, (_, action) => action.payload).addCase(change.fulfilled, (state, action) => action.payload?.searchHub ?? state).addCase(updateSearchConfiguration, (state, action) => action.payload.searchHub || state);
});
function getRequestStatusFlags(status) {
  return {
    status,
    isUninitialized: status === "uninitialized",
    isLoading: status === "pending",
    isSuccess: status === "fulfilled",
    isError: status === "rejected"
    /* rejected */
  };
}
var isPlainObject2 = isPlainObject$1;
function copyWithStructuralSharing(oldObj, newObj) {
  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
    return newObj;
  }
  const newKeys = Object.keys(newObj);
  const oldKeys = Object.keys(oldObj);
  let isSameObject = newKeys.length === oldKeys.length;
  const mergeObj = Array.isArray(newObj) ? [] : {};
  for (const key of newKeys) {
    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
  }
  return isSameObject ? oldObj : mergeObj;
}
function countObjectKeys(obj) {
  let count = 0;
  for (const _key in obj) {
    count++;
  }
  return count;
}
var flatten = (arr) => [].concat(...arr);
function isAbsoluteUrl(url) {
  return new RegExp(`(^|:)//`).test(url);
}
function isDocumentVisible() {
  if (typeof document === "undefined") {
    return true;
  }
  return document.visibilityState !== "hidden";
}
function isNotNullish(v) {
  return v != null;
}
function isOnline() {
  return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
}
var withoutTrailingSlash = (url) => url.replace(/\/$/, "");
var withoutLeadingSlash = (url) => url.replace(/^\//, "");
function joinUrls(base, url) {
  if (!base) {
    return url;
  }
  if (!url) {
    return base;
  }
  if (isAbsoluteUrl(url)) {
    return url;
  }
  const delimiter2 = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
  base = withoutTrailingSlash(base);
  url = withoutLeadingSlash(url);
  return `${base}${delimiter2}${url}`;
}
function getOrInsert(map, key, value) {
  if (map.has(key)) return map.get(key);
  return map.set(key, value).get(key);
}
var defaultFetchFn = (...args) => fetch(...args);
var defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;
var defaultIsJsonContentType = (headers) => (
  /*applicat*/
  /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "")
);
function stripUndefined(obj) {
  if (!isPlainObject$1(obj)) {
    return obj;
  }
  const copy = {
    ...obj
  };
  for (const [k, v] of Object.entries(copy)) {
    if (v === void 0) delete copy[k];
  }
  return copy;
}
function fetchBaseQuery({
  baseUrl,
  prepareHeaders = (x) => x,
  fetchFn = defaultFetchFn,
  paramsSerializer,
  isJsonContentType = defaultIsJsonContentType,
  jsonContentType = "application/json",
  jsonReplacer,
  timeout: defaultTimeout,
  responseHandler: globalResponseHandler,
  validateStatus: globalValidateStatus,
  ...baseFetchOptions
} = {}) {
  if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
    console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
  }
  return async (arg, api, extraOptions) => {
    const {
      getState,
      extra,
      endpoint,
      forced,
      type
    } = api;
    let meta2;
    let {
      url,
      headers = new Headers(baseFetchOptions.headers),
      params = void 0,
      responseHandler = globalResponseHandler ?? "json",
      validateStatus = globalValidateStatus ?? defaultValidateStatus,
      timeout = defaultTimeout,
      ...rest
    } = typeof arg == "string" ? {
      url: arg
    } : arg;
    let abortController, signal = api.signal;
    if (timeout) {
      abortController = new AbortController();
      api.signal.addEventListener("abort", abortController.abort);
      signal = abortController.signal;
    }
    let config = {
      ...baseFetchOptions,
      signal,
      ...rest
    };
    headers = new Headers(stripUndefined(headers));
    config.headers = await prepareHeaders(headers, {
      getState,
      arg,
      extra,
      endpoint,
      forced,
      type,
      extraOptions
    }) || headers;
    const isJsonifiable = (body) => typeof body === "object" && (isPlainObject$1(body) || Array.isArray(body) || typeof body.toJSON === "function");
    if (!config.headers.has("content-type") && isJsonifiable(config.body)) {
      config.headers.set("content-type", jsonContentType);
    }
    if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {
      config.body = JSON.stringify(config.body, jsonReplacer);
    }
    if (params) {
      const divider = ~url.indexOf("?") ? "&" : "?";
      const query2 = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
      url += divider + query2;
    }
    url = joinUrls(baseUrl, url);
    const request = new Request(url, config);
    const requestClone = new Request(url, config);
    meta2 = {
      request: requestClone
    };
    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {
      timedOut = true;
      abortController.abort();
    }, timeout);
    try {
      response = await fetchFn(request);
    } catch (e) {
      return {
        error: {
          status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
          error: String(e)
        },
        meta: meta2
      };
    } finally {
      if (timeoutId) clearTimeout(timeoutId);
      abortController?.signal.removeEventListener("abort", abortController.abort);
    }
    const responseClone = response.clone();
    meta2.response = responseClone;
    let resultData;
    let responseText = "";
    try {
      let handleResponseError;
      await Promise.all([
        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),
        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
        // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
        responseClone.text().then((r) => responseText = r, () => {
        })
      ]);
      if (handleResponseError) throw handleResponseError;
    } catch (e) {
      return {
        error: {
          status: "PARSING_ERROR",
          originalStatus: response.status,
          data: responseText,
          error: String(e)
        },
        meta: meta2
      };
    }
    return validateStatus(response, resultData) ? {
      data: resultData,
      meta: meta2
    } : {
      error: {
        status: response.status,
        data: resultData
      },
      meta: meta2
    };
  };
  async function handleResponse(response, responseHandler) {
    if (typeof responseHandler === "function") {
      return responseHandler(response);
    }
    if (responseHandler === "content-type") {
      responseHandler = isJsonContentType(response.headers) ? "json" : "text";
    }
    if (responseHandler === "json") {
      const text = await response.text();
      return text.length ? JSON.parse(text) : null;
    }
    return response.text();
  }
}
var HandledError = class {
  constructor(value, meta2 = void 0) {
    this.value = value;
    this.meta = meta2;
  }
};
async function defaultBackoff(attempt2 = 0, maxRetries = 5) {
  const attempts = Math.min(attempt2, maxRetries);
  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));
  await new Promise((resolve) => setTimeout((res2) => resolve(res2), timeout));
}
function fail(error, meta2) {
  throw Object.assign(new HandledError({
    error,
    meta: meta2
  }), {
    throwImmediately: true
  });
}
var EMPTY_OPTIONS = {};
var retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {
  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);
  const [maxRetries] = possibleMaxRetries.slice(-1);
  const defaultRetryCondition = (_, __, {
    attempt: attempt2
  }) => attempt2 <= maxRetries;
  const options2 = {
    maxRetries,
    backoff: defaultBackoff,
    retryCondition: defaultRetryCondition,
    ...defaultOptions,
    ...extraOptions
  };
  let retry2 = 0;
  while (true) {
    try {
      const result = await baseQuery(args, api, extraOptions);
      if (result.error) {
        throw new HandledError(result);
      }
      return result;
    } catch (e) {
      retry2++;
      if (e.throwImmediately) {
        if (e instanceof HandledError) {
          return e.value;
        }
        throw e;
      }
      if (e instanceof HandledError && !options2.retryCondition(e.value.error, args, {
        attempt: retry2,
        baseQueryApi: api,
        extraOptions
      })) {
        return e.value;
      }
      await options2.backoff(retry2, options2.maxRetries);
    }
  }
};
var retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {
  fail
});
var onFocus = /* @__PURE__ */ createAction("__rtkq/focused");
var onFocusLost = /* @__PURE__ */ createAction("__rtkq/unfocused");
var onOnline = /* @__PURE__ */ createAction("__rtkq/online");
var onOffline = /* @__PURE__ */ createAction("__rtkq/offline");
function isQueryDefinition(e) {
  return e.type === "query";
}
function isMutationDefinition(e) {
  return e.type === "mutation";
}
function isInfiniteQueryDefinition(e) {
  return e.type === "infinitequery";
}
function calculateProvidedBy(description, result, error, queryArg, meta2, assertTagTypes) {
  if (isFunction(description)) {
    return description(result, error, queryArg, meta2).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
  }
  if (Array.isArray(description)) {
    return description.map(expandTagDescription).map(assertTagTypes);
  }
  return [];
}
function isFunction(t) {
  return typeof t === "function";
}
function expandTagDescription(description) {
  return typeof description === "string" ? {
    type: description
  } : description;
}
function asSafePromise(promise, fallback) {
  return promise.catch(fallback);
}
var forceQueryFnSymbol = Symbol("forceQueryFn");
var isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === "function";
function buildInitiate({
  serializeQueryArgs,
  queryThunk,
  infiniteQueryThunk,
  mutationThunk,
  api,
  context
}) {
  const runningQueries = /* @__PURE__ */ new Map();
  const runningMutations = /* @__PURE__ */ new Map();
  const {
    unsubscribeQueryResult,
    removeMutationResult,
    updateSubscriptionOptions
  } = api.internalActions;
  return {
    buildInitiateQuery,
    buildInitiateInfiniteQuery,
    buildInitiateMutation,
    getRunningQueryThunk,
    getRunningMutationThunk,
    getRunningQueriesThunk,
    getRunningMutationsThunk
  };
  function getRunningQueryThunk(endpointName, queryArgs) {
    return (dispatch) => {
      const endpointDefinition = context.endpointDefinitions[endpointName];
      const queryCacheKey = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      return runningQueries.get(dispatch)?.[queryCacheKey];
    };
  }
  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
    return (dispatch) => {
      return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];
    };
  }
  function getRunningQueriesThunk() {
    return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
  }
  function getRunningMutationsThunk() {
    return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
  }
  function middlewareWarning(dispatch) {
    if (process.env.NODE_ENV !== "production") {
      if (middlewareWarning.triggered) return;
      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
      middlewareWarning.triggered = true;
      if (typeof returnedValue !== "object" || typeof returnedValue?.type === "string") {
        throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(34) : `Warning: Middleware for RTK-Query API at reducerPath "${api.reducerPath}" has not been added to the store.
You must add the middleware for RTK-Query to function correctly!`);
      }
    }
  }
  function buildInitiateAnyQuery(endpointName, endpointDefinition) {
    const queryAction = (arg, {
      subscribe = true,
      forceRefetch,
      subscriptionOptions,
      [forceQueryFnSymbol]: forceQueryFn,
      ...rest
    } = {}) => (dispatch, getState) => {
      const queryCacheKey = serializeQueryArgs({
        queryArgs: arg,
        endpointDefinition,
        endpointName
      });
      let thunk2;
      const commonThunkArgs = {
        ...rest,
        type: "query",
        subscribe,
        forceRefetch,
        subscriptionOptions,
        endpointName,
        originalArgs: arg,
        queryCacheKey,
        [forceQueryFnSymbol]: forceQueryFn
      };
      if (isQueryDefinition(endpointDefinition)) {
        thunk2 = queryThunk(commonThunkArgs);
      } else {
        const {
          direction,
          initialPageParam
        } = rest;
        thunk2 = infiniteQueryThunk({
          ...commonThunkArgs,
          // Supply these even if undefined. This helps with a field existence
          // check over in `buildSlice.ts`
          direction,
          initialPageParam
        });
      }
      const selector = api.endpoints[endpointName].select(arg);
      const thunkResult = dispatch(thunk2);
      const stateAfter = selector(getState());
      middlewareWarning(dispatch);
      const {
        requestId,
        abort
      } = thunkResult;
      const skippedSynchronously = stateAfter.requestId !== requestId;
      const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];
      const selectFromState = () => selector(getState());
      const statePromise = Object.assign(forceQueryFn ? (
        // a query has been forced (upsertQueryData)
        // -> we want to resolve it once data has been written with the data that will be written
        thunkResult.then(selectFromState)
      ) : skippedSynchronously && !runningQuery ? (
        // a query has been skipped due to a condition and we do not have any currently running query
        // -> we want to resolve it immediately with the current data
        Promise.resolve(stateAfter)
      ) : (
        // query just started or one is already in flight
        // -> wait for the running query, then resolve with data from after that
        Promise.all([runningQuery, thunkResult]).then(selectFromState)
      ), {
        arg,
        requestId,
        subscriptionOptions,
        queryCacheKey,
        abort,
        async unwrap() {
          const result = await statePromise;
          if (result.isError) {
            throw result.error;
          }
          return result.data;
        },
        refetch: () => dispatch(queryAction(arg, {
          subscribe: false,
          forceRefetch: true
        })),
        unsubscribe() {
          if (subscribe) dispatch(unsubscribeQueryResult({
            queryCacheKey,
            requestId
          }));
        },
        updateSubscriptionOptions(options2) {
          statePromise.subscriptionOptions = options2;
          dispatch(updateSubscriptionOptions({
            endpointName,
            requestId,
            queryCacheKey,
            options: options2
          }));
        }
      });
      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
        const running = getOrInsert(runningQueries, dispatch, {});
        running[queryCacheKey] = statePromise;
        statePromise.then(() => {
          delete running[queryCacheKey];
          if (!countObjectKeys(running)) {
            runningQueries.delete(dispatch);
          }
        });
      }
      return statePromise;
    };
    return queryAction;
  }
  function buildInitiateQuery(endpointName, endpointDefinition) {
    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
    return queryAction;
  }
  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
    return infiniteQueryAction;
  }
  function buildInitiateMutation(endpointName) {
    return (arg, {
      track = true,
      fixedCacheKey
    } = {}) => (dispatch, getState) => {
      const thunk2 = mutationThunk({
        type: "mutation",
        endpointName,
        originalArgs: arg,
        track,
        fixedCacheKey
      });
      const thunkResult = dispatch(thunk2);
      middlewareWarning(dispatch);
      const {
        requestId,
        abort,
        unwrap
      } = thunkResult;
      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({
        data
      })), (error) => ({
        error
      }));
      const reset = () => {
        dispatch(removeMutationResult({
          requestId,
          fixedCacheKey
        }));
      };
      const ret = Object.assign(returnValuePromise, {
        arg: thunkResult.arg,
        requestId,
        abort,
        unwrap,
        reset
      });
      const running = runningMutations.get(dispatch) || {};
      runningMutations.set(dispatch, running);
      running[requestId] = ret;
      ret.then(() => {
        delete running[requestId];
        if (!countObjectKeys(running)) {
          runningMutations.delete(dispatch);
        }
      });
      if (fixedCacheKey) {
        running[fixedCacheKey] = ret;
        ret.then(() => {
          if (running[fixedCacheKey] === ret) {
            delete running[fixedCacheKey];
            if (!countObjectKeys(running)) {
              runningMutations.delete(dispatch);
            }
          }
        });
      }
      return ret;
    };
  }
}
function defaultTransformResponse(baseQueryReturnValue) {
  return baseQueryReturnValue;
}
var addShouldAutoBatch = (arg = {}) => {
  return {
    ...arg,
    [SHOULD_AUTOBATCH]: true
  };
};
function buildThunks({
  reducerPath,
  baseQuery,
  context: {
    endpointDefinitions
  },
  serializeQueryArgs,
  api,
  assertTagType,
  selectors
}) {
  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {
    const endpointDefinition = endpointDefinitions[endpointName];
    const queryCacheKey = serializeQueryArgs({
      queryArgs: arg,
      endpointDefinition,
      endpointName
    });
    dispatch(api.internalActions.queryResultPatched({
      queryCacheKey,
      patches
    }));
    if (!updateProvided) {
      return;
    }
    const newValue = api.endpoints[endpointName].select(arg)(
      // Work around TS 4.1 mismatch
      getState()
    );
    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
    dispatch(api.internalActions.updateProvidedBy({
      queryCacheKey,
      providedTags
    }));
  };
  function addToStart(items, item, max = 0) {
    const newItems = [item, ...items];
    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
  }
  function addToEnd(items, item, max = 0) {
    const newItems = [...items, item];
    return max && newItems.length > max ? newItems.slice(1) : newItems;
  }
  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {
    const endpointDefinition = api.endpoints[endpointName];
    const currentState = endpointDefinition.select(arg)(
      // Work around TS 4.1 mismatch
      getState()
    );
    const ret = {
      patches: [],
      inversePatches: [],
      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
    };
    if (currentState.status === "uninitialized") {
      return ret;
    }
    let newValue;
    if ("data" in currentState) {
      if (isDraftable(currentState.data)) {
        const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
        ret.patches.push(...patches);
        ret.inversePatches.push(...inversePatches);
        newValue = value;
      } else {
        newValue = updateRecipe(currentState.data);
        ret.patches.push({
          op: "replace",
          path: [],
          value: newValue
        });
        ret.inversePatches.push({
          op: "replace",
          path: [],
          value: currentState.data
        });
      }
    }
    if (ret.patches.length === 0) {
      return ret;
    }
    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
    return ret;
  };
  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {
    const res2 = dispatch(api.endpoints[endpointName].initiate(arg, {
      subscribe: false,
      forceRefetch: true,
      [forceQueryFnSymbol]: () => ({
        data: value
      })
    }));
    return res2;
  };
  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {
    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
  };
  const executeEndpoint = async (arg, {
    signal,
    abort,
    rejectWithValue,
    fulfillWithValue,
    dispatch,
    getState,
    extra
  }) => {
    const endpointDefinition = endpointDefinitions[arg.endpointName];
    try {
      let transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
      const baseQueryApi = {
        signal,
        abort,
        dispatch,
        getState,
        extra,
        endpoint: arg.endpointName,
        type: arg.type,
        forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
        queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
      };
      const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
      let finalQueryReturnValue;
      const fetchPage2 = async (data, param, maxPages, previous) => {
        if (param == null && data.pages.length) {
          return Promise.resolve({
            data
          });
        }
        const finalQueryArg = {
          queryArg: arg.originalArgs,
          pageParam: param
        };
        const pageResponse = await executeRequest(finalQueryArg);
        const addTo = previous ? addToStart : addToEnd;
        return {
          data: {
            pages: addTo(data.pages, pageResponse.data, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          }
        };
      };
      async function executeRequest(finalQueryArg) {
        let result;
        const {
          extraOptions
        } = endpointDefinition;
        if (forceQueryFn) {
          result = forceQueryFn();
        } else if (endpointDefinition.query) {
          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
        } else {
          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));
        }
        if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
          const what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
          let err2;
          if (!result) {
            err2 = `${what} did not return anything.`;
          } else if (typeof result !== "object") {
            err2 = `${what} did not return an object.`;
          } else if (result.error && result.data) {
            err2 = `${what} returned an object containing both \`error\` and \`result\`.`;
          } else if (result.error === void 0 && result.data === void 0) {
            err2 = `${what} returned an object containing neither a valid \`error\` and \`result\`. At least one of them should not be \`undefined\``;
          } else {
            for (const key of Object.keys(result)) {
              if (key !== "error" && key !== "data" && key !== "meta") {
                err2 = `The object returned by ${what} has the unknown property ${key}.`;
                break;
              }
            }
          }
          if (err2) {
            console.error(`Error encountered handling the endpoint ${arg.endpointName}.
                  ${err2}
                  It needs to return an object with either the shape \`{ data: <value> }\` or \`{ error: <value> }\` that may contain an optional \`meta\` property.
                  Object returned was:`, result);
          }
        }
        if (result.error) throw new HandledError(result.error, result.meta);
        const transformedResponse = await transformResponse(result.data, result.meta, finalQueryArg);
        return {
          ...result,
          data: transformedResponse
        };
      }
      if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
        const {
          infiniteQueryOptions
        } = endpointDefinition;
        const {
          maxPages = Infinity
        } = infiniteQueryOptions;
        let result;
        const blankData = {
          pages: [],
          pageParams: []
        };
        const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;
        const isForcedQueryNeedingRefetch = (
          // arg.forceRefetch
          isForcedQuery(arg, getState()) && !arg.direction
        );
        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
        if ("direction" in arg && arg.direction && existingData.pages.length) {
          const previous = arg.direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const param = pageParamFn(infiniteQueryOptions, existingData);
          result = await fetchPage2(existingData, param, maxPages, previous);
        } else {
          const {
            initialPageParam = infiniteQueryOptions.initialPageParam
          } = arg;
          const cachedPageParams = cachedData?.pageParams ?? [];
          const firstPageParam = cachedPageParams[0] ?? initialPageParam;
          const totalPages = cachedPageParams.length;
          result = await fetchPage2(existingData, firstPageParam, maxPages);
          if (forceQueryFn) {
            result = {
              data: result.data.pages[0]
            };
          }
          for (let i = 1; i < totalPages; i++) {
            const param = getNextPageParam(infiniteQueryOptions, result.data);
            result = await fetchPage2(result.data, param, maxPages);
          }
        }
        finalQueryReturnValue = result;
      } else {
        finalQueryReturnValue = await executeRequest(arg.originalArgs);
      }
      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
        fulfilledTimeStamp: Date.now(),
        baseQueryMeta: finalQueryReturnValue.meta
      }));
    } catch (error) {
      let catchedError = error;
      if (catchedError instanceof HandledError) {
        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
        try {
          return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), addShouldAutoBatch({
            baseQueryMeta: catchedError.meta
          }));
        } catch (e) {
          catchedError = e;
        }
      }
      if (typeof process !== "undefined" && process.env.NODE_ENV !== "production") {
        console.error(`An unhandled error occurred processing a request for the endpoint "${arg.endpointName}".
In the case of an unhandled error, no tags will be "provided" or "invalidated".`, catchedError);
      } else {
        console.error(catchedError);
      }
      throw catchedError;
    }
  };
  function isForcedQuery(arg, state) {
    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);
    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;
    const fulfilledVal = requestState?.fulfilledTimeStamp;
    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);
    if (refetchVal) {
      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
    }
    return false;
  }
  const createQueryThunk = () => {
    const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {
      getPendingMeta({
        arg
      }) {
        const endpointDefinition = endpointDefinitions[arg.endpointName];
        return addShouldAutoBatch({
          startedTimeStamp: Date.now(),
          ...isInfiniteQueryDefinition(endpointDefinition) ? {
            direction: arg.direction
          } : {}
        });
      },
      condition(queryThunkArg, {
        getState
      }) {
        const state = getState();
        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);
        const fulfilledVal = requestState?.fulfilledTimeStamp;
        const currentArg = queryThunkArg.originalArgs;
        const previousArg = requestState?.originalArgs;
        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
        const direction = queryThunkArg.direction;
        if (isUpsertQuery(queryThunkArg)) {
          return true;
        }
        if (requestState?.status === "pending") {
          return false;
        }
        if (isForcedQuery(queryThunkArg, state)) {
          return true;
        }
        if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({
          currentArg,
          previousArg,
          endpointState: requestState,
          state
        })) {
          return true;
        }
        if (fulfilledVal && !direction) {
          return false;
        }
        return true;
      },
      dispatchConditionRejection: true
    });
    return generatedQueryThunk;
  };
  const queryThunk = createQueryThunk();
  const infiniteQueryThunk = createQueryThunk();
  const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {
    getPendingMeta() {
      return addShouldAutoBatch({
        startedTimeStamp: Date.now()
      });
    }
  });
  const hasTheForce = (options2) => "force" in options2;
  const hasMaxAge = (options2) => "ifOlderThan" in options2;
  const prefetch = (endpointName, arg, options2) => (dispatch, getState) => {
    const force = hasTheForce(options2) && options2.force;
    const maxAge = hasMaxAge(options2) && options2.ifOlderThan;
    const queryAction = (force2 = true) => {
      const options22 = {
        forceRefetch: force2,
        isPrefetch: true
      };
      return api.endpoints[endpointName].initiate(arg, options22);
    };
    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());
    if (force) {
      dispatch(queryAction());
    } else if (maxAge) {
      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;
      if (!lastFulfilledTs) {
        dispatch(queryAction());
        return;
      }
      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
      if (shouldRetrigger) {
        dispatch(queryAction());
      }
    } else {
      dispatch(queryAction(false));
    }
  };
  function matchesEndpoint(endpointName) {
    return (action) => action?.meta?.arg?.endpointName === endpointName;
  }
  function buildMatchThunkActions(thunk2, endpointName) {
    return {
      matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
      matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
      matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
    };
  }
  return {
    queryThunk,
    mutationThunk,
    infiniteQueryThunk,
    prefetch,
    updateQueryData,
    upsertQueryData,
    patchQueryData,
    buildMatchThunkActions
  };
}
function getNextPageParam(options2, {
  pages,
  pageParams
}) {
  const lastIndex = pages.length - 1;
  return options2.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);
}
function getPreviousPageParam(options2, {
  pages,
  pageParams
}) {
  return options2.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
}
function updateQuerySubstateIfExists(state, queryCacheKey, update) {
  const substate = state[queryCacheKey];
  if (substate) {
    update(substate);
  }
}
function getMutationCacheKey(id2) {
  return ("arg" in id2 ? id2.arg.fixedCacheKey : id2.fixedCacheKey) ?? id2.requestId;
}
function updateMutationSubstateIfExists(state, id2, update) {
  const substate = state[getMutationCacheKey(id2)];
  if (substate) {
    update(substate);
  }
}
var initialState = {};
function buildSlice({
  reducerPath,
  queryThunk,
  mutationThunk,
  serializeQueryArgs,
  context: {
    endpointDefinitions: definitions,
    apiUid,
    extractRehydrationInfo,
    hasRehydrationInfo
  },
  assertTagType,
  config
}) {
  const resetApiState = createAction(`${reducerPath}/resetApiState`);
  function writePendingCacheEntry(draft, arg, upserting, meta2) {
    draft[arg.queryCacheKey] ??= {
      status: "uninitialized",
      endpointName: arg.endpointName
    };
    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
      substate.status = "pending";
      substate.requestId = upserting && substate.requestId ? (
        // for `upsertQuery` **updates**, keep the current `requestId`
        substate.requestId
      ) : (
        // for normal queries or `upsertQuery` **inserts** always update the `requestId`
        meta2.requestId
      );
      if (arg.originalArgs !== void 0) {
        substate.originalArgs = arg.originalArgs;
      }
      substate.startedTimeStamp = meta2.startedTimeStamp;
      const endpointDefinition = definitions[meta2.arg.endpointName];
      if (isInfiniteQueryDefinition(endpointDefinition) && "direction" in arg) {
        substate.direction = arg.direction;
      }
    });
  }
  function writeFulfilledCacheEntry(draft, meta2, payload, upserting) {
    updateQuerySubstateIfExists(draft, meta2.arg.queryCacheKey, (substate) => {
      if (substate.requestId !== meta2.requestId && !upserting) return;
      const {
        merge
      } = definitions[meta2.arg.endpointName];
      substate.status = "fulfilled";
      if (merge) {
        if (substate.data !== void 0) {
          const {
            fulfilledTimeStamp,
            arg,
            baseQueryMeta,
            requestId
          } = meta2;
          let newData = produce(substate.data, (draftSubstateData) => {
            return merge(draftSubstateData, payload, {
              arg: arg.originalArgs,
              baseQueryMeta,
              fulfilledTimeStamp,
              requestId
            });
          });
          substate.data = newData;
        } else {
          substate.data = payload;
        }
      } else {
        substate.data = definitions[meta2.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;
      }
      delete substate.error;
      substate.fulfilledTimeStamp = meta2.fulfilledTimeStamp;
    });
  }
  const querySlice = createSlice({
    name: `${reducerPath}/queries`,
    initialState,
    reducers: {
      removeQueryResult: {
        reducer(draft, {
          payload: {
            queryCacheKey
          }
        }) {
          delete draft[queryCacheKey];
        },
        prepare: prepareAutoBatched()
      },
      cacheEntriesUpserted: {
        reducer(draft, action) {
          for (const entry of action.payload) {
            const {
              queryDescription: arg,
              value
            } = entry;
            writePendingCacheEntry(draft, arg, true, {
              arg,
              requestId: action.meta.requestId,
              startedTimeStamp: action.meta.timestamp
            });
            writeFulfilledCacheEntry(
              draft,
              {
                arg,
                requestId: action.meta.requestId,
                fulfilledTimeStamp: action.meta.timestamp,
                baseQueryMeta: {}
              },
              value,
              // We know we're upserting here
              true
            );
          }
        },
        prepare: (payload) => {
          const queryDescriptions = payload.map((entry) => {
            const {
              endpointName,
              arg,
              value
            } = entry;
            const endpointDefinition = definitions[endpointName];
            const queryDescription = {
              type: "query",
              endpointName,
              originalArgs: entry.arg,
              queryCacheKey: serializeQueryArgs({
                queryArgs: arg,
                endpointDefinition,
                endpointName
              })
            };
            return {
              queryDescription,
              value
            };
          });
          const result = {
            payload: queryDescriptions,
            meta: {
              [SHOULD_AUTOBATCH]: true,
              requestId: nanoid(),
              timestamp: Date.now()
            }
          };
          return result;
        }
      },
      queryResultPatched: {
        reducer(draft, {
          payload: {
            queryCacheKey,
            patches
          }
        }) {
          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {
            substate.data = applyPatches(substate.data, patches.concat());
          });
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(queryThunk.pending, (draft, {
        meta: meta2,
        meta: {
          arg
        }
      }) => {
        const upserting = isUpsertQuery(arg);
        writePendingCacheEntry(draft, arg, upserting, meta2);
      }).addCase(queryThunk.fulfilled, (draft, {
        meta: meta2,
        payload
      }) => {
        const upserting = isUpsertQuery(meta2.arg);
        writeFulfilledCacheEntry(draft, meta2, payload, upserting);
      }).addCase(queryThunk.rejected, (draft, {
        meta: {
          condition,
          arg,
          requestId
        },
        error,
        payload
      }) => {
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
          if (condition) ;
          else {
            if (substate.requestId !== requestId) return;
            substate.status = "rejected";
            substate.error = payload ?? error;
          }
        });
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          queries
        } = extractRehydrationInfo(action);
        for (const [key, entry] of Object.entries(queries)) {
          if (
            // do not rehydrate entries that were currently in flight.
            entry?.status === "fulfilled" || entry?.status === "rejected"
          ) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  const mutationSlice = createSlice({
    name: `${reducerPath}/mutations`,
    initialState,
    reducers: {
      removeMutationResult: {
        reducer(draft, {
          payload
        }) {
          const cacheKey = getMutationCacheKey(payload);
          if (cacheKey in draft) {
            delete draft[cacheKey];
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(mutationThunk.pending, (draft, {
        meta: meta2,
        meta: {
          requestId,
          arg,
          startedTimeStamp
        }
      }) => {
        if (!arg.track) return;
        draft[getMutationCacheKey(meta2)] = {
          requestId,
          status: "pending",
          endpointName: arg.endpointName,
          startedTimeStamp
        };
      }).addCase(mutationThunk.fulfilled, (draft, {
        payload,
        meta: meta2
      }) => {
        if (!meta2.arg.track) return;
        updateMutationSubstateIfExists(draft, meta2, (substate) => {
          if (substate.requestId !== meta2.requestId) return;
          substate.status = "fulfilled";
          substate.data = payload;
          substate.fulfilledTimeStamp = meta2.fulfilledTimeStamp;
        });
      }).addCase(mutationThunk.rejected, (draft, {
        payload,
        error,
        meta: meta2
      }) => {
        if (!meta2.arg.track) return;
        updateMutationSubstateIfExists(draft, meta2, (substate) => {
          if (substate.requestId !== meta2.requestId) return;
          substate.status = "rejected";
          substate.error = payload ?? error;
        });
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          mutations
        } = extractRehydrationInfo(action);
        for (const [key, entry] of Object.entries(mutations)) {
          if (
            // do not rehydrate entries that were currently in flight.
            (entry?.status === "fulfilled" || entry?.status === "rejected") && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
            key !== entry?.requestId
          ) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  const invalidationSlice = createSlice({
    name: `${reducerPath}/invalidation`,
    initialState,
    reducers: {
      updateProvidedBy: {
        reducer(draft, action) {
          const {
            queryCacheKey,
            providedTags
          } = action.payload;
          for (const tagTypeSubscriptions of Object.values(draft)) {
            for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
              const foundAt = idSubscriptions.indexOf(queryCacheKey);
              if (foundAt !== -1) {
                idSubscriptions.splice(foundAt, 1);
              }
            }
          }
          for (const {
            type,
            id: id2
          } of providedTags) {
            const subscribedQueries = (draft[type] ??= {})[id2 || "__internal_without_id"] ??= [];
            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
            if (!alreadySubscribed) {
              subscribedQueries.push(queryCacheKey);
            }
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, (draft, {
        payload: {
          queryCacheKey
        }
      }) => {
        for (const tagTypeSubscriptions of Object.values(draft)) {
          for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
            const foundAt = idSubscriptions.indexOf(queryCacheKey);
            if (foundAt !== -1) {
              idSubscriptions.splice(foundAt, 1);
            }
          }
        }
      }).addMatcher(hasRehydrationInfo, (draft, action) => {
        const {
          provided
        } = extractRehydrationInfo(action);
        for (const [type, incomingTags] of Object.entries(provided)) {
          for (const [id2, cacheKeys] of Object.entries(incomingTags)) {
            const subscribedQueries = (draft[type] ??= {})[id2 || "__internal_without_id"] ??= [];
            for (const queryCacheKey of cacheKeys) {
              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
            }
          }
        }
      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
        const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
        const {
          queryCacheKey
        } = action.meta.arg;
        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({
          queryCacheKey,
          providedTags
        }));
      });
    }
  });
  const subscriptionSlice = createSlice({
    name: `${reducerPath}/subscriptions`,
    initialState,
    reducers: {
      updateSubscriptionOptions(d, a) {
      },
      unsubscribeQueryResult(d, a) {
      },
      internal_getRTKQSubscriptions() {
      }
    }
  });
  const internalSubscriptionsSlice = createSlice({
    name: `${reducerPath}/internalSubscriptions`,
    initialState,
    reducers: {
      subscriptionsUpdated: {
        reducer(state, action) {
          return applyPatches(state, action.payload);
        },
        prepare: prepareAutoBatched()
      }
    }
  });
  const configSlice = createSlice({
    name: `${reducerPath}/config`,
    initialState: {
      online: isOnline(),
      focused: isDocumentVisible(),
      middlewareRegistered: false,
      ...config
    },
    reducers: {
      middlewareRegistered(state, {
        payload
      }) {
        state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
      }
    },
    extraReducers: (builder) => {
      builder.addCase(onOnline, (state) => {
        state.online = true;
      }).addCase(onOffline, (state) => {
        state.online = false;
      }).addCase(onFocus, (state) => {
        state.focused = true;
      }).addCase(onFocusLost, (state) => {
        state.focused = false;
      }).addMatcher(hasRehydrationInfo, (draft) => ({
        ...draft
      }));
    }
  });
  const combinedReducer = combineReducers({
    queries: querySlice.reducer,
    mutations: mutationSlice.reducer,
    provided: invalidationSlice.reducer,
    subscriptions: internalSubscriptionsSlice.reducer,
    config: configSlice.reducer
  });
  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);
  const actions2 = {
    ...configSlice.actions,
    ...querySlice.actions,
    ...subscriptionSlice.actions,
    ...internalSubscriptionsSlice.actions,
    ...mutationSlice.actions,
    ...invalidationSlice.actions,
    resetApiState
  };
  return {
    reducer,
    actions: actions2
  };
}
var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
var initialSubState = {
  status: "uninitialized"
  /* uninitialized */
};
var defaultQuerySubState = /* @__PURE__ */ produce(initialSubState, () => {
});
var defaultMutationSubState = /* @__PURE__ */ produce(initialSubState, () => {
});
function buildSelectors({
  serializeQueryArgs,
  reducerPath,
  createSelector: createSelector2
}) {
  const selectSkippedQuery = (state) => defaultQuerySubState;
  const selectSkippedMutation = (state) => defaultMutationSubState;
  return {
    buildQuerySelector,
    buildInfiniteQuerySelector,
    buildMutationSelector,
    selectInvalidatedBy,
    selectCachedArgsForQuery,
    selectApiState,
    selectQueries,
    selectMutations,
    selectQueryEntry,
    selectConfig
  };
  function withRequestFlags(substate) {
    return {
      ...substate,
      ...getRequestStatusFlags(substate.status)
    };
  }
  function selectApiState(rootState) {
    const state = rootState[reducerPath];
    if (process.env.NODE_ENV !== "production") {
      if (!state) {
        if (selectApiState.triggered) return state;
        selectApiState.triggered = true;
        console.error(`Error: No data found at \`state.${reducerPath}\`. Did you forget to add the reducer to the store?`);
      }
    }
    return state;
  }
  function selectQueries(rootState) {
    return selectApiState(rootState)?.queries;
  }
  function selectQueryEntry(rootState, cacheKey) {
    return selectQueries(rootState)?.[cacheKey];
  }
  function selectMutations(rootState) {
    return selectApiState(rootState)?.mutations;
  }
  function selectConfig(rootState) {
    return selectApiState(rootState)?.config;
  }
  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
    return (queryArgs) => {
      if (queryArgs === skipToken) {
        return createSelector2(selectSkippedQuery, combiner);
      }
      const serializedArgs = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;
      return createSelector2(selectQuerySubstate, combiner);
    };
  }
  function buildQuerySelector(endpointName, endpointDefinition) {
    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
  }
  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
    const {
      infiniteQueryOptions
    } = endpointDefinition;
    function withInfiniteQueryResultFlags(substate) {
      const stateWithRequestFlags = {
        ...substate,
        ...getRequestStatusFlags(substate.status)
      };
      const {
        isLoading,
        isError: isError2,
        direction
      } = stateWithRequestFlags;
      const isForward = direction === "forward";
      const isBackward = direction === "backward";
      return {
        ...stateWithRequestFlags,
        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data),
        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data),
        isFetchingNextPage: isLoading && isForward,
        isFetchingPreviousPage: isLoading && isBackward,
        isFetchNextPageError: isError2 && isForward,
        isFetchPreviousPageError: isError2 && isBackward
      };
    }
    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
  }
  function buildMutationSelector() {
    return (id2) => {
      let mutationId;
      if (typeof id2 === "object") {
        mutationId = getMutationCacheKey(id2) ?? skipToken;
      } else {
        mutationId = id2;
      }
      const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;
      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
      return createSelector2(finalSelectMutationSubstate, withRequestFlags);
    };
  }
  function selectInvalidatedBy(state, tags) {
    const apiState = state[reducerPath];
    const toInvalidate = /* @__PURE__ */ new Set();
    for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {
      const provided = apiState.provided[tag.type];
      if (!provided) {
        continue;
      }
      let invalidateSubscriptions = (tag.id !== void 0 ? (
        // id given: invalidate all queries that provide this type & id
        provided[tag.id]
      ) : (
        // no id: invalidate all queries that provide this type
        flatten(Object.values(provided))
      )) ?? [];
      for (const invalidate of invalidateSubscriptions) {
        toInvalidate.add(invalidate);
      }
    }
    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {
      const querySubState = apiState.queries[queryCacheKey];
      return querySubState ? [{
        queryCacheKey,
        endpointName: querySubState.endpointName,
        originalArgs: querySubState.originalArgs
      }] : [];
    }));
  }
  function selectCachedArgsForQuery(state, queryName) {
    return Object.values(selectQueries(state)).filter(
      (entry) => entry?.endpointName === queryName && entry.status !== "uninitialized"
      /* uninitialized */
    ).map((entry) => entry.originalArgs);
  }
  function getHasNextPage(options2, data) {
    if (!data) return false;
    return getNextPageParam(options2, data) != null;
  }
  function getHasPreviousPage(options2, data) {
    if (!data || !options2.getPreviousPageParam) return false;
    return getPreviousPageParam(options2, data) != null;
  }
}
var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var defaultSerializeQueryArgs = ({
  endpointName,
  queryArgs
}) => {
  let serialized = "";
  const cached = cache?.get(queryArgs);
  if (typeof cached === "string") {
    serialized = cached;
  } else {
    const stringified = JSON.stringify(queryArgs, (key, value) => {
      value = typeof value === "bigint" ? {
        $bigint: value.toString()
      } : value;
      value = isPlainObject$1(value) ? Object.keys(value).sort().reduce((acc, key2) => {
        acc[key2] = value[key2];
        return acc;
      }, {}) : value;
      return value;
    });
    if (isPlainObject$1(queryArgs)) {
      cache?.set(queryArgs, stringified);
    }
    serialized = stringified;
  }
  return `${endpointName}(${serialized})`;
};
function buildCreateApi(...modules) {
  return function baseCreateApi(options2) {
    const extractRehydrationInfo = weakMapMemoize((action) => options2.extractRehydrationInfo?.(action, {
      reducerPath: options2.reducerPath ?? "api"
    }));
    const optionsWithDefaults = {
      reducerPath: "api",
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: false,
      refetchOnFocus: false,
      refetchOnReconnect: false,
      invalidationBehavior: "delayed",
      ...options2,
      extractRehydrationInfo,
      serializeQueryArgs(queryArgsApi) {
        let finalSerializeQueryArgs = defaultSerializeQueryArgs;
        if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
          finalSerializeQueryArgs = (queryArgsApi2) => {
            const initialResult = endpointSQA(queryArgsApi2);
            if (typeof initialResult === "string") {
              return initialResult;
            } else {
              return defaultSerializeQueryArgs({
                ...queryArgsApi2,
                queryArgs: initialResult
              });
            }
          };
        } else if (options2.serializeQueryArgs) {
          finalSerializeQueryArgs = options2.serializeQueryArgs;
        }
        return finalSerializeQueryArgs(queryArgsApi);
      },
      tagTypes: [...options2.tagTypes || []]
    };
    const context = {
      endpointDefinitions: {},
      batch(fn) {
        fn();
      },
      apiUid: nanoid(),
      extractRehydrationInfo,
      hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)
    };
    const api = {
      injectEndpoints,
      enhanceEndpoints({
        addTagTypes,
        endpoints
      }) {
        if (addTagTypes) {
          for (const eT of addTagTypes) {
            if (!optionsWithDefaults.tagTypes.includes(eT)) {
              optionsWithDefaults.tagTypes.push(eT);
            }
          }
        }
        if (endpoints) {
          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
            if (typeof partialDefinition === "function") {
              partialDefinition(context.endpointDefinitions[endpointName]);
            } else {
              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
            }
          }
        }
        return api;
      }
    };
    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));
    function injectEndpoints(inject) {
      const evaluatedEndpoints = inject.endpoints({
        query: (x) => ({
          ...x,
          type: "query"
          /* query */
        }),
        mutation: (x) => ({
          ...x,
          type: "mutation"
          /* mutation */
        }),
        infiniteQuery: (x) => ({
          ...x,
          type: "infinitequery"
          /* infinitequery */
        })
      });
      for (const [endpointName, definition2] of Object.entries(evaluatedEndpoints)) {
        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {
          if (inject.overrideExisting === "throw") {
            throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(39) : `called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
          } else if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
            console.error(`called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
          }
          continue;
        }
        if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
          if (isInfiniteQueryDefinition(definition2)) {
            const {
              infiniteQueryOptions
            } = definition2;
            const {
              maxPages,
              getPreviousPageParam: getPreviousPageParam2
            } = infiniteQueryOptions;
            if (typeof maxPages === "number") {
              if (maxPages < 1) {
                throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(40) : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);
              }
              if (typeof getPreviousPageParam2 !== "function") {
                throw new Error(process.env.NODE_ENV === "production" ? formatProdErrorMessage(41) : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);
              }
            }
          }
        }
        context.endpointDefinitions[endpointName] = definition2;
        for (const m of initializedModules) {
          m.injectEndpoint(endpointName, definition2);
        }
      }
      return api;
    }
    return api.injectEndpoints({
      endpoints: options2.endpoints
    });
  };
}
function safeAssign(target, ...args) {
  return Object.assign(target, ...args);
}
var buildBatchedActionsHandler = ({
  api,
  queryThunk,
  internalState
}) => {
  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;
  let previousSubscriptions = null;
  let updateSyncTimer = null;
  const {
    updateSubscriptionOptions,
    unsubscribeQueryResult
  } = api.internalActions;
  const actuallyMutateSubscriptions = (mutableState, action) => {
    if (updateSubscriptionOptions.match(action)) {
      const {
        queryCacheKey,
        requestId,
        options: options2
      } = action.payload;
      if (mutableState?.[queryCacheKey]?.[requestId]) {
        mutableState[queryCacheKey][requestId] = options2;
      }
      return true;
    }
    if (unsubscribeQueryResult.match(action)) {
      const {
        queryCacheKey,
        requestId
      } = action.payload;
      if (mutableState[queryCacheKey]) {
        delete mutableState[queryCacheKey][requestId];
      }
      return true;
    }
    if (api.internalActions.removeQueryResult.match(action)) {
      delete mutableState[action.payload.queryCacheKey];
      return true;
    }
    if (queryThunk.pending.match(action)) {
      const {
        meta: {
          arg,
          requestId
        }
      } = action;
      const substate = mutableState[arg.queryCacheKey] ??= {};
      substate[`${requestId}_running`] = {};
      if (arg.subscribe) {
        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
      }
      return true;
    }
    let mutated = false;
    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {
      const state = mutableState[action.meta.arg.queryCacheKey] || {};
      const key = `${action.meta.requestId}_running`;
      mutated ||= !!state[key];
      delete state[key];
    }
    if (queryThunk.rejected.match(action)) {
      const {
        meta: {
          condition,
          arg,
          requestId
        }
      } = action;
      if (condition && arg.subscribe) {
        const substate = mutableState[arg.queryCacheKey] ??= {};
        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
        mutated = true;
      }
    }
    return mutated;
  };
  const getSubscriptions = () => internalState.currentSubscriptions;
  const getSubscriptionCount = (queryCacheKey) => {
    const subscriptions = getSubscriptions();
    const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};
    return countObjectKeys(subscriptionsForQueryArg);
  };
  const isRequestSubscribed = (queryCacheKey, requestId) => {
    const subscriptions = getSubscriptions();
    return !!subscriptions?.[queryCacheKey]?.[requestId];
  };
  const subscriptionSelectors = {
    getSubscriptions,
    getSubscriptionCount,
    isRequestSubscribed
  };
  return (action, mwApi) => {
    if (!previousSubscriptions) {
      previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
    }
    if (api.util.resetApiState.match(action)) {
      previousSubscriptions = internalState.currentSubscriptions = {};
      updateSyncTimer = null;
      return [true, false];
    }
    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {
      return [false, subscriptionSelectors];
    }
    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
    let actionShouldContinue = true;
    if (didMutate) {
      if (!updateSyncTimer) {
        updateSyncTimer = setTimeout(() => {
          const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
          const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);
          mwApi.next(api.internalActions.subscriptionsUpdated(patches));
          previousSubscriptions = newSubscriptions;
          updateSyncTimer = null;
        }, 500);
      }
      const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
    }
    return [actionShouldContinue, false];
  };
};
function isObjectEmpty(obj) {
  for (const k in obj) {
    return false;
  }
  return true;
}
var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
var buildCacheCollectionHandler = ({
  reducerPath,
  api,
  queryThunk,
  context,
  internalState,
  selectors: {
    selectQueryEntry,
    selectConfig
  }
}) => {
  const {
    removeQueryResult,
    unsubscribeQueryResult,
    cacheEntriesUpserted
  } = api.internalActions;
  const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
  function anySubscriptionsRemainingForKey(queryCacheKey) {
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    return !!subscriptions && !isObjectEmpty(subscriptions);
  }
  const currentRemovalTimeouts = {};
  const handler = (action, mwApi, internalState2) => {
    const state = mwApi.getState();
    const config = selectConfig(state);
    if (canTriggerUnsubscribe(action)) {
      let queryCacheKeys;
      if (cacheEntriesUpserted.match(action)) {
        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);
      } else {
        const {
          queryCacheKey
        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
        queryCacheKeys = [queryCacheKey];
      }
      handleUnsubscribeMany(queryCacheKeys, mwApi, config);
    }
    if (api.util.resetApiState.match(action)) {
      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {
        if (timeout) clearTimeout(timeout);
        delete currentRemovalTimeouts[key];
      }
    }
    if (context.hasRehydrationInfo(action)) {
      const {
        queries
      } = context.extractRehydrationInfo(action);
      handleUnsubscribeMany(Object.keys(queries), mwApi, config);
    }
  };
  function handleUnsubscribeMany(cacheKeys, api2, config) {
    const state = api2.getState();
    for (const queryCacheKey of cacheKeys) {
      const entry = selectQueryEntry(state, queryCacheKey);
      handleUnsubscribe(queryCacheKey, entry?.endpointName, api2, config);
    }
  }
  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
    const endpointDefinition = context.endpointDefinitions[endpointName];
    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;
    if (keepUnusedDataFor === Infinity) {
      return;
    }
    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
      const currentTimeout = currentRemovalTimeouts[queryCacheKey];
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
          api2.dispatch(removeQueryResult({
            queryCacheKey
          }));
        }
        delete currentRemovalTimeouts[queryCacheKey];
      }, finalKeepUnusedDataFor * 1e3);
    }
  }
  return handler;
};
var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
var buildCacheLifecycleHandler = ({
  api,
  reducerPath,
  context,
  queryThunk,
  mutationThunk,
  internalState,
  selectors: {
    selectQueryEntry,
    selectApiState
  }
}) => {
  const isQueryThunk = isAsyncThunkAction(queryThunk);
  const isMutationThunk = isAsyncThunkAction(mutationThunk);
  const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
  const lifecycleMap = {};
  function resolveLifecycleEntry(cacheKey, data, meta2) {
    const lifecycle = lifecycleMap[cacheKey];
    if (lifecycle?.valueResolved) {
      lifecycle.valueResolved({
        data,
        meta: meta2
      });
      delete lifecycle.valueResolved;
    }
  }
  function removeLifecycleEntry(cacheKey) {
    const lifecycle = lifecycleMap[cacheKey];
    if (lifecycle) {
      delete lifecycleMap[cacheKey];
      lifecycle.cacheEntryRemoved();
    }
  }
  const handler = (action, mwApi, stateBefore) => {
    const cacheKey = getCacheKey(action);
    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
      if (!oldEntry && newEntry) {
        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
      }
    }
    if (queryThunk.pending.match(action)) {
      checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
    } else if (api.internalActions.cacheEntriesUpserted.match(action)) {
      for (const {
        queryDescription,
        value
      } of action.payload) {
        const {
          endpointName,
          originalArgs,
          queryCacheKey
        } = queryDescription;
        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
        resolveLifecycleEntry(queryCacheKey, value, {});
      }
    } else if (mutationThunk.pending.match(action)) {
      const state = mwApi.getState()[reducerPath].mutations[cacheKey];
      if (state) {
        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
      }
    } else if (isFulfilledThunk(action)) {
      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
      removeLifecycleEntry(cacheKey);
    } else if (api.util.resetApiState.match(action)) {
      for (const cacheKey2 of Object.keys(lifecycleMap)) {
        removeLifecycleEntry(cacheKey2);
      }
    }
  };
  function getCacheKey(action) {
    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;
    if (isMutationThunk(action)) {
      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;
    }
    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;
    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);
    return "";
  }
  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
    const endpointDefinition = context.endpointDefinitions[endpointName];
    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;
    if (!onCacheEntryAdded) return;
    const lifecycle = {};
    const cacheEntryRemoved = new Promise((resolve) => {
      lifecycle.cacheEntryRemoved = resolve;
    });
    const cacheDataLoaded = Promise.race([new Promise((resolve) => {
      lifecycle.valueResolved = resolve;
    }), cacheEntryRemoved.then(() => {
      throw neverResolvedError;
    })]);
    cacheDataLoaded.catch(() => {
    });
    lifecycleMap[queryCacheKey] = lifecycle;
    const selector = api.endpoints[endpointName].select(endpointDefinition.type === "query" ? originalArgs : queryCacheKey);
    const extra = mwApi.dispatch((_, __, extra2) => extra2);
    const lifecycleApi = {
      ...mwApi,
      getCacheEntry: () => selector(mwApi.getState()),
      requestId,
      extra,
      updateCachedData: endpointDefinition.type === "query" ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
      cacheDataLoaded,
      cacheEntryRemoved
    };
    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
    Promise.resolve(runningHandler).catch((e) => {
      if (e === neverResolvedError) return;
      throw e;
    });
  }
  return handler;
};
var buildDevCheckHandler = ({
  api,
  context: {
    apiUid
  },
  reducerPath
}) => {
  return (action, mwApi) => {
    if (api.util.resetApiState.match(action)) {
      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
    }
    if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === "conflict") {
        console.warn(`There is a mismatch between slice and middleware for the reducerPath "${reducerPath}".
You can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === "api" ? `
If you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : ""}`);
      }
    }
  };
};
var buildInvalidationByTagsHandler = ({
  reducerPath,
  context,
  context: {
    endpointDefinitions
  },
  mutationThunk,
  queryThunk,
  api,
  assertTagType,
  refetchQuery,
  internalState
}) => {
  const {
    removeQueryResult
  } = api.internalActions;
  const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
  const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));
  let pendingTagInvalidations = [];
  const handler = (action, mwApi) => {
    if (isThunkActionWithTags(action)) {
      invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
    } else if (isQueryEnd(action)) {
      invalidateTags([], mwApi);
    } else if (api.util.invalidateTags.match(action)) {
      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
    }
  };
  function hasPendingRequests(state) {
    const {
      queries,
      mutations
    } = state;
    for (const cacheRecord of [queries, mutations]) {
      for (const key in cacheRecord) {
        if (cacheRecord[key]?.status === "pending") return true;
      }
    }
    return false;
  }
  function invalidateTags(newTags, mwApi) {
    const rootState = mwApi.getState();
    const state = rootState[reducerPath];
    pendingTagInvalidations.push(...newTags);
    if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
      return;
    }
    const tags = pendingTagInvalidations;
    pendingTagInvalidations = [];
    if (tags.length === 0) return;
    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
    context.batch(() => {
      const valuesArray = Array.from(toInvalidate.values());
      for (const {
        queryCacheKey
      } of valuesArray) {
        const querySubState = state.queries[queryCacheKey];
        const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};
        if (querySubState) {
          if (countObjectKeys(subscriptionSubState) === 0) {
            mwApi.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== "uninitialized") {
            mwApi.dispatch(refetchQuery(querySubState));
          }
        }
      }
    });
  }
  return handler;
};
var buildPollingHandler = ({
  reducerPath,
  queryThunk,
  api,
  refetchQuery,
  internalState
}) => {
  const currentPolls = {};
  const handler = (action, mwApi) => {
    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
      updatePollingInterval(action.payload, mwApi);
    }
    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
      updatePollingInterval(action.meta.arg, mwApi);
    }
    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
      startNextPoll(action.meta.arg, mwApi);
    }
    if (api.util.resetApiState.match(action)) {
      clearPolls();
    }
  };
  function startNextPoll({
    queryCacheKey
  }, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === "uninitialized") return;
    const {
      lowestPollingInterval,
      skipPollingIfUnfocused
    } = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) return;
    const currentPoll = currentPolls[queryCacheKey];
    if (currentPoll?.timeout) {
      clearTimeout(currentPoll.timeout);
      currentPoll.timeout = void 0;
    }
    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    currentPolls[queryCacheKey] = {
      nextPollTimestamp,
      pollingInterval: lowestPollingInterval,
      timeout: setTimeout(() => {
        if (state.config.focused || !skipPollingIfUnfocused) {
          api2.dispatch(refetchQuery(querySubState));
        }
        startNextPoll({
          queryCacheKey
        }, api2);
      }, lowestPollingInterval)
    };
  }
  function updatePollingInterval({
    queryCacheKey
  }, api2) {
    const state = api2.getState()[reducerPath];
    const querySubState = state.queries[queryCacheKey];
    const subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === "uninitialized") {
      return;
    }
    const {
      lowestPollingInterval
    } = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) {
      cleanupPollForKey(queryCacheKey);
      return;
    }
    const currentPoll = currentPolls[queryCacheKey];
    const nextPollTimestamp = Date.now() + lowestPollingInterval;
    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
      startNextPoll({
        queryCacheKey
      }, api2);
    }
  }
  function cleanupPollForKey(key) {
    const existingPoll = currentPolls[key];
    if (existingPoll?.timeout) {
      clearTimeout(existingPoll.timeout);
    }
    delete currentPolls[key];
  }
  function clearPolls() {
    for (const key of Object.keys(currentPolls)) {
      cleanupPollForKey(key);
    }
  }
  function findLowestPollingInterval(subscribers = {}) {
    let skipPollingIfUnfocused = false;
    let lowestPollingInterval = Number.POSITIVE_INFINITY;
    for (let key in subscribers) {
      if (!!subscribers[key].pollingInterval) {
        lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
        skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;
      }
    }
    return {
      lowestPollingInterval,
      skipPollingIfUnfocused
    };
  }
  return handler;
};
var buildQueryLifecycleHandler = ({
  api,
  context,
  queryThunk,
  mutationThunk
}) => {
  const isPendingThunk = isPending(queryThunk, mutationThunk);
  const isRejectedThunk = isRejected(queryThunk, mutationThunk);
  const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
  const lifecycleMap = {};
  const handler = (action, mwApi) => {
    if (isPendingThunk(action)) {
      const {
        requestId,
        arg: {
          endpointName,
          originalArgs
        }
      } = action.meta;
      const endpointDefinition = context.endpointDefinitions[endpointName];
      const onQueryStarted = endpointDefinition?.onQueryStarted;
      if (onQueryStarted) {
        const lifecycle = {};
        const queryFulfilled = new Promise((resolve, reject) => {
          lifecycle.resolve = resolve;
          lifecycle.reject = reject;
        });
        queryFulfilled.catch(() => {
        });
        lifecycleMap[requestId] = lifecycle;
        const selector = api.endpoints[endpointName].select(endpointDefinition.type === "query" ? originalArgs : requestId);
        const extra = mwApi.dispatch((_, __, extra2) => extra2);
        const lifecycleApi = {
          ...mwApi,
          getCacheEntry: () => selector(mwApi.getState()),
          requestId,
          extra,
          updateCachedData: endpointDefinition.type === "query" ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
          queryFulfilled
        };
        onQueryStarted(originalArgs, lifecycleApi);
      }
    } else if (isFullfilledThunk(action)) {
      const {
        requestId,
        baseQueryMeta
      } = action.meta;
      lifecycleMap[requestId]?.resolve({
        data: action.payload,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    } else if (isRejectedThunk(action)) {
      const {
        requestId,
        rejectedWithValue,
        baseQueryMeta
      } = action.meta;
      lifecycleMap[requestId]?.reject({
        error: action.payload ?? action.error,
        isUnhandledError: !rejectedWithValue,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    }
  };
  return handler;
};
var buildWindowEventHandler = ({
  reducerPath,
  context,
  api,
  refetchQuery,
  internalState
}) => {
  const {
    removeQueryResult
  } = api.internalActions;
  const handler = (action, mwApi) => {
    if (onFocus.match(action)) {
      refetchValidQueries(mwApi, "refetchOnFocus");
    }
    if (onOnline.match(action)) {
      refetchValidQueries(mwApi, "refetchOnReconnect");
    }
  };
  function refetchValidQueries(api2, type) {
    const state = api2.getState()[reducerPath];
    const queries = state.queries;
    const subscriptions = internalState.currentSubscriptions;
    context.batch(() => {
      for (const queryCacheKey of Object.keys(subscriptions)) {
        const querySubState = queries[queryCacheKey];
        const subscriptionSubState = subscriptions[queryCacheKey];
        if (!subscriptionSubState || !querySubState) continue;
        const shouldRefetch = Object.values(subscriptionSubState).some((sub) => sub[type] === true) || Object.values(subscriptionSubState).every((sub) => sub[type] === void 0) && state.config[type];
        if (shouldRefetch) {
          if (countObjectKeys(subscriptionSubState) === 0) {
            api2.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== "uninitialized") {
            api2.dispatch(refetchQuery(querySubState));
          }
        }
      }
    });
  }
  return handler;
};
function buildMiddleware(input) {
  const {
    reducerPath,
    queryThunk,
    api,
    context
  } = input;
  const {
    apiUid
  } = context;
  const actions2 = {
    invalidateTags: createAction(`${reducerPath}/invalidateTags`)
  };
  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);
  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
  const middleware = (mwApi) => {
    let initialized2 = false;
    const internalState = {
      currentSubscriptions: {}
    };
    const builderArgs = {
      ...input,
      internalState,
      refetchQuery,
      isThisApiSliceAction
    };
    const handlers = handlerBuilders.map((build) => build(builderArgs));
    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
    const windowEventsHandler = buildWindowEventHandler(builderArgs);
    return (next) => {
      return (action) => {
        if (!isAction(action)) {
          return next(action);
        }
        if (!initialized2) {
          initialized2 = true;
          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
        }
        const mwApiWithNext = {
          ...mwApi,
          next
        };
        const stateBefore = mwApi.getState();
        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
        let res2;
        if (actionShouldContinue) {
          res2 = next(action);
        } else {
          res2 = internalProbeResult;
        }
        if (!!mwApi.getState()[reducerPath]) {
          windowEventsHandler(action, mwApiWithNext, stateBefore);
          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
            for (const handler of handlers) {
              handler(action, mwApiWithNext, stateBefore);
            }
          }
        }
        return res2;
      };
    };
  };
  return {
    middleware,
    actions: actions2
  };
  function refetchQuery(querySubState) {
    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
      subscribe: false,
      forceRefetch: true
    });
  }
}
var coreModuleName = /* @__PURE__ */ Symbol();
var coreModule = ({
  createSelector: createSelector2 = createSelector
} = {}) => ({
  name: coreModuleName,
  init(api, {
    baseQuery,
    tagTypes,
    reducerPath,
    serializeQueryArgs,
    keepUnusedDataFor,
    refetchOnMountOrArgChange,
    refetchOnFocus,
    refetchOnReconnect,
    invalidationBehavior
  }, context) {
    enablePatches();
    const assertTagType = (tag) => {
      if (typeof process !== "undefined" && process.env.NODE_ENV === "development") {
        if (!tagTypes.includes(tag.type)) {
          console.error(`Tag type '${tag.type}' was used, but not specified in \`tagTypes\`!`);
        }
      }
      return tag;
    };
    Object.assign(api, {
      reducerPath,
      endpoints: {},
      internalActions: {
        onOnline,
        onOffline,
        onFocus,
        onFocusLost
      },
      util: {}
    });
    const selectors = buildSelectors({
      serializeQueryArgs,
      reducerPath,
      createSelector: createSelector2
    });
    const {
      selectInvalidatedBy,
      selectCachedArgsForQuery,
      buildQuerySelector,
      buildInfiniteQuerySelector,
      buildMutationSelector
    } = selectors;
    safeAssign(api.util, {
      selectInvalidatedBy,
      selectCachedArgsForQuery
    });
    const {
      queryThunk,
      infiniteQueryThunk,
      mutationThunk,
      patchQueryData,
      updateQueryData,
      upsertQueryData,
      prefetch,
      buildMatchThunkActions
    } = buildThunks({
      baseQuery,
      reducerPath,
      context,
      api,
      serializeQueryArgs,
      assertTagType,
      selectors
    });
    const {
      reducer,
      actions: sliceActions
    } = buildSlice({
      context,
      queryThunk,
      mutationThunk,
      serializeQueryArgs,
      reducerPath,
      assertTagType,
      config: {
        refetchOnFocus,
        refetchOnReconnect,
        refetchOnMountOrArgChange,
        keepUnusedDataFor,
        reducerPath,
        invalidationBehavior
      }
    });
    safeAssign(api.util, {
      patchQueryData,
      updateQueryData,
      upsertQueryData,
      prefetch,
      resetApiState: sliceActions.resetApiState,
      upsertQueryEntries: sliceActions.cacheEntriesUpserted
    });
    safeAssign(api.internalActions, sliceActions);
    const {
      middleware,
      actions: middlewareActions
    } = buildMiddleware({
      reducerPath,
      context,
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      api,
      assertTagType,
      selectors
    });
    safeAssign(api.util, middlewareActions);
    safeAssign(api, {
      reducer,
      middleware
    });
    const {
      buildInitiateQuery,
      buildInitiateInfiniteQuery,
      buildInitiateMutation,
      getRunningMutationThunk,
      getRunningMutationsThunk,
      getRunningQueriesThunk,
      getRunningQueryThunk
    } = buildInitiate({
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      api,
      serializeQueryArgs,
      context
    });
    safeAssign(api.util, {
      getRunningMutationThunk,
      getRunningMutationsThunk,
      getRunningQueryThunk,
      getRunningQueriesThunk
    });
    return {
      name: coreModuleName,
      injectEndpoint(endpointName, definition2) {
        const anyApi = api;
        const endpoint = anyApi.endpoints[endpointName] ??= {};
        if (isQueryDefinition(definition2)) {
          safeAssign(endpoint, {
            name: endpointName,
            select: buildQuerySelector(endpointName, definition2),
            initiate: buildInitiateQuery(endpointName, definition2)
          }, buildMatchThunkActions(queryThunk, endpointName));
        }
        if (isMutationDefinition(definition2)) {
          safeAssign(endpoint, {
            name: endpointName,
            select: buildMutationSelector(),
            initiate: buildInitiateMutation(endpointName)
          }, buildMatchThunkActions(mutationThunk, endpointName));
        }
        if (isInfiniteQueryDefinition(definition2)) {
          safeAssign(endpoint, {
            name: endpointName,
            select: buildInfiniteQuerySelector(endpointName, definition2),
            initiate: buildInitiateInfiniteQuery(endpointName, definition2)
          }, buildMatchThunkActions(queryThunk, endpointName));
        }
      }
    };
  }
});
var createApi = /* @__PURE__ */ buildCreateApi(coreModule());
const selectQuery = createSelector((state) => state.query, (query2) => query2);
const selectEnableQuerySyntax = createSelector((state) => state.query?.enableQuerySyntax, (enableQuerySyntax) => enableQuerySyntax);
createSelector((state) => selectQuery(state)?.q, (state) => state.search.requestId, (state) => state.generatedAnswer.cannotAnswer, (state) => state.configuration.analytics.analyticsMode, (state) => state.search.searchAction?.actionCause, (q, requestId, cannotAnswer, analyticsMode, actionCause) => ({
  q,
  requestId,
  cannotAnswer,
  analyticsMode,
  actionCause
}));
createSelector((state) => state.generatedAnswer?.answerApiQueryParams, (answerApiQueryParams) => answerApiQueryParams ?? skipToken);
const logGeneratedAnswerStreamEnd = (answerGenerated) => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/streamEnd",
  __legacy__getBuilder: (client, state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    const answerTextIsEmpty = answerGenerated ? !state.generatedAnswer?.answer || !state.generatedAnswer?.answer.length : void 0;
    if (!generativeQuestionAnsweringId) {
      return null;
    }
    return client.makeGeneratedAnswerStreamEnd({
      generativeQuestionAnsweringId,
      answerGenerated,
      answerTextIsEmpty
    });
  },
  analyticsType: "Rga.AnswerReceived",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      answerGenerated: answerGenerated ?? false
    };
  }
});
const logGeneratedAnswerResponseLinked = () => makeAnalyticsAction({
  prefix: "analytics/generatedAnswer/responseLinked",
  __legacy__getBuilder: () => {
    return null;
  },
  analyticsType: "Rga.ResponseLinked",
  analyticsPayloadBuilder: (state) => {
    const generativeQuestionAnsweringId = generativeQuestionAnsweringIdSelector(state);
    return {
      answerId: generativeQuestionAnsweringId ?? "",
      responseId: state.search?.searchResponseId || state.search?.response.searchUid || ""
    };
  }
});
const selectAdvancedSearchQueries = createSelector((state) => state.advancedSearchQueries, (advancedSearchQueries) => {
  if (!advancedSearchQueries) {
    return {};
  }
  const { aq, cq, dq, lq } = advancedSearchQueries;
  return {
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq }
  };
});
const selectContext = createSelector((state) => state.context, (context) => context);
const selectPipeline = createSelector((state) => state.pipeline, (pipeline) => pipeline);
const selectSearchHub = createSelector((state) => state.searchHub, (searchHub) => searchHub);
const selectActiveTab = createSelector((state) => state, (tabSetState) => {
  if (!tabSetState) {
    return "";
  }
  for (const tabId in tabSetState) {
    if (tabSetState[tabId].isActive) {
      return tabSetState[tabId].id;
    }
  }
  return "";
});
createSelector((state) => state, (tabSetState) => {
  const activeTabId = selectActiveTab(tabSetState);
  return activeTabId && tabSetState ? tabSetState[activeTabId].expression : "";
});
const selectLocale = createSelector((state) => state.configuration.search.locale, (locale) => locale);
const selectTimezone = createSelector((state) => state.configuration.search.timezone, (timezone2) => timezone2);
const selectDictionaryFieldContext = (state) => {
  if (!state.dictionaryFieldContext || !Object.keys(state.dictionaryFieldContext.contextValues).length) {
    return void 0;
  }
  return state.dictionaryFieldContext.contextValues;
};
const selectExcerptLength = createSelector((state) => state.excerptLength?.length, (excerptLength) => excerptLength);
const isFacetEnabledSelector = (state, id2) => {
  return state.facetOptions.facets[id2]?.enabled ?? true;
};
const selectFacetOptions = (state) => {
  const { freezeFacetOrder } = state.facetOptions ?? {};
  return freezeFacetOrder !== void 0 ? { freezeFacetOrder } : void 0;
};
const selectFoldingQueryParams = (state) => {
  if (!state.folding) {
    return void 0;
  }
  return {
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: state.folding.filterFieldRange
  };
};
const selectSortCriteria = createSelector((state) => state.sortCriteria, (sortCriteria) => sortCriteria);
const buildStreamingRequest = async (state) => ({
  accessToken: state.configuration.accessToken,
  organizationId: state.configuration.organizationId,
  url: getOrganizationEndpoint(state.configuration.organizationId, state.configuration.environment),
  streamId: state.search.extendedResults?.generativeQuestionAnsweringId
});
const constructAnswerAPIQueryParams = (state, navigatorContext) => {
  const q = selectQuery(state)?.q;
  const { aq, cq, dq, lq } = buildAdvancedSearchQueryParams(state);
  const context = selectContext(state);
  const analyticsParams = fromAnalyticsStateToAnalyticsParams$1(state.configuration.analytics, navigatorContext, { actionCause: selectSearchActionCause(state) });
  const searchHub = selectSearchHub(state);
  const pipeline = selectPipeline(state);
  const citationsFieldToInclude = selectFieldsToIncludeInCitation(state) ?? [];
  const facetParams = getGeneratedFacetParams(state);
  const tab = selectActiveTab(state.tabSet) || "default";
  const locale = selectLocale(state);
  const timezone2 = selectTimezone(state);
  const referrer = navigatorContext.referrer || "";
  const facetOptions = selectFacetOptions(state);
  const sortCriteria = selectSortCriteria(state);
  const actionsHistory = getActionsHistory(state);
  const excerptLength = selectExcerptLength(state);
  const foldingParams = selectFoldingQueryParams(state);
  const dictionaryFieldContext = selectDictionaryFieldContext(state);
  return {
    q,
    ...aq && { aq },
    ...cq && { cq },
    ...dq && { dq },
    ...lq && { lq },
    ...state.query && { enableQuerySyntax: selectEnableQuerySyntax(state) },
    ...context?.contextValues && {
      context: context.contextValues
    },
    pipelineRuleParameters: {
      mlGenerativeQuestionAnswering: {
        responseFormat: state.generatedAnswer.responseFormat,
        citationsFieldToInclude
      }
    },
    ...searchHub?.length && { searchHub },
    ...pipeline?.length && { pipeline },
    ...facetParams.length && { facets: facetParams },
    ...state.fields && { fieldsToInclude: state.fields.fieldsToInclude },
    ...state.didYouMean && {
      queryCorrection: {
        enabled: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "next",
        options: {
          automaticallyCorrect: state.didYouMean.automaticallyCorrectQuery ? "whenNoResults" : "never"
        }
      },
      enableDidYouMean: state.didYouMean.enableDidYouMean && state.didYouMean.queryCorrectionMode === "legacy"
    },
    ...state.pagination && {
      numberOfResults: getNumberOfResultsWithinIndexLimit(state),
      firstResult: state.pagination.firstResult
    },
    tab,
    locale,
    timezone: timezone2,
    ...state.debug !== void 0 && { debug: state.debug },
    referrer,
    ...actionsHistory,
    ...foldingParams ?? {},
    ...excerptLength && { excerptLength },
    ...dictionaryFieldContext && {
      dictionaryFieldContext
    },
    sortCriteria,
    ...facetOptions && { facetOptions },
    ...analyticsParams,
    ...state.insightCaseContext?.caseContext && {
      caseContext: state.insightCaseContext?.caseContext
    }
  };
};
const getGeneratedFacetParams = (state) => getFacets$3(state)?.map((facetRequest) => mapFacetRequest(facetRequest, initialSearchMappings())).sort((a, b) => a.facetId > b.facetId ? 1 : b.facetId > a.facetId ? -1 : 0);
const getActionsHistory = (state) => ({
  actionsHistory: state.configuration.analytics.enabled ? HistoryStore2.getInstance().getHistory() : []
});
const buildAdvancedSearchQueryParams = (state) => {
  const advancedSearchQueryParams = selectAdvancedSearchQueries(state);
  const mergedCq = buildConstantQuery(state);
  return {
    ...advancedSearchQueryParams,
    ...mergedCq && { cq: mergedCq }
  };
};
const generatedContentFormat = ["text/plain", "text/markdown"];
const stringValue = new StringValue({ required: true });
const optionalStringValue = new StringValue();
const booleanValue = new BooleanValue({ required: true });
const citationSchema = {
  id: stringValue,
  title: stringValue,
  uri: stringValue,
  permanentid: stringValue,
  clickUri: optionalStringValue
};
const answerContentFormatSchema = new StringValue({
  required: true,
  constrainTo: generatedContentFormat
});
const setIsVisible = createAction("generatedAnswer/setIsVisible", (payload) => validatePayload(payload, booleanValue));
const setAnswerId = createAction("generatedAnswer/setAnswerId", (payload) => validatePayload(payload, requiredNonEmptyString));
const setAnswerGenerationMode = createAction("generatedAnswer/setAnswerGenerationMode", (payload) => validatePayload(payload, new StringValue({
  constrainTo: ["automatic", "manual"],
  required: false,
  default: "automatic"
})));
const setIsEnabled = createAction("generatedAnswer/setIsEnabled", (payload) => validatePayload(payload, booleanValue));
const updateMessage = createAction("generatedAnswer/updateMessage", (payload) => validatePayload(payload, {
  textDelta: stringValue
}));
const updateCitations = createAction("generatedAnswer/updateCitations", (payload) => validatePayload(payload, {
  citations: new ArrayValue({
    required: true,
    each: new RecordValue({
      values: citationSchema
    })
  })
}));
const updateError = createAction("generatedAnswer/updateError", (payload) => validatePayload(payload, {
  message: optionalStringValue,
  code: new NumberValue({ min: 0 })
}));
const resetAnswer = createAction("generatedAnswer/resetAnswer");
const likeGeneratedAnswer = createAction("generatedAnswer/like");
const dislikeGeneratedAnswer = createAction("generatedAnswer/dislike");
const openGeneratedAnswerFeedbackModal = createAction("generatedAnswer/feedbackModal/open");
const expandGeneratedAnswer = createAction("generatedAnswer/expand");
const collapseGeneratedAnswer = createAction("generatedAnswer/collapse");
const setId = createAction("generatedAnswer/setId", (payload) => validatePayload(payload, {
  id: new StringValue({
    required: true
  })
}));
const closeGeneratedAnswerFeedbackModal = createAction("generatedAnswer/feedbackModal/close");
const sendGeneratedAnswerFeedback = createAction("generatedAnswer/sendFeedback");
const setIsLoading = createAction("generatedAnswer/setIsLoading", (payload) => validatePayload(payload, booleanValue));
const setIsStreaming = createAction("generatedAnswer/setIsStreaming", (payload) => validatePayload(payload, booleanValue));
const setAnswerContentFormat = createAction("generatedAnswer/setAnswerContentFormat", (payload) => validatePayload(payload, answerContentFormatSchema));
const updateResponseFormat = createAction("generatedAnswer/updateResponseFormat", (payload) => validatePayload(payload, {
  contentFormat: new ArrayValue({
    each: answerContentFormatSchema,
    default: ["text/plain"]
  })
}));
const updateAnswerConfigurationId = createAction("knowledge/updateAnswerConfigurationId", (payload) => validatePayload(payload, stringValue));
const registerFieldsToIncludeInCitations = createAction("generatedAnswer/registerFieldsToIncludeInCitations", (payload) => validatePayload(payload, nonEmptyStringArray));
const setIsAnswerGenerated = createAction("generatedAnswer/setIsAnswerGenerated", (payload) => validatePayload(payload, booleanValue));
const setCannotAnswer = createAction("generatedAnswer/setCannotAnswer", (payload) => validatePayload(payload, booleanValue));
const setAnswerApiQueryParams = createAction("generatedAnswer/setAnswerApiQueryParams", (payload) => validatePayload(payload, new RecordValue({})));
createAsyncThunk("generatedAnswer/streamAnswer", async (params, config) => {
  const state = config.getState();
  const { dispatch, extra, getState } = config;
  const { search } = getState();
  const { queryExecuted } = search;
  const { setAbortControllerRef } = params;
  const request = await buildStreamingRequest(state);
  const handleStreamPayload = (payloadType, payload) => {
    switch (payloadType) {
      case "genqa.headerMessageType": {
        const header = JSON.parse(payload);
        dispatch(setAnswerContentFormat(header.contentFormat));
        break;
      }
      case "genqa.messageType":
        dispatch(updateMessage(JSON.parse(payload)));
        break;
      case "genqa.citationsType":
        dispatch(updateCitations(JSON.parse(payload)));
        break;
      case "genqa.endOfStreamType": {
        const isAnswerGenerated = JSON.parse(payload).answerGenerated;
        const cannotAnswer = queryExecuted.length !== 0 && !isAnswerGenerated;
        dispatch(setCannotAnswer(cannotAnswer));
        dispatch(setIsStreaming(false));
        dispatch(setIsAnswerGenerated(isAnswerGenerated));
        dispatch(logGeneratedAnswerStreamEnd(isAnswerGenerated));
        dispatch(logGeneratedAnswerResponseLinked());
        break;
      }
      default:
        if (state.debug) {
          extra.logger.warn(`Unknown payloadType: "${payloadType}"`);
        }
    }
  };
  dispatch(setIsLoading(true));
  const currentStreamRequestMatchesOriginalStreamRequest = (request2) => {
    return request2.streamId === config.getState().search.extendedResults.generativeQuestionAnsweringId;
  };
  const abortController = extra.streamingClient?.streamGeneratedAnswer(request, {
    write: (data) => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(setIsLoading(false));
        if (data.payload && data.payloadType) {
          handleStreamPayload(data.payloadType, data.payload);
        }
      }
    },
    abort: (error) => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(updateError(error));
      }
    },
    close: () => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(setIsStreaming(false));
      }
    },
    resetAnswer: () => {
      if (currentStreamRequestMatchesOriginalStreamRequest(request)) {
        dispatch(resetAnswer());
      }
    }
  });
  if (abortController) {
    setAbortControllerRef(abortController);
  } else {
    dispatch(setIsLoading(false));
  }
});
createAsyncThunk("generatedAnswer/generateAnswer", async (_, { getState, dispatch, extra: { navigatorContext, logger } }) => {
  const state = getState();
  if (state.generatedAnswer.answerConfigurationId) {
    const answerApiQueryParams = constructAnswerAPIQueryParams(state, navigatorContext);
    dispatch(setAnswerApiQueryParams(answerApiQueryParams));
    await dispatch(fetchAnswer(answerApiQueryParams));
  } else {
    logger.warn("[WARNING] Missing answerConfigurationId in engine configuration. The generateAnswer action requires an answer configuration ID to use CRGA with the Answer API.");
  }
});
const dynamicBaseQuery = async (args, api, extraOptions) => {
  const state = api.getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const answerConfigurationId = state.generatedAnswer.answerConfigurationId;
  const updatedArgs = {
    ...args,
    headers: {
      ...args?.headers || {},
      Authorization: `Bearer ${accessToken}`
    }
  };
  try {
    const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
    const data = fetchBaseQuery({
      baseUrl: `${platformEndpoint}/rest/organizations/${organizationId}/answer/v1/configs/${answerConfigurationId}`
    })(updatedArgs, api, extraOptions);
    return { data };
  } catch (error) {
    return { error };
  }
};
const answerSlice = createApi({
  reducerPath: "answer",
  baseQuery: retry(dynamicBaseQuery, { maxRetries: 3 }),
  endpoints: () => ({})
});
const handleHeaderMessage = (draft, payload) => {
  const { contentFormat } = payload;
  draft.contentFormat = contentFormat;
  draft.isStreaming = true;
  draft.isLoading = false;
};
const handleMessage = (draft, payload) => {
  if (draft.answer === void 0) {
    draft.answer = payload.textDelta;
  } else if (typeof payload.textDelta === "string") {
    draft.answer = draft.answer.concat(payload.textDelta);
  }
};
const handleCitations = (draft, payload) => {
  draft.citations = payload.citations;
};
const handleEndOfStream = (draft, payload) => {
  draft.generated = payload.answerGenerated;
  draft.isStreaming = false;
};
const handleError$3 = (draft, message) => {
  const errorMessage = message.errorMessage || "Unknown error occurred";
  draft.error = {
    message: errorMessage,
    code: message.code
  };
  draft.isStreaming = false;
  draft.isLoading = false;
  console.error(`Generated answer error: ${errorMessage} (code: ${message.code})`);
};
const updateCacheWithEvent = (event, draft, dispatch) => {
  const message = JSON.parse(event.data);
  if (message.finishReason === "ERROR" && message.errorMessage) {
    handleError$3(draft, message);
  }
  const parsedPayload = message.payload.length ? JSON.parse(message.payload) : {};
  switch (message.payloadType) {
    case "genqa.headerMessageType":
      if (parsedPayload.contentFormat) {
        handleHeaderMessage(draft, parsedPayload);
        dispatch(setAnswerContentFormat(parsedPayload.contentFormat));
      }
      break;
    case "genqa.messageType":
      if (parsedPayload.textDelta) {
        handleMessage(draft, parsedPayload);
        dispatch(updateMessage({ textDelta: parsedPayload.textDelta }));
      }
      break;
    case "genqa.citationsType":
      if (parsedPayload.citations) {
        handleCitations(draft, parsedPayload);
        dispatch(updateCitations({ citations: parsedPayload.citations }));
      }
      break;
    case "genqa.endOfStreamType":
      handleEndOfStream(draft, parsedPayload);
      dispatch(logGeneratedAnswerStreamEnd(parsedPayload.answerGenerated ?? false));
      dispatch(logGeneratedAnswerResponseLinked());
      break;
  }
};
const buildAnswerEndpoint = (platformEndpoint, organizationId, answerConfigurationId, insightId) => {
  if (!platformEndpoint || !organizationId || !answerConfigurationId) {
    throw new Error("Missing required parameters for answer endpoint");
  }
  const basePath2 = `/rest/organizations/${organizationId}`;
  const prefix = insightId ? `insight/v1/configs/${insightId}/answer` : `answer/v1/configs`;
  return `${platformEndpoint}${basePath2}/${prefix}/${answerConfigurationId}/generate`;
};
const answerApi = answerSlice.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    getAnswer: builder.query({
      queryFn: () => ({
        data: {
          contentFormat: void 0,
          answer: void 0,
          citations: void 0,
          error: void 0,
          generated: false,
          isStreaming: true,
          isLoading: true
        }
      }),
      serializeQueryArgs: ({ endpointName, queryArgs }) => {
        const { analytics: _analytics, ...queryArgsWithoutAnalytics } = queryArgs;
        return `${endpointName}(${JSON.stringify(queryArgsWithoutAnalytics)})`;
      },
      async onCacheEntryAdded(args, { getState, cacheDataLoaded, updateCachedData, dispatch }) {
        await cacheDataLoaded;
        const { configuration: configuration2, generatedAnswer, insightConfiguration } = getState();
        const { organizationId, environment, accessToken } = configuration2;
        const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
        const answerEndpoint = buildAnswerEndpoint(platformEndpoint, organizationId, generatedAnswer.answerConfigurationId, insightConfiguration?.insightId);
        await fetchEventSource(answerEndpoint, {
          method: "POST",
          body: JSON.stringify(args),
          headers: {
            Authorization: `Bearer ${accessToken}`,
            Accept: "application/json",
            "Content-Type": "application/json",
            "Accept-Encoding": "*"
          },
          fetch,
          onopen: async (res2) => {
            const answerId = res2.headers.get("x-answer-id");
            if (answerId) {
              updateCachedData((draft) => {
                draft.answerId = answerId;
                dispatch(setAnswerId(answerId));
              });
            }
          },
          onmessage: (event) => {
            updateCachedData((draft) => {
              updateCacheWithEvent(event, draft, dispatch);
            });
          },
          onerror: (error) => {
            throw error;
          },
          onclose: () => {
            updateCachedData((draft) => {
              dispatch(setCannotAnswer(!draft.generated));
            });
          }
        });
      }
    })
  })
});
const fetchAnswer = (fetchAnswerParams) => {
  return answerApi.endpoints.getAnswer.initiate(fetchAnswerParams);
};
const versionReducer = createReducer(VERSION, (builder) => builder);
function isAnalyticsAction(action) {
  const analytics = action.payload?.analyticsAction;
  return isActionWithType(action) && !isNullOrUndefined(analytics);
}
function isActionWithType(action) {
  return "type" in action;
}
const analyticsMiddleware = (api) => (next) => (action) => {
  let analytics;
  if (isAnalyticsAction(action)) {
    analytics = action.payload.analyticsAction;
    delete action.payload.analyticsAction;
  }
  const ret = next(action);
  if (isActionWithType(action)) {
    if (action.type === "search/executeSearch/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with search:", action);
    }
    if (action.type === "recommendation/get/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with recommendation:", action);
    }
    if (action.type === "productRecommendations/get/fullfilled" && analytics === void 0) {
      console.error("No analytics action associated with product recommendation:", action);
    }
  }
  if (analytics !== void 0) {
    api.dispatch(analytics);
  }
  return ret;
};
const registerTab = createAction("tab/register", (payload) => {
  const schema = new RecordValue({
    values: {
      id: requiredNonEmptyString,
      expression: requiredEmptyAllowedString
    }
  });
  return validatePayload(payload, schema);
});
const updateActiveTab = createAction("tab/updateActiveTab", (id2) => {
  return validatePayload(id2, requiredNonEmptyString);
});
dayjs.extend(utc);
dayjs.extend(timezone);
const getConfigurationInitialState$1 = () => ({
  organizationId: "",
  accessToken: "",
  search: {
    locale: "en-US",
    timezone: dayjs.tz.guess(),
    authenticationProviders: []
  },
  analytics: {
    enabled: true,
    originContext: "Search",
    originLevel2: "default",
    originLevel3: "default",
    anonymous: false,
    deviceId: "",
    userDisplayName: "",
    documentLocation: "",
    analyticsMode: "next",
    source: {}
  },
  knowledge: {
    answerConfigurationId: ""
  },
  environment: "prod"
});
const pendragonCookieValueMatcher = /(^|; )Coveo-Pendragon=([^;]*)/;
function getMagicCookie() {
  if (typeof window === "undefined") {
    return false;
  } else {
    return pendragonCookieValueMatcher.exec(document.cookie)?.pop() || null;
  }
}
const configurationReducer$1 = createReducer(getConfigurationInitialState$1(), (builder) => builder.addCase(updateBasicConfiguration$1, (state, action) => {
  handleUpdateBasicConfiguration$1(state, action.payload);
}).addCase(updateSearchConfiguration, (state, action) => {
  handleUpdateSearchConfiguration(state, action.payload);
}).addCase(updateAnalyticsConfiguration$1, (state, action) => {
  handleUpdateAnalyticsConfiguration(state, action.payload);
}).addCase(disableAnalytics$1, (state) => {
  state.analytics.enabled = false;
}).addCase(enableAnalytics$1, (state) => {
  state.analytics.enabled = true;
}).addCase(setOriginLevel2, (state, action) => {
  state.analytics.originLevel2 = action.payload.originLevel2;
}).addCase(setOriginLevel3, (state, action) => {
  state.analytics.originLevel3 = action.payload.originLevel3;
}).addCase(updateActiveTab, (state, action) => {
  state.analytics.originLevel2 = action.payload;
}).addCase(restoreTab, (state, action) => {
  state.analytics.originLevel2 = action.payload;
}).addCase(restoreSearchParameters$1, (state, action) => {
  if (!isNullOrUndefined(action.payload.tab)) {
    state.analytics.originLevel2 = action.payload.tab;
  }
}));
function handleUpdateBasicConfiguration$1(state, payload) {
  if (!isNullOrUndefined(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!isNullOrUndefined(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateSearchConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.proxyBaseUrl)) {
    state.search.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!isNullOrUndefined(payload.locale)) {
    state.search.locale = payload.locale;
  }
  if (!isNullOrUndefined(payload.timezone)) {
    state.search.timezone = payload.timezone;
  }
  if (!isNullOrUndefined(payload.authenticationProviders)) {
    state.search.authenticationProviders = payload.authenticationProviders;
  }
}
function handleUpdateAnalyticsConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!isNullOrUndefined(payload.originContext)) {
    state.analytics.originContext = payload.originContext;
  }
  if (!isNullOrUndefined(payload.originLevel2)) {
    state.analytics.originLevel2 = payload.originLevel2;
  }
  if (!isNullOrUndefined(payload.originLevel3)) {
    state.analytics.originLevel3 = payload.originLevel3;
  }
  if (!isNullOrUndefined(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!isNullOrUndefined(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
  if (!isNullOrUndefined(payload.analyticsMode)) {
    state.analytics.analyticsMode = payload.analyticsMode;
  }
  if (!isNullOrUndefined(payload.source)) {
    state.analytics.source = payload.source;
  }
  try {
    const magicCookie = getMagicCookie();
    if (magicCookie) {
      state.analytics.analyticsMode = "next";
      state.analytics.trackingId = magicCookie;
    }
  } catch (_) {
  }
  if (!isNullOrUndefined(payload.runtimeEnvironment)) {
    state.analytics.runtimeEnvironment = payload.runtimeEnvironment;
  }
  if (!isNullOrUndefined(payload.anonymous)) {
    state.analytics.anonymous = payload.anonymous;
  }
  if (!isNullOrUndefined(payload.deviceId)) {
    state.analytics.deviceId = payload.deviceId;
  }
  if (!isNullOrUndefined(payload.userDisplayName)) {
    state.analytics.userDisplayName = payload.userDisplayName;
  }
  if (!isNullOrUndefined(payload.documentLocation)) {
    state.analytics.documentLocation = payload.documentLocation;
  }
}
const configuration = configurationReducer$1;
function isInstantlyCallableThunkAction(action) {
  return action.instantlyCallable;
}
const instantlyCallableThunkActionMiddleware = () => (next) => (action) => next(isInstantlyCallableThunkAction(action) ? action() : action);
const logActionErrorMiddleware = (logger) => () => (next) => (action) => {
  const unknownAction = action;
  if (!unknownAction.error) {
    return next(action);
  }
  const error = unknownAction.error;
  const errorPayloadMessage = [
    unknownAction.payload?.errorCode,
    unknownAction.payload?.message
  ].filter(Boolean).join(" - ");
  if (!unknownAction.payload?.ignored) {
    logger.error(errorPayloadMessage || error.stack || error.message || error.name || "Error", `Action dispatch error ${unknownAction.type}`, action);
  }
  if (unknownAction.error.name === "SchemaValidationError") {
    return;
  }
  return next(action);
};
const logActionMiddleware = (logger) => (api) => (next) => (action) => {
  logger.debug({
    action,
    nextState: api.getState()
  }, `Action dispatched: ${action.type}`);
  return next(action);
};
const getNavigatorContext = (relay, customProvider) => {
  const { referrer, userAgent, location, clientId } = relay.getMeta("");
  const customContext = customProvider ? customProvider() : {};
  return { ...customContext, referrer, userAgent, location, clientId };
};
function createReducerManager(initialReducers, preloadedState) {
  const reducers = { ...initialReducers };
  let crossReducer;
  const rootReducer = (combined) => {
    return (state, action) => {
      const intermediate = combined(state, action);
      const final = crossReducer ? crossReducer(intermediate, action) : intermediate;
      return final;
    };
  };
  return {
    get combinedReducer() {
      const placeholderReducers = fromEntries(Object.entries(preloadedState).filter(([key]) => !(key in reducers)).map(([key, value]) => [key, (() => value)]));
      return rootReducer(combineReducers({ ...placeholderReducers, ...reducers }));
    },
    containsAll(newReducers) {
      const keys2 = Object.keys(newReducers);
      return keys2.every((key) => key in reducers);
    },
    add(newReducers) {
      Object.keys(newReducers).filter((key) => !(key in reducers)).forEach((key) => {
        reducers[key] = newReducers[key];
      });
    },
    addCrossReducer(reducer) {
      crossReducer = reducer;
    }
  };
}
function parseJWT(token) {
  if (!token || !isJWTToken(token)) {
    return null;
  }
  try {
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const base64decoded = atob(base64);
    const jsonPayload = decodeURIComponent(base64decoded.split("").map((character) => {
      return `%${`00${character.charCodeAt(0).toString(16)}`.slice(-2)}`;
    }).join(""));
    return JSON.parse(jsonPayload);
  } catch (_) {
    return null;
  }
}
function shouldRenewJWT(token, bufferSeconds = 60) {
  if (!token) {
    return false;
  }
  const parsedToken = parseJWT(token);
  if (!parsedToken || typeof parsedToken.exp !== "number") {
    return false;
  }
  const nowSeconds = Math.floor(Date.now() / 1e3);
  return parsedToken.exp <= nowSeconds + bufferSeconds;
}
function isJWTToken(token) {
  if (!token) {
    return false;
  }
  return /^[A-Za-z0-9_-]{2,}(?:\.[A-Za-z0-9_-]{2,}){2}$/.test(token);
}
function createRenewAccessTokenMiddleware(logger, renewToken) {
  let accessTokenRenewalsAttempts = 0;
  let pendingTokenRenewal = null;
  const resetRenewalTriesAfterDelay = debounce(() => {
    accessTokenRenewalsAttempts = 0;
  }, 500);
  const handleTokenRenewal = async (store, handleErrors = false) => {
    const isTokenRenewalPending = !pendingTokenRenewal;
    if (isTokenRenewalPending && renewToken) {
      pendingTokenRenewal = (async () => {
        if (handleErrors) {
          attempt(renewToken);
        }
        return await renewToken();
      })().finally(() => {
        pendingTokenRenewal = null;
      });
    }
    const accessToken = await pendingTokenRenewal;
    if (isTokenRenewalPending && accessToken) {
      store.dispatch(updateBasicConfiguration$1({ accessToken }));
    }
    return accessToken;
  };
  const handleProactiveTokenRenewal = async (store) => {
    const state = store.getState();
    const accessToken = getAccessTokenFromState(state);
    if (!accessToken || !shouldRenewJWT(accessToken)) {
      return;
    }
    logger.debug("Access token is expired or about to expire, attempting renewal.");
    try {
      const newAccessToken = await handleTokenRenewal(store);
      if (newAccessToken) {
        logger.debug("Access token was renewed.");
      } else {
        logger.warn("Access token renewal returned an empty token. Please check the #renewAccessToken function.");
      }
    } catch (error) {
      logger.warn(error, "Access token renewal failed. A retry will occur if necessary.");
    }
  };
  const handleExpiredToken = async (store, payload, action) => {
    if (accessTokenRenewalsAttempts >= 5) {
      logger.warn("Attempted to renew the token but was not successful. Please check the #renewAccessToken function.");
      dispatchError(store, payload.error);
      return payload;
    }
    accessTokenRenewalsAttempts++;
    resetRenewalTriesAfterDelay();
    await handleTokenRenewal(store, true);
    store.dispatch(action);
    return;
  };
  return (store) => (next) => async (action) => {
    const isThunk = typeof action === "function";
    const hasRenewFunction = typeof renewToken === "function";
    if (!isThunk) {
      return next(action);
    }
    if (hasRenewFunction) {
      await handleProactiveTokenRenewal(store);
    }
    const payload = await next(action);
    if (!isExpiredTokenError(payload)) {
      return payload;
    }
    if (!hasRenewFunction) {
      logger.warn("Unable to renew the expired token because a renew function was not provided. Please specify the #renewAccessToken option when initializing the engine.");
      dispatchError(store, payload.error);
      return payload;
    }
    return await handleExpiredToken(store, payload, action);
  };
}
function isExpiredTokenError(action) {
  return typeof action === "object" && action !== null && "error" in action && // biome-ignore lint/suspicious/noExplicitAny: any action is possible here.
  action.error?.name === new UnauthorizedTokenError().name;
}
function dispatchError(store, error) {
  store.dispatch(setError({
    status: 401,
    statusCode: 401,
    message: error.message,
    type: error.name
  }));
}
async function attempt(fn) {
  try {
    return await fn();
  } catch (_) {
    return "";
  }
}
function getAccessTokenFromState(state) {
  return state.configuration.accessToken;
}
const stateKeyDescription = "coveo-headless-internal-state";
const stateKey = Symbol.for(stateKeyDescription);
const redactEngine = (engine) => new Proxy(engine, {
  ownKeys(target) {
    return Reflect.ownKeys(target).filter((key) => key !== stateKey);
  },
  get(target, prop, receiver) {
    if (typeof prop === "symbol" && prop.description === stateKeyDescription && prop !== stateKey) {
      engine.logger.warn("You might be loading Headless twice. Please check your setup.\nIf you are trying to access the inner state... Don't");
    }
    return Reflect.get(target, prop, receiver);
  }
});
function configureStore({ reducer, preloadedState, middlewares = [], thunkExtraArguments, name }) {
  return configureStore$1({
    reducer,
    preloadedState,
    devTools: {
      stateSanitizer: (state) => state.history ? { ...state, history: "<<OMIT>>" } : state,
      name,
      shouldHotReload: false
      // KIT-961 -> Redux dev tool + hot reloading interacts badly with replaceReducers mechanism.
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ thunk: { extraArgument: thunkExtraArguments } }).prepend(...middlewares).concat(logActionMiddleware(thunkExtraArguments.logger))
  });
}
function getUpdateAnalyticsConfigurationPayload(configuration2, logger) {
  const { analytics } = configuration2;
  const { analyticsClientMiddleware: _, ...payload } = analytics ?? {};
  const payloadWithURL = {
    ...payload,
    ...analytics?.proxyBaseUrl && {
      apiBaseUrl: analytics.proxyBaseUrl,
      nexApiBaseUrl: analytics.proxyBaseUrl
    }
  };
  if (payloadWithURL.analyticsMode !== "next" && doNotTrack$1()) {
    logger.info("Analytics disabled since doNotTrack is active.");
    return {
      ...payloadWithURL,
      enabled: false
    };
  }
  return payloadWithURL;
}
function buildEngine(options2, thunkExtraArguments) {
  const reducers = {
    ...options2.reducers,
    configuration,
    version: versionReducer
  };
  const engine = buildCoreEngine({ ...options2, reducers }, thunkExtraArguments, configuration);
  const { accessToken, environment, organizationId } = options2.configuration;
  engine.dispatch(updateBasicConfiguration$1({
    accessToken,
    environment,
    organizationId
  }));
  const analyticsPayload = getUpdateAnalyticsConfigurationPayload(options2.configuration, engine.logger);
  if (analyticsPayload) {
    engine.dispatch(updateAnalyticsConfiguration$1(analyticsPayload));
  }
  return engine;
}
function buildCoreEngine(options2, thunkExtraArguments, configurationReducer2) {
  const { reducers, navigatorContextProvider } = options2;
  const reducerManager = createReducerManager({ ...reducers, configurationReducer: configurationReducer2 }, options2.preloadedState ?? {});
  if (options2.crossReducer) {
    reducerManager.addCrossReducer(options2.crossReducer);
  }
  const logger = thunkExtraArguments.logger;
  const thunkExtraArgumentsWithRelay = {
    ...thunkExtraArguments,
    get relay() {
      return getRelayInstanceFromState(engine.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    }
  };
  const store = createStore(options2, thunkExtraArgumentsWithRelay, reducerManager);
  const engine = {
    addReducers(reducers2) {
      if (reducerManager.containsAll(reducers2)) {
        return;
      }
      reducerManager.add(reducers2);
      store.replaceReducer(reducerManager.combinedReducer);
    },
    dispatch: store.dispatch,
    subscribe: store.subscribe,
    enableAnalytics() {
      store.dispatch(enableAnalytics$1());
    },
    disableAnalytics() {
      store.dispatch(disableAnalytics$1());
    },
    get state() {
      return store.getState();
    },
    get relay() {
      return getRelayInstanceFromState(this.state, navigatorContextProvider);
    },
    get navigatorContext() {
      return getNavigatorContext(this.relay, navigatorContextProvider);
    },
    logger,
    store
  };
  return engine;
}
function createStore(options2, thunkExtraArguments, reducerManager) {
  const { preloadedState, configuration: configuration2 } = options2;
  const name = configuration2.name || "coveo-headless";
  const middlewares = createMiddleware(options2, thunkExtraArguments.logger);
  return configureStore({
    preloadedState,
    reducer: reducerManager.combinedReducer,
    middlewares,
    thunkExtraArguments,
    name
  });
}
function createMiddleware(options2, logger) {
  const { renewAccessToken } = options2.configuration;
  const renewTokenMiddleware = createRenewAccessTokenMiddleware(logger, renewAccessToken);
  return [
    instantlyCallableThunkActionMiddleware,
    renewTokenMiddleware,
    logActionErrorMiddleware(logger),
    analyticsMiddleware
  ].concat(answerApi.middleware, options2.middlewares || []);
}
const nextAnalyticsUsageWithServiceFeatureWarning = '[Warning] A component from the Coveo Headless library has been instantiated with the Analytics Mode: "Next".\nHowever, this mode is not available for Coveo for Service features, and this configuration may not work as expected.\nPlease switch back to the "legacy" analytics mode to ensure proper functionality.\nFor more information, refer to the documentation: https://docs.coveo.com/en/o3r90189/build-a-search-ui/event-protocol';
function warnIfUsingNextAnalyticsModeForServiceFeature(analyticsMode) {
  if (analyticsMode === "next") {
    console.warn(nextAnalyticsUsageWithServiceFeatureWarning);
  }
}
var pino = { exports: {} };
var errHelpers;
var hasRequiredErrHelpers;
function requireErrHelpers() {
  if (hasRequiredErrHelpers) return errHelpers;
  hasRequiredErrHelpers = 1;
  const isErrorLike = (err2) => {
    return err2 && typeof err2.message === "string";
  };
  const getErrorCause = (err2) => {
    if (!err2) return;
    const cause = err2.cause;
    if (typeof cause === "function") {
      const causeResult = err2.cause();
      return isErrorLike(causeResult) ? causeResult : void 0;
    } else {
      return isErrorLike(cause) ? cause : void 0;
    }
  };
  const _stackWithCauses = (err2, seen) => {
    if (!isErrorLike(err2)) return "";
    const stack = err2.stack || "";
    if (seen.has(err2)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  const stackWithCauses = (err2) => _stackWithCauses(err2, /* @__PURE__ */ new Set());
  const _messageWithCauses = (err2, seen, skip) => {
    if (!isErrorLike(err2)) return "";
    const message = skip ? "" : err2.message || "";
    if (seen.has(err2)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err2);
    if (cause) {
      seen.add(err2);
      const skipIfVErrorStyleCause = typeof err2.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  const messageWithCauses = (err2) => _messageWithCauses(err2, /* @__PURE__ */ new Set());
  errHelpers = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
  return errHelpers;
}
var errProto;
var hasRequiredErrProto;
function requireErrProto() {
  if (hasRequiredErrProto) return errProto;
  hasRequiredErrProto = 1;
  const seen = Symbol("circular-ref-tag");
  const rawSymbol = Symbol("pino-raw-err-ref");
  const pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    message: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    stack: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: void 0
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  errProto = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
  return errProto;
}
var err;
var hasRequiredErr;
function requireErr() {
  if (hasRequiredErr) return err;
  hasRequiredErr = 1;
  err = errSerializer;
  const { messageWithCauses, stackWithCauses, isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString } = Object.prototype;
  function errSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = messageWithCauses(err2);
    _err.stack = stackWithCauses(err2);
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errSerializer(err3));
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return err;
}
var errWithCause;
var hasRequiredErrWithCause;
function requireErrWithCause() {
  if (hasRequiredErrWithCause) return errWithCause;
  hasRequiredErrWithCause = 1;
  errWithCause = errWithCauseSerializer;
  const { isErrorLike } = requireErrHelpers();
  const { pinoErrProto, pinoErrorSymbols } = requireErrProto();
  const { seen } = pinoErrorSymbols;
  const { toString } = Object.prototype;
  function errWithCauseSerializer(err2) {
    if (!isErrorLike(err2)) {
      return err2;
    }
    err2[seen] = void 0;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err2.constructor) === "[object Function]" ? err2.constructor.name : err2.name;
    _err.message = err2.message;
    _err.stack = err2.stack;
    if (Array.isArray(err2.errors)) {
      _err.aggregateErrors = err2.errors.map((err3) => errWithCauseSerializer(err3));
    }
    if (isErrorLike(err2.cause) && !Object.prototype.hasOwnProperty.call(err2.cause, seen)) {
      _err.cause = errWithCauseSerializer(err2.cause);
    }
    for (const key in err2) {
      if (_err[key] === void 0) {
        const val = err2[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err2[seen];
    _err.raw = err2;
    return _err;
  }
  return errWithCause;
}
var req;
var hasRequiredReq;
function requireReq() {
  if (hasRequiredReq) return req;
  hasRequiredReq = 1;
  req = {
    mapHttpRequest,
    reqSerializer
  };
  const rawSymbol = Symbol("pino-raw-req-ref");
  const pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function reqSerializer(req2) {
    const connection = req2.info || req2.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req2.id === "function" ? req2.id() : req2.id || (req2.info ? req2.info.id : void 0);
    _req.method = req2.method;
    if (req2.originalUrl) {
      _req.url = req2.originalUrl;
    } else {
      const path = req2.path;
      _req.url = typeof path === "string" ? path : req2.url ? req2.url.path || req2.url : void 0;
    }
    if (req2.query) {
      _req.query = req2.query;
    }
    if (req2.params) {
      _req.params = req2.params;
    }
    _req.headers = req2.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req2.raw || req2;
    return _req;
  }
  function mapHttpRequest(req2) {
    return {
      req: reqSerializer(req2)
    };
  }
  return req;
}
var res;
var hasRequiredRes;
function requireRes() {
  if (hasRequiredRes) return res;
  hasRequiredRes = 1;
  res = {
    mapHttpResponse,
    resSerializer
  };
  const rawSymbol = Symbol("pino-raw-res-ref");
  const pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function resSerializer(res2) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res2.headersSent ? res2.statusCode : null;
    _res.headers = res2.getHeaders ? res2.getHeaders() : res2._headers;
    _res.raw = res2;
    return _res;
  }
  function mapHttpResponse(res2) {
    return {
      res: resSerializer(res2)
    };
  }
  return res;
}
var pinoStdSerializers;
var hasRequiredPinoStdSerializers;
function requirePinoStdSerializers() {
  if (hasRequiredPinoStdSerializers) return pinoStdSerializers;
  hasRequiredPinoStdSerializers = 1;
  const errSerializer = requireErr();
  const errWithCauseSerializer = requireErrWithCause();
  const reqSerializers = requireReq();
  const resSerializers = requireRes();
  pinoStdSerializers = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer) return customSerializer;
      return function wrapErrSerializer(err2) {
        return customSerializer(errSerializer(err2));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
      return function wrappedReqSerializer(req2) {
        return customSerializer(reqSerializers.reqSerializer(req2));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer) return customSerializer;
      return function wrappedResSerializer(res2) {
        return customSerializer(resSerializers.resSerializer(res2));
      };
    }
  };
  return pinoStdSerializers;
}
var caller;
var hasRequiredCaller;
function requireCaller() {
  if (hasRequiredCaller) return caller;
  hasRequiredCaller = 1;
  function noOpPrepareStackTrace(_, stack) {
    return stack;
  }
  caller = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return void 0;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
  return caller;
}
var validator_1;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator_1;
  hasRequiredValidator = 1;
  validator_1 = validator;
  function validator(opts = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH = (s) => `fast-redact  Invalid path (${s})`
    } = opts;
    return function validate2({ paths }) {
      paths.forEach((s) => {
        if (typeof s !== "string") {
          throw Error(ERR_PATHS_MUST_BE_STRINGS());
        }
        try {
          if (//.test(s)) throw Error();
          const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "").replace(/\.\*/g, ".").replace(/\[\*\]/g, "[]");
          if (/\n|\r|;/.test(expr)) throw Error();
          if (/\/\*/.test(expr)) throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const  = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
        } catch (e) {
          throw Error(ERR_INVALID_PATH(s));
        }
      });
    };
  }
  return validator_1;
}
var rx;
var hasRequiredRx;
function requireRx() {
  if (hasRequiredRx) return rx;
  hasRequiredRx = 1;
  rx = /[^.[\]]+|\[((?:.)*?)\]/g;
  return rx;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const rx2 = requireRx();
  parse_1 = parse2;
  function parse2({ paths }) {
    const wildcards = [];
    var wcLen = 0;
    const secret = paths.reduce(function(o, strPath, ix) {
      var path = strPath.match(rx2).map((p) => p.replace(/'|"|`/g, ""));
      const leadingBracket = strPath[0] === "[";
      path = path.map((p) => {
        if (p[0] === "[") return p.substr(1, p.length - 2);
        else return p;
      });
      const star = path.indexOf("*");
      if (star > -1) {
        const before = path.slice(0, star);
        const beforeStr = before.join(".");
        const after = path.slice(star + 1, path.length);
        const nested = after.length > 0;
        wcLen++;
        wildcards.push({
          before,
          beforeStr,
          after,
          nested
        });
      } else {
        o[strPath] = {
          path,
          val: void 0,
          precensored: false,
          circle: "",
          escPath: JSON.stringify(strPath),
          leadingBracket
        };
      }
      return o;
    }, {});
    return { wildcards, wcLen, secret };
  }
  return parse_1;
}
var redactor_1;
var hasRequiredRedactor;
function requireRedactor() {
  if (hasRequiredRedactor) return redactor_1;
  hasRequiredRedactor = 1;
  const rx2 = requireRx();
  redactor_1 = redactor;
  function redactor({ secret, serialize: serialize2, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
    const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize2)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize2)}
  `).bind(state);
    redact.state = state;
    if (serialize2 === false) {
      redact.restore = (o) => state.restore(o);
    }
    return redact;
  }
  function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
    return Object.keys(secret).map((path) => {
      const { escPath, leadingBracket, path: arrPath } = secret[path];
      const skip = leadingBracket ? 1 : 0;
      const delim = leadingBracket ? "" : ".";
      const hops = [];
      var match;
      while ((match = rx2.exec(path)) !== null) {
        const [, ix] = match;
        const { index, input } = match;
        if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
      }
      var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
      if (existence.length === 0) existence += `o${delim}${path} != null`;
      else existence += ` && o${delim}${path} != null`;
      const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
      const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
      return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
    }).join("\n");
  }
  function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
    return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
  }
  function resultTmpl(serialize2) {
    return serialize2 === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
  function strictImpl(strict, serialize2) {
    return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize2 === false ? `return o` : `return this.serialize(o)`;
  }
  return redactor_1;
}
var modifiers;
var hasRequiredModifiers;
function requireModifiers() {
  if (hasRequiredModifiers) return modifiers;
  hasRequiredModifiers = 1;
  modifiers = {
    groupRedact,
    groupRestore,
    nestedRedact,
    nestedRestore
  };
  function groupRestore({ keys: keys2, values, target }) {
    if (target == null || typeof target === "string") return;
    const length = keys2.length;
    for (var i = 0; i < length; i++) {
      const k = keys2[i];
      target[k] = values[i];
    }
  }
  function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
    const target = get2(o, path);
    if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
    const keys2 = Object.keys(target);
    const keysLength = keys2.length;
    const pathLength = path.length;
    const pathWithKey = censorFctTakesPath ? [...path] : void 0;
    const values = new Array(keysLength);
    for (var i = 0; i < keysLength; i++) {
      const key = keys2[i];
      values[i] = target[key];
      if (censorFctTakesPath) {
        pathWithKey[pathLength] = key;
        target[key] = censor(target[key], pathWithKey);
      } else if (isCensorFct) {
        target[key] = censor(target[key]);
      } else {
        target[key] = censor;
      }
    }
    return { keys: keys2, values, target, flat: true };
  }
  function nestedRestore(instructions) {
    for (let i = 0; i < instructions.length; i++) {
      const { target, path, value } = instructions[i];
      let current2 = target;
      for (let i2 = path.length - 1; i2 > 0; i2--) {
        current2 = current2[path[i2]];
      }
      current2[path[0]] = value;
    }
  }
  function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
    const target = get2(o, path);
    if (target == null) return;
    const keys2 = Object.keys(target);
    const keysLength = keys2.length;
    for (var i = 0; i < keysLength; i++) {
      const key = keys2[i];
      specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
    }
    return store;
  }
  function has2(obj, prop) {
    return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
  }
  function specialSet(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
    const afterPathLen = afterPath.length;
    const lastPathIndex = afterPathLen - 1;
    const originalKey = k;
    var i = -1;
    var n;
    var nv;
    var ov;
    var wc = null;
    var kIsWc;
    var wcov;
    var consecutive = false;
    var level = 0;
    var depth = 0;
    var redactPathCurrent = tree();
    ov = n = o[k];
    if (typeof n !== "object") return;
    while (n != null && ++i < afterPathLen) {
      depth += 1;
      k = afterPath[i];
      if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
        break;
      }
      if (k === "*") {
        if (wc === "*") {
          consecutive = true;
        }
        wc = k;
        if (i !== lastPathIndex) {
          continue;
        }
      }
      if (wc) {
        const wcKeys = Object.keys(n);
        for (var j = 0; j < wcKeys.length; j++) {
          const wck = wcKeys[j];
          wcov = n[wck];
          kIsWc = k === "*";
          if (consecutive) {
            redactPathCurrent = node(redactPathCurrent, wck, depth);
            level = i;
            ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
          } else {
            if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
              if (kIsWc) {
                ov = wcov;
              } else {
                ov = wcov[k];
              }
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
              if (kIsWc) {
                const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                store.push(rv);
                n[wck] = nv;
              } else {
                if (wcov[k] === nv) ;
                else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) {
                  redactPathCurrent = node(redactPathCurrent, wck, depth);
                } else {
                  redactPathCurrent = node(redactPathCurrent, wck, depth);
                  const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                  store.push(rv);
                  wcov[k] = nv;
                }
              }
            }
          }
        }
        wc = null;
      } else {
        ov = n[k];
        redactPathCurrent = node(redactPathCurrent, k, depth);
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
        if (has2(n, k) && nv === ov || nv === void 0 && censor !== void 0) ;
        else {
          const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
          store.push(rv);
          n[k] = nv;
        }
        n = n[k];
      }
      if (typeof n !== "object") break;
    }
  }
  function get2(o, p) {
    var i = -1;
    var l = p.length;
    var n = o;
    while (n != null && ++i < l) {
      n = n[p[i]];
    }
    return n;
  }
  function iterateNthLevel(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
    if (level === 0) {
      if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
        if (kIsWc) {
          ov = wcov;
        } else {
          ov = wcov[k];
        }
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
        if (kIsWc) {
          const rv = restoreInstr(redactPathCurrent, ov, parent);
          store.push(rv);
          n[wck] = nv;
        } else {
          if (wcov[k] === nv) ;
          else if (nv === void 0 && censor !== void 0 || has2(wcov, k) && nv === ov) ;
          else {
            const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
            store.push(rv);
            wcov[k] = nv;
          }
        }
      }
    }
    for (const key in wcov) {
      if (typeof wcov[key] === "object") {
        redactPathCurrent = node(redactPathCurrent, key, depth);
        iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
      }
    }
  }
  function tree() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
  function node(parent, key, depth) {
    if (parent.depth === depth) {
      return node(parent.parent, key, depth);
    }
    var child = {
      parent,
      key,
      depth,
      children: []
    };
    parent.children.push(child);
    return child;
  }
  function restoreInstr(node2, value, target) {
    let current2 = node2;
    const path = [];
    do {
      path.push(current2.key);
      current2 = current2.parent;
    } while (current2.parent != null);
    return { path, value, target };
  }
  return modifiers;
}
var restorer_1;
var hasRequiredRestorer;
function requireRestorer() {
  if (hasRequiredRestorer) return restorer_1;
  hasRequiredRestorer = 1;
  const { groupRestore, nestedRestore } = requireModifiers();
  restorer_1 = restorer;
  function restorer() {
    return function compileRestore() {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
      const { secret, wcLen } = this;
      const paths = Object.keys(secret);
      const resetters = resetTmpl(secret, paths);
      const hasWildcards = wcLen > 0;
      const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
      this.restore = Function(
        "o",
        restoreTmpl(resetters, paths, hasWildcards)
      ).bind(state);
      this.restore.state = state;
    };
  }
  function resetTmpl(secret, paths) {
    return paths.map((path) => {
      const { circle, escPath, leadingBracket } = secret[path];
      const delim = leadingBracket ? "" : ".";
      const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
      const clear = `secret[${escPath}].val = undefined`;
      return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
    }).join("");
  }
  function restoreTmpl(resetters, paths, hasWildcards) {
    const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
    return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
  }
  return restorer_1;
}
var state_1;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state_1;
  hasRequiredState = 1;
  state_1 = state;
  function state(o) {
    const {
      secret,
      censor,
      compileRestore,
      serialize: serialize2,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    } = o;
    const builder = [{ secret, censor, compileRestore }];
    if (serialize2 !== false) builder.push({ serialize: serialize2 });
    if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
    return Object.assign(...builder);
  }
  return state_1;
}
var fastRedact_1;
var hasRequiredFastRedact;
function requireFastRedact() {
  if (hasRequiredFastRedact) return fastRedact_1;
  hasRequiredFastRedact = 1;
  const validator = requireValidator();
  const parse2 = requireParse();
  const redactor = requireRedactor();
  const restorer = requireRestorer();
  const { groupRedact, nestedRedact } = requireModifiers();
  const state = requireState();
  const rx2 = requireRx();
  const validate2 = validator();
  const noop2 = (o) => o;
  noop2.restore = noop2;
  const DEFAULT_CENSOR = "[REDACTED]";
  fastRedact.rx = rx2;
  fastRedact.validator = validator;
  fastRedact_1 = fastRedact;
  function fastRedact(opts = {}) {
    const paths = Array.from(new Set(opts.paths || []));
    const serialize2 = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
    const remove = opts.remove;
    if (remove === true && serialize2 !== JSON.stringify) {
      throw Error("fast-redact  remove option may only be set when serializer is JSON.stringify");
    }
    const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
    const isCensorFct = typeof censor === "function";
    const censorFctTakesPath = isCensorFct && censor.length > 1;
    if (paths.length === 0) return serialize2 || noop2;
    validate2({ paths, serialize: serialize2, censor });
    const { wildcards, wcLen, secret } = parse2({ paths, censor });
    const compileRestore = restorer();
    const strict = "strict" in opts ? opts.strict : true;
    return redactor({ secret, wcLen, serialize: serialize2, strict, isCensorFct, censorFctTakesPath }, state({
      secret,
      censor,
      compileRestore,
      serialize: serialize2,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    }));
  }
  return fastRedact_1;
}
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  const setLevelSym = Symbol("pino.setLevel");
  const getLevelSym = Symbol("pino.getLevel");
  const levelValSym = Symbol("pino.levelVal");
  const levelCompSym = Symbol("pino.levelComp");
  const useLevelLabelsSym = Symbol("pino.useLevelLabels");
  const useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  const mixinSym = Symbol("pino.mixin");
  const lsCacheSym = Symbol("pino.lsCache");
  const chindingsSym = Symbol("pino.chindings");
  const asJsonSym = Symbol("pino.asJson");
  const writeSym = Symbol("pino.write");
  const redactFmtSym = Symbol("pino.redactFmt");
  const timeSym = Symbol("pino.time");
  const timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  const streamSym = Symbol("pino.stream");
  const stringifySym = Symbol("pino.stringify");
  const stringifySafeSym = Symbol("pino.stringifySafe");
  const stringifiersSym = Symbol("pino.stringifiers");
  const endSym = Symbol("pino.end");
  const formatOptsSym = Symbol("pino.formatOpts");
  const messageKeySym = Symbol("pino.messageKey");
  const errorKeySym = Symbol("pino.errorKey");
  const nestedKeySym = Symbol("pino.nestedKey");
  const nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  const mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  const msgPrefixSym = Symbol("pino.msgPrefix");
  const wildcardFirstSym = Symbol("pino.wildcardFirst");
  const serializersSym = Symbol.for("pino.serializers");
  const formattersSym = Symbol.for("pino.formatters");
  const hooksSym = Symbol.for("pino.hooks");
  const needsMetadataGsym = Symbol.for("pino.metadata");
  symbols = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
  return symbols;
}
var redaction_1;
var hasRequiredRedaction;
function requireRedaction() {
  if (hasRequiredRedaction) return redaction_1;
  hasRequiredRedaction = 1;
  const fastRedact = requireFastRedact();
  const { redactFmtSym, wildcardFirstSym } = requireSymbols();
  const { rx: rx2, validator } = fastRedact;
  const validate2 = validator({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino  redacted paths must be strings",
    ERR_INVALID_PATH: (s) => `pino  redact paths array contains an invalid path (${s})`
  });
  const CENSOR = "[Redacted]";
  const strict = false;
  function redaction(opts, serialize2) {
    const { paths, censor } = handle(opts);
    const shape = paths.reduce((o, str) => {
      rx2.lastIndex = 0;
      const first = rx2.exec(str);
      const next = rx2.exec(str);
      let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o[ns] = null;
        return o;
      }
      if (o[ns] === null) {
        return o;
      }
      const { index } = next;
      const nextPath = `${str.substr(index, str.length - 1)}`;
      o[ns] = o[ns] || [];
      if (ns !== wildcardFirstSym && o[ns].length === 0) {
        o[ns].push(...o[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o).forEach(function(k) {
          if (o[k]) {
            o[k].push(nextPath);
          }
        });
      }
      o[ns].push(nextPath);
      return o;
    }, {});
    const result = {
      [redactFmtSym]: fastRedact({ paths, censor, serialize: serialize2, strict })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize2(censor(...args)) : serialize2(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
      if (shape[k] === null) {
        o[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path) => {
          return censor(value, [k, ...path]);
        } : censor;
        o[k] = fastRedact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize: serialize2,
          strict
        });
      }
      return o;
    }, result);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      validate2(opts);
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino  redact must contain an array of strings");
    }
    if (remove === true) censor = void 0;
    validate2({ paths, censor });
    return { paths, censor };
  }
  redaction_1 = redaction;
  return redaction_1;
}
var time;
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime) return time;
  hasRequiredTime = 1;
  const nullTime = () => "";
  const epochTime = () => `,"time":${Date.now()}`;
  const unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
  const isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  time = { nullTime, epochTime, unixTime, isoTime };
  return time;
}
var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function tryStringify(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = format;
  function format(f2, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f2 === "object" && f2 !== null) {
      var len = args.length + offset;
      if (len === 1) return f2;
      var objects = new Array(len);
      objects[0] = ss(f2);
      for (var index = 1; index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f2 !== "string") {
      return f2;
    }
    var argLen = args.length;
    if (argLen === 0) return f2;
    var str = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f2 && f2.length || 0;
    for (var i = 0; i < flen; ) {
      if (f2.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f2.charCodeAt(i + 1)) {
          case 100:
          // 'd'
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null) break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          // 'O'
          case 111:
          // 'o'
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === void 0) break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            var type = typeof args[a];
            if (type === "string") {
              str += "'" + args[a] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type === "function") {
              str += args[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += String(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f2;
    else if (lastPos < flen) {
      str += f2.slice(lastPos);
    }
    return str;
  }
  return quickFormatUnescaped;
}
var atomicSleep = { exports: {} };
var hasRequiredAtomicSleep;
function requireAtomicSleep() {
  if (hasRequiredAtomicSleep) return atomicSleep.exports;
  hasRequiredAtomicSleep = 1;
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    atomicSleep.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
    };
    atomicSleep.exports = sleep;
  }
  return atomicSleep.exports;
}
var sonicBoom;
var hasRequiredSonicBoom;
function requireSonicBoom() {
  if (hasRequiredSonicBoom) return sonicBoom;
  hasRequiredSonicBoom = 1;
  const fs2 = require$$0$1;
  const EventEmitter = require$$1;
  const inherits = require$$2.inherits;
  const path = require$$3;
  const sleep = requireAtomicSleep();
  const assert = require$$5;
  const BUSY_WRITE_TIMEOUT = 100;
  const kEmptyBuffer = Buffer.allocUnsafe(0);
  const MAX_WRITE = 16 * 1024;
  const kContentModeBuffer = "buffer";
  const kContentModeUtf8 = "utf8";
  const [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
  const kCopyBuffer = major >= 22 && minor >= 7;
  function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err2, fd) {
      if (err2) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err2);
            }
          });
        } else {
          sonic.emit("error", err2);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir) fs2.mkdirSync(path.dirname(file), { recursive: true });
        const fd = fs2.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err2) {
        fileOpened(err2);
        throw err2;
      }
    } else if (sonic.mkdir) {
      fs2.mkdir(path.dirname(file), { recursive: true }, (err2) => {
        if (err2) return fileOpened(err2);
        fs2.open(file, flags, mode, fileOpened);
      });
    } else {
      fs2.open(file, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = void 0;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err2, n) => {
      if (err2) {
        if ((err2.code === "EAGAIN" || err2.code === "EBUSY") && this.retryEAGAIN(err2, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(void 0, 0);
            } catch (err3) {
              this.release(err3);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err2);
        }
        return;
      }
      this.emit("write", n);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n2 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err3) {
          this.release(err3);
          return;
        }
      }
      if (this._fsync) {
        fs2.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
      n = Buffer.from(writingBuf).subarray(0, n).toString().length;
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.slice(n);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners) return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  inherits(SonicBoom, EventEmitter);
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs2.fsync(this.fd, (err2) => {
            this._flushPending = false;
            cb(err2);
          });
        } catch (err2) {
          cb(err2);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err2) => {
      this._flushPending = false;
      cb(err2);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error);
        return;
      }
      throw error;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error);
        return;
      }
      throw error;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file) {
      this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs2.close(fd, (err2) => {
          if (err2) {
            return this.emit("error", err2);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n = fs2.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs2.fsyncSync(this.fd);
    } catch {
    }
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n = fs2.writeSync(this.fd, buf);
        buf = buf.subarray(n);
        this._len = Math.max(this._len - n, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err2) {
        const shouldRetry = err2.code === "EAGAIN" || err2.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err2, buf.length, this._len - buf.length)) {
          throw err2;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      fs2.write(this.fd, this._writingBuf, "utf8", release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err2) {
        release(err2);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs2.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== void 0) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs2.fsync(sonic.fd, closeWrapped);
    } catch {
    }
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs2.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err2) {
      if (err2) {
        sonic.emit("error", err2);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  sonicBoom = SonicBoom;
  return sonicBoom;
}
var onExitLeakFree;
var hasRequiredOnExitLeakFree;
function requireOnExitLeakFree() {
  if (hasRequiredOnExitLeakFree) return onExitLeakFree;
  hasRequiredOnExitLeakFree = 1;
  const refs = {
    exit: [],
    beforeExit: []
  };
  const functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  let registry;
  function ensureRegistry() {
    if (registry === void 0) {
      registry = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry = void 0;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref of refs[event]) {
      const obj = ref.deref();
      const fn = ref.fn;
      if (obj !== void 0) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn) {
    if (obj === void 0) {
      throw new Error("the object can't be undefined");
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    ensureRegistry();
    registry.register(obj, ref);
    refs[event].push(ref);
  }
  function register(obj, fn) {
    _register("exit", obj, fn);
  }
  function registerBeforeExit(obj, fn) {
    _register("beforeExit", obj, fn);
  }
  function unregister(obj) {
    if (registry === void 0) {
      return;
    }
    registry.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref) => {
        const _obj = ref.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  onExitLeakFree = {
    register,
    registerBeforeExit,
    unregister
  };
  return onExitLeakFree;
}
const version = "3.1.0";
const require$$0 = {
  version
};
var wait_1;
var hasRequiredWait;
function requireWait() {
  if (hasRequiredWait) return wait_1;
  hasRequiredWait = 1;
  const MAX_TIMEOUT2 = 1e3;
  function wait(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current2 = Atomics.load(state, index);
    if (current2 === expected) {
      done(null, "ok");
      return;
    }
    let prior = current2;
    const check = (backoff2) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current2;
          current2 = Atomics.load(state, index);
          if (current2 === prior) {
            check(backoff2 >= MAX_TIMEOUT2 ? MAX_TIMEOUT2 : backoff2 * 2);
          } else {
            if (current2 === expected) done(null, "ok");
            else done(null, "not-equal");
          }
        }, backoff2);
      }
    };
    check(1);
  }
  function waitDiff(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current2 = Atomics.load(state, index);
    if (current2 !== expected) {
      done(null, "ok");
      return;
    }
    const check = (backoff2) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current2 = Atomics.load(state, index);
          if (current2 !== expected) {
            done(null, "ok");
          } else {
            check(backoff2 >= MAX_TIMEOUT2 ? MAX_TIMEOUT2 : backoff2 * 2);
          }
        }, backoff2);
      }
    };
    check(1);
  }
  wait_1 = { wait, waitDiff };
  return wait_1;
}
var indexes;
var hasRequiredIndexes;
function requireIndexes() {
  if (hasRequiredIndexes) return indexes;
  hasRequiredIndexes = 1;
  const WRITE_INDEX = 4;
  const READ_INDEX = 8;
  indexes = {
    WRITE_INDEX,
    READ_INDEX
  };
  return indexes;
}
var threadStream;
var hasRequiredThreadStream;
function requireThreadStream() {
  if (hasRequiredThreadStream) return threadStream;
  hasRequiredThreadStream = 1;
  const { version: version2 } = require$$0;
  const { EventEmitter } = require$$1;
  const { Worker } = require$$2$1;
  const { join } = require$$3;
  const { pathToFileURL } = require$$4;
  const { wait } = requireWait();
  const {
    WRITE_INDEX,
    READ_INDEX
  } = requireIndexes();
  const buffer = require$$7;
  const assert = require$$5;
  const kImpl = Symbol("kImpl");
  const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }
  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  const FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : commonjsGlobal.FinalizationRegistry || FakeFinalizationRegistry;
  const WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : commonjsGlobal.WeakRef || FakeWeakRef;
  const registry = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });
  function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream[kImpl].dataBuf,
        stateBuf: stream[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version2
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry.register(stream, worker);
    return worker;
  }
  function drain(stream) {
    assert(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
      stream[kImpl].needDrain = false;
      stream.emit("drain");
    }
  }
  function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream[kImpl].buf.length === 0) {
        stream[kImpl].flushing = false;
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
        return;
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, nextFlush.bind(null, stream));
      } else {
        stream.flush(() => {
          if (stream.destroyed) {
            return;
          }
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
        return;
      }
      stream.flush(() => {
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream);
      });
    } else {
      destroy(stream, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === void 0) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream);
        stream.flush(() => {
          stream[kImpl].ready = true;
          stream.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream.emit(msg.name, ...msg.args);
        } else {
          stream.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code) {
    const stream = this.stream.deref();
    if (stream === void 0) {
      return;
    }
    registry.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off("exit", onWorkerExit);
    destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
  }
  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message, transferList) => {
        this.worker.postMessage(message, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err2) {
          destroy(this, err2);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err2) {
          destroy(this, err2);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err2, res2) => {
        if (err2) {
          destroy(this, err2);
          process.nextTick(cb, err2);
          return;
        }
        if (res2 === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  function error(stream, err2) {
    setImmediate(() => {
      stream.emit("error", err2);
    });
  }
  function destroy(stream, err2) {
    if (stream[kImpl].destroyed) {
      return;
    }
    stream[kImpl].destroyed = true;
    if (err2) {
      stream[kImpl].errored = err2;
      error(stream, err2);
    }
    if (!stream.worker.exited) {
      stream.worker.terminate().catch(() => {
      }).then(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    } else {
      setImmediate(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    }
  }
  function write(stream, data, cb) {
    const current2 = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current2);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current2 + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
      return;
    }
    stream[kImpl].ended = true;
    try {
      stream.flushSync();
      let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream[kImpl].finished = true;
        stream.emit("finish");
      });
    } catch (err2) {
      destroy(stream, err2);
    }
  }
  function writeSync(stream) {
    const cb = () => {
      if (stream[kImpl].ending) {
        end(stream);
      } else if (stream[kImpl].needDrain) {
        process.nextTick(drain, stream);
      }
    };
    stream[kImpl].flushing = false;
    while (stream[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      } else {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      }
    }
  }
  function flushSync(stream) {
    if (stream[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  threadStream = ThreadStream;
  return threadStream;
}
var transport_1;
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return transport_1;
  hasRequiredTransport = 1;
  const { createRequire } = require$$0$2;
  const getCallers = requireCaller();
  const { join, isAbsolute, sep } = require$$2$2;
  const sleep = requireAtomicSleep();
  const onExit = requireOnExitLeakFree();
  const ThreadStream = requireThreadStream();
  function setupOnExit(stream) {
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on("close", function() {
      onExit.unregister(stream);
    });
  }
  function buildStream(filename, workerData, workerOpts, sync) {
    const stream = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream.on("ready", onReady);
    stream.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream);
      }
    }
    function onExit2() {
      if (stream.closed) {
        return;
      }
      stream.flushSync();
      sleep(100);
      stream.end();
    }
    return stream;
  }
  function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once("close", function() {
      stream.unref();
    });
  }
  function flush(stream) {
    stream.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline, targets, levels: levels2, dedupe, worker = {}, caller: caller2 = getCallers(), sync = false } = fullOptions;
    const options2 = {
      ...fullOptions.options
    };
    const callers = typeof caller2 === "string" ? [caller2] : caller2;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options2.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options2.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t) => {
          return {
            ...t,
            level: dest.level,
            // duplicate the pipeline `level` property defined in the upper level
            target: fixTarget(t.target)
          };
        });
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
      options2.pipelines = [pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels2) {
      options2.levels = levels2;
    }
    if (dedupe) {
      options2.dedupe = dedupe;
    }
    options2.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options2, worker, sync);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire(context).resolve(origin);
          break;
        } catch (err2) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  }
  transport_1 = transport;
  return transport_1;
}
var tools;
var hasRequiredTools;
function requireTools() {
  if (hasRequiredTools) return tools;
  hasRequiredTools = 1;
  const format = requireQuickFormatUnescaped();
  const { mapHttpRequest, mapHttpResponse } = requirePinoStdSerializers();
  const SonicBoom = requireSonicBoom();
  const onExit = requireOnExitLeakFree();
  const {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = requireSymbols();
  const { isMainThread } = require$$2$1;
  const transport = requireTransport();
  function noop2() {
  }
  function genLog(level, hook) {
    if (!hook) return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o, ...n) {
      if (typeof o === "object") {
        let msg = o;
        if (o !== null) {
          if (o.method && o.headers && o.socket) {
            o = mapHttpRequest(o);
          } else if (typeof o.setHeader === "function") {
            o = mapHttpResponse(o);
          }
        }
        let formatParams;
        if (msg === null && n.length === 0) {
          formatParams = [null];
        } else {
          msg = n.shift();
          formatParams = n;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o === void 0 ? n.shift() : o;
        if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
      }
    }
  }
  function asString(str) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l = str.length;
    if (l > 100) {
      return JSON.stringify(str);
    }
    for (var i = 0; i < l && point >= 32; i++) {
      point = str.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str;
    } else {
      result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
  }
  function asJson(obj, msg, num, time2) {
    const stringify2 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time2;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
        }
        if (value === void 0) continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== void 0) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        // this case explicitly falls through to the next one
        case "boolean":
          if (stringifier) value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify2)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify2 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
      if (valid === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
        if (value === void 0) continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  }
  function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
  }
  function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on("error", filterBrokenPipe);
    if (!opts.sync && isMainThread) {
      onExit.register(stream, autoEnd);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    return stream;
    function filterBrokenPipe(err2) {
      if (err2.code === "EPIPE") {
        stream.write = noop2;
        stream.end = noop2;
        stream.flushSync = noop2;
        stream.destroy = noop2;
        return;
      }
      stream.removeListener("error", filterBrokenPipe);
      stream.emit("error", err2);
    }
  }
  function autoEnd(stream, eventName) {
    if (stream.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream.flush();
      stream.on("drain", function() {
        stream.end();
      });
    } else {
      stream.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller2, opts = {}, stream) {
      if (typeof opts === "string") {
        stream = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream = buildSafeSonicBoom({ dest: stream });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream = transport({ caller: caller2, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false) opts.level = "silent";
      if (!onChild) opts.onChild = noop2;
      if (!stream) {
        if (!hasBeenTampered(process.stdout)) {
          stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream = process.stdout;
        }
      }
      return { opts, stream };
    };
  }
  function stringify(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify2 = stringifySafeFn || this[stringifySafeSym];
        return stringify2(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log) {
    return {
      level,
      bindings,
      log
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === void 0) {
      return 1;
    }
    return destination;
  }
  tools = {
    noop: noop2,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
  };
  return tools;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  const SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  constants = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
  return constants;
}
var levels;
var hasRequiredLevels;
function requireLevels() {
  if (hasRequiredLevels) return levels;
  hasRequiredLevels = 1;
  const {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = requireSymbols();
  const { noop: noop2, genLog } = requireTools();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants();
  const levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream.flushSync === "function") {
          try {
            stream.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
    o[DEFAULT_LEVELS[k]] = k;
    return o;
  }, {});
  const initialLsCache = Object.keys(nums).reduce((o, k) => {
    o[k] = '{"level":' + Number(k);
    return o;
  }, {});
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache2 = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache2[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache2;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === void 0) throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === void 0) throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelComparison(values[key], levelVal) === false) {
        this[key] = noop2;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit(
      "level-change",
      level,
      levelVal,
      labels[preLevelVal],
      preLevelVal,
      this
    );
  }
  function getLevel(level) {
    const { levels: levels2, levelVal } = this;
    return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current2, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current2 <= expected;
    }
    return current2 >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
      o[customLevels[k]] = k;
      return o;
    }, {}) : null;
    const labels = Object.assign(
      Object.create(Object.prototype, { Infinity: { value: "silent" } }),
      useOnlyCustomLevels ? null : nums,
      customNums
    );
    const values = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    return { labels, values };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(
        Object.keys(customLevels || {}).map((key) => customLevels[key]),
        useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
        Infinity
      );
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(
      Object.create(Object.prototype, { silent: { value: Infinity } }),
      useOnlyCustomLevels ? null : DEFAULT_LEVELS,
      customLevels
    );
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels2, customLevels) {
    const { labels, values } = levels2;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  levels = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
  return levels;
}
var meta;
var hasRequiredMeta;
function requireMeta() {
  if (hasRequiredMeta) return meta;
  hasRequiredMeta = 1;
  meta = { version: "9.7.0" };
  return meta;
}
var proto;
var hasRequiredProto;
function requireProto() {
  if (hasRequiredProto) return proto;
  hasRequiredProto = 1;
  const { EventEmitter } = require$$0$3;
  const {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    parsedChindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = requireSymbols();
  const {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = requireLevels();
  const {
    asChindings,
    asJson,
    buildFormatters,
    stringify
  } = requireTools();
  const {
    version: version2
  } = requireMeta();
  const redaction = requireRedaction();
  const constructor = class Pino {
  };
  const prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version: version2,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n) {
      throw Error("levelVal is read-only");
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  proto = function() {
    return Object.create(prototype);
  };
  const resetChildingsFormatter = (bindings2) => bindings2;
  function child(bindings2, options2) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    options2 = options2 || {};
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options2.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = /* @__PURE__ */ Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0; i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options2.serializers) {
        instance[serializersSym][bk] = options2.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options2.serializers);
      for (var bi = 0; bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options2.serializers[bks];
      }
    } else instance[serializersSym] = serializers;
    if (options2.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log } = options2.formatters;
      instance[formattersSym] = buildFormatters(
        level || formatters.level,
        chindings || resetChildingsFormatter,
        log || formatters.log
      );
    } else {
      instance[formattersSym] = buildFormatters(
        formatters.level,
        resetChildingsFormatter,
        formatters.log
      );
    }
    if (options2.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options2.customLevels);
      instance.levels = mappings(options2.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options2.redact === "object" && options2.redact !== null || Array.isArray(options2.redact)) {
      instance.redact = options2.redact;
      const stringifiers = redaction(instance.redact, stringify);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options2.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options2.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    const childLevel = options2.level || this.level;
    instance[setLevelSym](childLevel);
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
    delete this[parsedChindingsSym];
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === void 0 || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === void 0) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
      stream.lastLevel = num;
      stream.lastObj = obj;
      stream.lastMsg = msg;
      stream.lastTime = t.slice(this[timeSliceIndexSym]);
      stream.lastLogger = this;
    }
    stream.write(streamWriteHook ? streamWriteHook(s) : s);
  }
  function noop2() {
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream = this[streamSym];
    if (typeof stream.flush === "function") {
      stream.flush(cb || noop2);
    } else if (cb) cb();
  }
  return proto;
}
var safeStableStringify = { exports: {} };
var hasRequiredSafeStableStringify;
function requireSafeStableStringify() {
  if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
  hasRequiredSafeStableStringify = 1;
  (function(module, exports) {
    const { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    const stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports.stringify = stringify;
    exports.configure = configure;
    module.exports = stringify;
    const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res2 = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res2 += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res2;
    }
    function getCircularValueOption(options2) {
      if (hasOwnProperty2.call(options2, "circularValue")) {
        const circularValue = options2.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options2) {
      let value;
      if (hasOwnProperty2.call(options2, "deterministic")) {
        value = options2.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options2, key) {
      let value;
      if (hasOwnProperty2.call(options2, key)) {
        value = options2[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options2, key) {
      let value;
      if (hasOwnProperty2.call(options2, key)) {
        value = options2[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options2) {
      if (hasOwnProperty2.call(options2, "strict")) {
        const value = options2.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options2) {
      options2 = { ...options2 };
      const fail2 = getStrictOption(options2);
      if (fail2) {
        if (options2.bigint === void 0) {
          options2.bigint = false;
        }
        if (!("circularValue" in options2)) {
          options2.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options2);
      const bigint = getBooleanOption(options2, "bigint");
      const deterministic = getDeterministicOption(options2);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options2, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options2, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys2 = sort(keys2, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res2 = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res2 += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res2 += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res3 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res3 += tmp2 !== void 0 ? tmp2 : "null";
                res3 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res3 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res3 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res3 += `
${originalIndentation}`;
              stack.pop();
              return `[${res3}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res2 = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, join, maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys2 = sort(keys2, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res2 = `
${indentation}${res2}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res2 = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res2}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res2 += stringifyTypedArray(value, ",", maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys2 = sort(keys2, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res2 += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res2 += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res2}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail2 ? fail2(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail2 ? fail2(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  })(safeStableStringify, safeStableStringify.exports);
  return safeStableStringify.exports;
}
var multistream_1;
var hasRequiredMultistream;
function requireMultistream() {
  if (hasRequiredMultistream) return multistream_1;
  hasRequiredMultistream = 1;
  const metadata = Symbol.for("pino.metadata");
  const { DEFAULT_LEVELS } = requireConstants();
  const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  function multistream(streamsArray, opts) {
    let counter = 0;
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res2 = {
      write,
      add,
      emit: emit2,
      flushSync,
      end,
      minLevel: 0,
      streams: [],
      clone: clone2,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res2);
    } else {
      add.call(res2, streamsArray);
    }
    streamsArray = null;
    return res2;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream;
      for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream = dest.stream;
          if (stream[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream.lastLevel = level;
            stream.lastTime = lastTime;
            stream.lastMsg = lastMsg;
            stream.lastObj = lastObj;
            stream.lastLogger = lastLogger;
          }
          stream.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit2(...args) {
      for (const { stream } of this.streams) {
        if (typeof stream.emit === "function") {
          stream.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res2;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: void 0,
        id: counter++
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res2;
    }
    function end() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
        stream.end();
      }
    }
    function clone2(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0; i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        minLevel: level,
        streams,
        clone: clone2,
        emit: emit2,
        flushSync,
        [metadata]: true
      };
    }
  }
  function compareByLevel(a, b) {
    return a.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  }
  function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  }
  multistream_1 = multistream;
  return multistream_1;
}
var hasRequiredPino;
function requirePino() {
  if (hasRequiredPino) return pino.exports;
  hasRequiredPino = 1;
  const os = require$$0$4;
  const stdSerializers = requirePinoStdSerializers();
  const caller2 = requireCaller();
  const redaction = requireRedaction();
  const time2 = requireTime();
  const proto2 = requireProto();
  const symbols2 = requireSymbols();
  const { configure } = requireSafeStableStringify();
  const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = requireLevels();
  const { DEFAULT_LEVELS, SORTING_ORDER } = requireConstants();
  const {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify,
    normalizeDestFileDescriptor,
    noop: noop2
  } = requireTools();
  const { version: version2 } = requireMeta();
  const {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols2;
  const { epochTime, nullTime } = time2;
  const { pid } = process;
  const hostname = os.hostname();
  const defaultErrorSerializer = stdSerializers.err;
  const defaultOptions = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number) {
        return { level: number };
      }
    }),
    hooks: {
      logMethod: void 0,
      streamWrite: void 0
    },
    timestamp: epochTime,
    name: void 0,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  const normalize = createArgsNormalizer(defaultOptions);
  const serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
  function pino$1(...args) {
    const instance = {};
    const { opts, stream } = normalize(instance, caller2(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(
      formatters.level,
      formatters.bindings,
      formatters.log
    );
    const stringifyFn = stringify.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === void 0) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time3 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time3().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels2 = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === "function") {
      stream.emit("message", { code: "PINO_CONFIG", config: { levels: levels2, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels: levels2,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream,
      [timeSym]: time3,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      // protect against injection
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop2,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto2());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  pino.exports = pino$1;
  pino.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  pino.exports.transport = requireTransport();
  pino.exports.multistream = requireMultistream();
  pino.exports.levels = mappings();
  pino.exports.stdSerializers = serializers;
  pino.exports.stdTimeFunctions = Object.assign({}, time2);
  pino.exports.symbols = symbols2;
  pino.exports.version = version2;
  pino.exports.default = pino$1;
  pino.exports.pino = pino$1;
  return pino.exports;
}
var pinoExports = requirePino();
function buildLogger(options2) {
  return pinoExports.pino({
    name: "@coveo/headless",
    level: options2?.level || "warn",
    formatters: {
      log: options2?.logFormatter
    }
  });
}
function buildThunkExtraArguments(configuration2, logger) {
  const analyticsClientMiddleware = getAnalyticsClientMiddleware(configuration2);
  const validatePayload2 = validatePayloadAndThrow;
  const preprocessRequest = getPreprocessRequest(configuration2);
  return {
    analyticsClientMiddleware,
    validatePayload: validatePayload2,
    preprocessRequest,
    logger
  };
}
function getAnalyticsClientMiddleware(configuration2) {
  const { analytics } = configuration2;
  const NoopAnalyticsMiddleware = (_, p) => p;
  return analytics?.analyticsClientMiddleware || NoopAnalyticsMiddleware;
}
function getPreprocessRequest(configuration2) {
  return configuration2.preprocessRequest || NoopPreprocessRequest;
}
const possiblyWarnOnMismatch = (token, tokenProp, stateProp, defaultProp, payload, logger) => {
  const tokenValue = token[tokenProp];
  if (isNullOrUndefined(tokenValue)) {
    return;
  }
  if (isNullOrUndefined(payload)) {
    return;
  }
  if (payload === tokenValue) {
    return;
  }
  if (payload === defaultProp) {
    return;
  }
  logger.warn(`Mismatch on access token (JWT Token) ${tokenProp} and engine configuration.`);
  logger.warn(`To remove this warning, make sure that access token value [${tokenValue}] matches engine configuration value [${stateProp}]`);
};
const shouldReconcileValues = (tokenValue, stateValue) => {
  if (isNullOrUndefined(tokenValue)) {
    return false;
  }
  if (stateValue === tokenValue) {
    return false;
  }
  return true;
};
const decodeJSONWebToken = (token) => {
  const parsed = parseJWT(token);
  return parsed ? parsed : false;
};
const updateSearchHub = (jwt, state) => {
  if (shouldReconcileValues(jwt.searchHub, state.searchHub)) {
    state.searchHub = jwt.searchHub;
  }
  return state;
};
const handleMismatchOnSearchHub = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(jwt, "searchHub", state.searchHub, getSearchHubInitialState(), payload, logger);
  return updateSearchHub(jwt, state);
};
const updatePipeline = (jwt, state) => {
  if (shouldReconcileValues(jwt.pipeline, state.pipeline)) {
    state.pipeline = jwt.pipeline;
  }
  return state;
};
const handleMismatchOnPipeline = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(jwt, "pipeline", state.pipeline, getPipelineInitialState(), payload, logger);
  return updatePipeline(jwt, state);
};
const updateUserDisplayName = (jwt, state) => {
  if (shouldReconcileValues(jwt.userDisplayName, state.configuration.analytics.userDisplayName)) {
    state.configuration.analytics.userDisplayName = jwt.userDisplayName;
  }
  return state;
};
const handleMismatchOnUserDisplayName = (jwt, state, payload, logger) => {
  possiblyWarnOnMismatch(jwt, "userDisplayName", state.configuration.analytics.userDisplayName, getConfigurationInitialState$1().analytics.userDisplayName, payload, logger);
  return updateUserDisplayName(jwt, state);
};
const jwtReducer = (logger) => {
  return createReducer({}, (builder) => {
    builder.addCase(setSearchHub, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnSearchHub(jwt, state, action.payload, logger);
    }).addCase(setPipeline, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnPipeline(jwt, state, action.payload, logger);
    }).addCase(updateBasicConfiguration$1, (state, action) => {
      if (state.configuration.accessToken !== action.payload.accessToken) {
        return state;
      }
      const { accessToken } = action.payload;
      if (!accessToken) {
        return state;
      }
      const jwt = decodeJSONWebToken(accessToken);
      if (!jwt) {
        return state;
      }
      return [updatePipeline, updateSearchHub, updateUserDisplayName].reduce((resultingState, updateProp) => updateProp(jwt, resultingState), state);
    }).addCase(updateSearchConfiguration, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      const searchHubReconciled = handleMismatchOnSearchHub(jwt, state, action.payload.searchHub, logger);
      const pipelineReconciled = handleMismatchOnPipeline(jwt, searchHubReconciled, action.payload?.pipeline, logger);
      return pipelineReconciled;
    }).addCase(updateAnalyticsConfiguration$1, (state, action) => {
      const jwt = decodeJSONWebToken(state.configuration.accessToken);
      if (!jwt) {
        return state;
      }
      return handleMismatchOnUserDisplayName(jwt, state, action.payload.userDisplayName, logger);
    });
  });
};
const engineConfigurationDefinitions = {
  organizationId: requiredNonEmptyString,
  accessToken: requiredNonEmptyString,
  name: new StringValue({
    required: false,
    emptyAllowed: false
  }),
  analytics: new RecordValue({
    options: {
      required: false
    },
    values: {
      enabled: new BooleanValue({
        required: false
      }),
      originContext: new StringValue({
        required: false
      }),
      originLevel2: new StringValue({
        required: false
      }),
      originLevel3: new StringValue({
        required: false
      }),
      analyticsMode: new StringValue({
        constrainTo: ["legacy", "next"],
        required: false,
        default: "next"
      }),
      proxyBaseUrl: new StringValue({
        required: false,
        url: true
      }),
      trackingId: new StringValue({
        required: false,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  environment: new StringValue({
    required: false,
    default: "prod",
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  })
};
function getSampleEngineConfiguration() {
  return {
    organizationId: "searchuisamples",
    // deepcode ignore HardcodedNonCryptoSecret: Public key freely available for our documentation
    accessToken: "xx564559b1-0045-48e1-953c-3addd1ee4457"
  };
}
const searchEngineConfigurationSchema = new Schema({
  ...engineConfigurationDefinitions,
  search: new RecordValue({
    options: {
      required: false
    },
    values: {
      pipeline: new StringValue({ required: false, emptyAllowed: true }),
      searchHub: nonEmptyString,
      locale: nonEmptyString,
      timezone: nonEmptyString,
      authenticationProviders: new ArrayValue({
        required: false,
        each: requiredNonEmptyString
      }),
      proxyBaseUrl: new StringValue({ required: false, url: true })
    }
  })
});
function getSampleSearchEngineConfiguration() {
  return {
    ...getSampleEngineConfiguration(),
    search: {
      searchHub: "default"
    }
  };
}
const searchEngineReducers = { debug: debugReducer, pipeline: pipelineReducer, searchHub: searchHubReducer, search: searchReducer };
function getUpdateSearchConfigurationPayload(configuration2) {
  const { search, organizationId, environment } = configuration2;
  const apiBaseUrl = search?.proxyBaseUrl ? search.proxyBaseUrl : getSearchApiBaseUrl(organizationId, environment);
  const payloadWithURL = {
    ...search,
    apiBaseUrl
  };
  return payloadWithURL;
}
function buildSearchEngine(options2) {
  const logger = buildLogger(options2.loggerOptions);
  const { configuration: configuration2 } = options2;
  validateConfiguration$2(configuration2, logger);
  const searchAPIClient = createSearchAPIClient$1(configuration2, logger);
  const generatedAnswerClient = createGeneratedAnswerAPIClient(logger);
  const thunkArguments = {
    ...buildThunkExtraArguments(configuration2, logger),
    apiClient: searchAPIClient,
    streamingClient: generatedAnswerClient
  };
  const augmentedOptions = {
    ...options2,
    reducers: searchEngineReducers,
    crossReducer: jwtReducer(logger)
  };
  const engine = buildEngine(augmentedOptions, thunkArguments);
  const search = getUpdateSearchConfigurationPayload(configuration2);
  if (search) {
    engine.dispatch(updateSearchConfiguration(search));
  }
  return {
    ...engine,
    get state() {
      return engine.state;
    },
    executeFirstSearch(analyticsEvent = logInterfaceLoad()) {
      if (firstSearchExecutedSelector(engine.state)) {
        return;
      }
      const action = executeSearch$1({
        legacy: analyticsEvent,
        next: interfaceLoad()
      });
      engine.dispatch(action);
    },
    executeFirstSearchAfterStandaloneSearchBoxRedirect(analytics) {
      const { cause, metadata } = analytics;
      if (firstSearchExecutedSelector(engine.state)) {
        return;
      }
      const isOmniboxFromLink = metadata && cause === "omniboxFromLink";
      const action = executeSearch$1({
        legacy: isOmniboxFromLink ? logOmniboxFromLink(metadata) : logSearchFromLink(),
        next: isOmniboxFromLink ? omniboxFromLink() : searchFromLink()
      });
      engine.dispatch(action);
    }
  };
}
function validateConfiguration$2(configuration2, logger) {
  try {
    searchEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error(error, "Search engine configuration error");
    throw error;
  }
}
function createSearchAPIClient$1(configuration2, logger) {
  const { search } = configuration2;
  return new SearchAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest,
    postprocessSearchResponseMiddleware: search?.preprocessSearchResponseMiddleware || NoopPostprocessSearchResponseMiddleware,
    postprocessFacetSearchResponseMiddleware: search?.preprocessFacetSearchResponseMiddleware || NoopPostprocessFacetSearchResponseMiddleware,
    postprocessQuerySuggestResponseMiddleware: search?.preprocessQuerySuggestResponseMiddleware || NoopPostprocessQuerySuggestResponseMiddleware
  });
}
function createGeneratedAnswerAPIClient(logger) {
  return new GeneratedAnswerAPIClient({
    logger
  });
}
const facetValueDefinition = {
  value: requiredNonEmptyString,
  numberOfResults: new NumberValue({ min: 0 }),
  state: requiredNonEmptyString
};
const facetIdDefinition = requiredNonEmptyString;
const numberOfValuesDefinition = new NumberValue({
  min: NUMBER_OF_VALUE_MINIMUM,
  default: NUMBER_OF_VALUE_DEFAULT,
  required: false
});
const desiredCountDefinition = new NumberValue({
  min: DESIRED_COUNT_MINIMUM,
  max: DESIRED_COUNT_MAXIMUM,
  default: DESIRED_COUNT_DEFAULT,
  required: false
});
const optionsSchema$9 = {
  desiredCount: desiredCountDefinition,
  numberOfValues: numberOfValuesDefinition
};
const setOptions = createAction("automaticFacet/setOptions", (payload) => validatePayload(payload, optionsSchema$9));
const deselectAllAutomaticFacetValues = createAction("automaticFacet/deselectAll", (payload) => validatePayload(payload, facetIdDefinition));
const fieldDefinition = requiredNonEmptyString;
const toggleSelectAutomaticFacetValue = createAction("automaticFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  field: fieldDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
}));
const categoryFacetValueDefinition = {
  state: new Value({ required: true }),
  numberOfResults: new NumberValue({ required: true, min: 0 }),
  value: new StringValue({ required: true, emptyAllowed: true }),
  path: new ArrayValue({ required: true, each: requiredNonEmptyString }),
  moreValuesAvailable: new BooleanValue({ required: false })
};
function validateCategoryFacetValue(payload) {
  payload.children.forEach((child) => {
    validateCategoryFacetValue(child);
  });
  validatePayloadAndThrow({
    state: payload.state,
    numberOfResults: payload.numberOfResults,
    value: payload.value,
    path: payload.path,
    moreValuesAvailable: payload.moreValuesAvailable
  }, categoryFacetValueDefinition);
}
const categoryFacetPayloadDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  delimitingCharacter: new StringValue({ required: false, emptyAllowed: true }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  basePath: new ArrayValue({ required: false, each: requiredNonEmptyString }),
  filterByBasePath: new BooleanValue({ required: false })
};
const registerCategoryFacet = createAction("categoryFacet/register", (payload) => validatePayload(payload, categoryFacetPayloadDefinition));
const toggleSelectCategoryFacetValue$1 = createAction("categoryFacet/toggleSelectValue", (payload) => {
  try {
    validatePayloadAndThrow(payload.facetId, requiredNonEmptyString);
    validateCategoryFacetValue(payload.selection);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const deselectAllCategoryFacetValues = createAction("categoryFacet/deselectAll", (payload) => validatePayload(payload, categoryFacetPayloadDefinition.facetId));
const updateCategoryFacetNumberOfValues$1 = createAction("categoryFacet/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: categoryFacetPayloadDefinition.facetId,
  numberOfValues: categoryFacetPayloadDefinition.numberOfValues
}));
const updateCategoryFacetSortCriterion = createAction("categoryFacet/updateSortCriterion", (payload) => validatePayload(payload, {
  facetId: categoryFacetPayloadDefinition.facetId,
  criterion: new Value()
}));
const updateCategoryFacetBasePath = createAction("categoryFacet/updateBasePath", (payload) => validatePayload(payload, {
  facetId: categoryFacetPayloadDefinition.facetId,
  basePath: new ArrayValue({ each: requiredNonEmptyString })
}));
const categoryFacetBreadcrumbPayloadDefinition = {
  categoryFacetId: facetIdDefinition,
  categoryFacetPath: new ArrayValue({
    required: true,
    each: requiredNonEmptyString
  })
};
const getCategoryFacetMetadata = (state, { categoryFacetId, categoryFacetPath }) => {
  const facet = state.categoryFacetSet[categoryFacetId];
  const categoryFacetField = facet?.request.field;
  const categoryFacetTitle = `${categoryFacetField}_${categoryFacetId}`;
  return {
    categoryFacetId,
    categoryFacetPath,
    categoryFacetField,
    categoryFacetTitle
  };
};
const logCategoryFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/categoryFacet/breadcrumb", (client, state) => {
  validatePayload(payload, categoryFacetBreadcrumbPayloadDefinition);
  return client.makeBreadcrumbFacet(getCategoryFacetMetadata(state, payload));
});
const categoryBreadcrumbFacet = () => ({
  actionCause: SearchPageEvents.breadcrumbFacet
});
const updateFacetOptions = createAction("facetOptions/update", (payload = { freezeFacetOrder: true }) => validatePayload(payload, {
  freezeFacetOrder: new BooleanValue({ required: false })
}));
const enableFacet = createAction("facetOptions/facet/enable", (payload) => validatePayload(payload, facetIdDefinition));
const disableFacet = createAction("facetOptions/facet/disable", (payload) => validatePayload(payload, facetIdDefinition));
const facetSearchOptionsDefinition = {
  facetId: facetIdDefinition,
  captions: new RecordValue({ options: { required: false } }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  query: new StringValue({ required: false, emptyAllowed: true })
};
const categoryFacetSearchResultDefinition = {
  path: new ArrayValue({
    required: true,
    each: requiredNonEmptyString
  }),
  displayValue: requiredEmptyAllowedString,
  rawValue: requiredEmptyAllowedString,
  count: new NumberValue({ required: true, min: 0 })
};
const selectCategoryFacetSearchResult = createAction("categoryFacet/selectSearchResult", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  value: new RecordValue({ values: categoryFacetSearchResultDefinition })
}));
const registerCategoryFacetSearch = createAction("categoryFacetSearch/register", (payload) => validatePayload(payload, facetSearchOptionsDefinition));
function handleFacetSortCriterionUpdate(state, payload) {
  const { facetId: facetId2, criterion } = payload;
  const facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.sortCriteria = criterion;
}
function handleFacetDeselectAll(facetRequest) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetRequest.currentValues.map((value) => ({
    ...value,
    ...{ previousState: value.state !== "idle" ? value.state : void 0 },
    state: "idle"
  }));
  facetRequest.preventAutoSelect = true;
}
function handleFacetUpdateNumberOfValues(facetRequest, numberOfValues2) {
  if (!facetRequest) {
    return;
  }
  facetRequest.numberOfValues = numberOfValues2;
}
function handleCategoryFacetDeselectAll(state, facetId2) {
  const slice = state[facetId2];
  if (!slice) {
    return;
  }
  slice.request.numberOfValues = slice.initialNumberOfValues;
  slice.request.currentValues = [];
  slice.request.preventAutoSelect = true;
}
function selectPath$1(request, path, initialNumberOfValues) {
  request.currentValues = buildCurrentValuesFromPath$1(path, initialNumberOfValues);
  request.numberOfValues = path.length ? 1 : initialNumberOfValues;
  request.preventAutoSelect = true;
}
function buildCurrentValuesFromPath$1(path, retrieveCount) {
  if (!path.length) {
    return [];
  }
  const root = buildCategoryFacetValueRequest$2(path[0], retrieveCount);
  let curr = root;
  for (const segment of path.splice(1)) {
    const next = buildCategoryFacetValueRequest$2(segment, retrieveCount);
    curr.children.push(next);
    curr = next;
  }
  curr.state = "selected";
  curr.retrieveChildren = true;
  return [root];
}
function buildCategoryFacetValueRequest$2(value, retrieveCount) {
  return {
    value,
    retrieveCount,
    children: [],
    state: "idle",
    retrieveChildren: false
  };
}
const categoryFacetSetReducer = createReducer(getCategoryFacetSetInitialState(), (builder) => {
  builder.addCase(registerCategoryFacet, (state, action) => {
    const options2 = action.payload;
    const { facetId: facetId2 } = options2;
    if (facetId2 in state) {
      return;
    }
    const request = buildCategoryFacetRequest(options2);
    const initialNumberOfValues = request.numberOfValues;
    state[facetId2] = { request, initialNumberOfValues };
  }).addCase(change.fulfilled, (state, action) => action.payload?.categoryFacetSet ?? state).addCase(restoreSearchParameters$1, (state, action) => {
    const cf = action.payload.cf || {};
    Object.keys(state).forEach((id2) => {
      const request = state[id2].request;
      const path = cf[id2] || [];
      if (path.length || request.currentValues.length) {
        selectPath$1(request, path, state[id2].initialNumberOfValues);
      }
    });
  }).addCase(updateCategoryFacetSortCriterion, (state, action) => {
    const { facetId: facetId2, criterion } = action.payload;
    const request = state[facetId2]?.request;
    if (!request) {
      return;
    }
    request.sortCriteria = criterion;
  }).addCase(updateCategoryFacetBasePath, (state, action) => {
    const { facetId: facetId2, basePath: basePath2 } = action.payload;
    const request = state[facetId2]?.request;
    if (!request) {
      return;
    }
    request.basePath = [...basePath2];
  }).addCase(toggleSelectCategoryFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection, retrieveCount } = action.payload;
    const request = state[facetId2]?.request;
    if (!request) {
      return;
    }
    const { path } = selection;
    const pathToSelection = path.slice(0, path.length - 1);
    const children = ensurePathAndReturnChildren$1(request, pathToSelection, retrieveCount);
    if (children.length) {
      const lastSelectedParent = children[0];
      lastSelectedParent.retrieveChildren = true;
      lastSelectedParent.state = "selected";
      lastSelectedParent.previousState = "idle";
      lastSelectedParent.children = [];
      return;
    }
    const newParent = buildCategoryFacetValueRequest$1(selection.value, retrieveCount);
    newParent.state = "selected";
    newParent.previousState = "idle";
    children.push(newParent);
    request.numberOfValues = 1;
  }).addCase(deselectAllCategoryFacetValues, (state, action) => {
    const facetId2 = action.payload;
    handleCategoryFacetDeselectAll(state, facetId2);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.keys(state).forEach((facetId2) => handleCategoryFacetDeselectAll(state, facetId2));
  }).addCase(updateFacetAutoSelection, (state, action) => Object.keys(state).forEach((facetId2) => {
    state[facetId2].request.preventAutoSelect = !action.payload.allow;
  })).addCase(updateCategoryFacetNumberOfValues$1, (state, action) => {
    const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
    const request = state[facetId2]?.request;
    if (!request) {
      return;
    }
    if (!request.currentValues.length) {
      return handleFacetUpdateNumberOfValues(request, numberOfValues2);
    }
    handleCategoryFacetNestedNumberOfValuesUpdate(state, action.payload);
  }).addCase(selectCategoryFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const facet = state[facetId2];
    if (!facet) {
      return;
    }
    const path = [...value.path, value.rawValue];
    selectPath$1(facet.request, path, facet.initialNumberOfValues);
  }).addCase(fetchFacetValues.fulfilled, (state, action) => {
    handleCategoryFacetResponseUpdate(state, action.payload.response.facets);
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    handleCategoryFacetResponseUpdate(state, action.payload.response.facets);
  }).addCase(disableFacet, (state, action) => {
    handleCategoryFacetDeselectAll(state, action.payload);
  });
});
const defaultCategoryFacetOptions = {
  delimitingCharacter: ";",
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 5,
  sortCriteria: "occurrences",
  basePath: [],
  filterByBasePath: true,
  resultsMustMatch: "atLeastOneValue"
};
function ensurePathAndReturnChildren$1(request, path, retrieveCount) {
  let children = request.currentValues;
  for (const segment of path) {
    let parent = children[0];
    const missingParent = !parent;
    if (missingParent || segment !== parent.value) {
      parent = buildCategoryFacetValueRequest$1(segment, retrieveCount);
      children.length = 0;
      children.push(parent);
    }
    parent.retrieveChildren = false;
    parent.previousState = void 0;
    parent.state = "idle";
    children = parent.children;
  }
  return children;
}
function buildCategoryFacetRequest(config) {
  return {
    ...defaultCategoryFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "hierarchical",
    ...config
  };
}
function buildCategoryFacetValueRequest$1(value, retrieveCount) {
  return {
    value,
    state: "idle",
    children: [],
    retrieveChildren: true,
    retrieveCount
  };
}
function handleCategoryFacetResponseUpdate(state, facets) {
  facets.forEach((response) => {
    if (!isCategoryFacetResponse(state, response)) {
      return;
    }
    const id2 = response.facetId;
    const request = state[id2]?.request;
    if (!request) {
      return;
    }
    const requestWasInvalid = isRequestInvalid(request, response);
    request.currentValues = requestWasInvalid ? [] : request.currentValues;
    request.preventAutoSelect = false;
  });
}
function handleCategoryFacetNestedNumberOfValuesUpdate(state, payload) {
  const { facetId: facetId2, numberOfValues: numberOfValues2 } = payload;
  let selectedValue = state[facetId2]?.request.currentValues[0];
  if (!selectedValue) {
    return;
  }
  while (selectedValue.children.length && selectedValue?.state !== "selected") {
    selectedValue = selectedValue.children[0];
  }
  selectedValue.retrieveCount = numberOfValues2;
}
function isCategoryFacetResponse(state, response) {
  const id2 = response.facetId;
  return id2 in state;
}
function isRequestInvalid(request, response) {
  const requestParents = findActiveValueAncestry(request.currentValues);
  const responseParents = findActiveValueAncestry(response.values);
  return requestParents.length !== responseParents.length;
}
const facetId = new StringValue({
  regex: /^[a-zA-Z0-9-_]+$/
});
const field = new StringValue({ required: true });
const basePath = new ArrayValue({
  each: new StringValue()
});
const delimitingCharacter = new StringValue();
const filterByBasePath = new BooleanValue();
const filterFacetCount = new BooleanValue();
const injectionDepth = new NumberValue({ min: 0 });
const numberOfValues = new NumberValue({ min: 1 });
const generateAutomaticRanges = new BooleanValue({
  required: true
});
const captions = new RecordValue();
const query = new StringValue();
const facetSearchOptionDefinitions = {
  captions,
  numberOfValues,
  query
};
const facetSearch = new RecordValue({
  values: facetSearchOptionDefinitions
});
const allowedValues = new RecordValue({
  options: { required: false },
  values: {
    type: new StringValue({
      constrainTo: ["simple"],
      emptyAllowed: false,
      required: true
    }),
    values: new ArrayValue({
      required: true,
      max: 25,
      each: new StringValue({ emptyAllowed: false, required: true })
    })
  }
});
const hasBreadcrumbs = new BooleanValue();
const customSort = new ArrayValue({
  min: 1,
  max: 25,
  required: false,
  each: new StringValue({ emptyAllowed: false, required: true })
});
const facetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: new StringValue({ required: true, emptyAllowed: true }),
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  resultsMustMatch: new Value({ required: false }),
  allowedValues,
  customSort
};
const registerFacet = createAction("facet/register", (payload) => validatePayload(payload, facetRegistrationOptionsDefinition));
const toggleSelectFacetValue$1 = createAction("facet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
}));
const toggleExcludeFacetValue$1 = createAction("facet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
}));
const deselectAllFacetValues = createAction("facet/deselectAll", (payload) => validatePayload(payload, facetIdDefinition));
const updateFacetSortCriterion = createAction("facet/updateSortCriterion", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  criterion: new Value({ required: true })
}));
const updateFacetNumberOfValues = createAction("facet/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  numberOfValues: new NumberValue({ required: true, min: 1 })
}));
const updateFacetIsFieldExpanded = createAction("facet/updateIsFieldExpanded", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  isFieldExpanded: new BooleanValue({ required: true })
}));
const updateFreezeCurrentValues = createAction("facet/updateFreezeCurrentValues", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  freezeCurrentValues: new BooleanValue({ required: true })
}));
const logFacetShowMore = (facetId2) => makeAnalyticsAction("analytics/facet/showMore", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const metadata = buildFacetBaseMetadata(facetId2, getStateNeededForFacetMetadata(state));
  return client.makeFacetShowMore(metadata);
});
const logFacetShowLess = (facetId2) => makeAnalyticsAction("analytics/facet/showLess", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const metadata = buildFacetBaseMetadata(facetId2, getStateNeededForFacetMetadata(state));
  return client.makeFacetShowLess(metadata);
});
const logFacetUpdateSort = (payload) => makeAnalyticsAction("analytics/facet/sortChange", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    criterion: new Value({
      required: true
    })
  });
  const { facetId: facetId2, criterion } = payload;
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const base = buildFacetBaseMetadata(facetId2, stateForAnalytics);
  const metadata = { ...base, criteria: criterion };
  return client.makeFacetUpdateSort(metadata);
});
const logFacetClearAll = (facetId2) => makeAnalyticsAction("analytics/facet/reset", (client, state) => {
  validatePayload(facetId2, facetIdDefinition);
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetBaseMetadata(facetId2, stateForAnalytics);
  return client.makeFacetClearAll(metadata);
});
const logFacetSelect = (payload) => makeAnalyticsAction("analytics/facet/select", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetSelect(metadata);
});
const logFacetExclude = (payload) => makeAnalyticsAction("analytics/facet/exclude", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetExclude(metadata);
});
const logFacetDeselect = (payload) => makeAnalyticsAction("analytics/facet/deselect", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetDeselect(metadata);
});
const logFacetUnexclude = (payload) => makeAnalyticsAction("analytics/facet/unexclude", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const stateForAnalytics = getStateNeededForFacetMetadata(state);
  const metadata = buildFacetSelectionChangeMetadata(payload, stateForAnalytics);
  return client.makeFacetUnexclude(metadata);
});
const logFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/facet/breadcrumb", (client, state) => {
  validatePayload(payload, {
    facetId: facetIdDefinition,
    facetValue: requiredNonEmptyString
  });
  const metadata = buildFacetSelectionChangeMetadata(payload, getStateNeededForFacetMetadata(state));
  return client.makeBreadcrumbFacet(metadata);
});
const facetClearAll = () => {
  return {
    actionCause: SearchPageEvents.facetClearAll
  };
};
const facetSelect = () => ({
  actionCause: SearchPageEvents.facetSelect
});
const facetExclude = () => ({
  actionCause: SearchPageEvents.facetExclude
});
const facetDeselect = () => ({
  actionCause: SearchPageEvents.facetDeselect
});
const facetUnexclude = () => ({
  actionCause: SearchPageEvents.facetUnexclude
});
const breadcrumbFacet = () => ({
  actionCause: SearchPageEvents.breadcrumbFacet
});
const selectFacetSearchResultPayloadDefinition = {
  facetId: facetIdDefinition,
  value: new RecordValue({
    values: {
      displayValue: requiredEmptyAllowedString,
      rawValue: requiredEmptyAllowedString,
      count: new NumberValue({ required: true, min: 0 })
    }
  })
};
const registerFacetSearch = createAction("facetSearch/register", (payload) => validatePayload(payload, facetSearchOptionsDefinition));
const updateFacetSearch = createAction("facetSearch/update", (payload) => validatePayload(payload, facetSearchOptionsDefinition));
const selectFacetSearchResult = createAction("facetSearch/toggleSelectValue", (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition));
const excludeFacetSearchResult = createAction("facetSearch/toggleExcludeValue", (payload) => validatePayload(payload, selectFacetSearchResultPayloadDefinition));
const facetSetReducer = createReducer(getFacetSetInitialState(), (builder) => {
  builder.addCase(registerFacet, (state, action) => {
    const { facetId: facetId2 } = action.payload;
    if (facetId2 in state) {
      return;
    }
    state[facetId2] = getFacetSetSliceInitialState(buildFacetRequest(action.payload));
  }).addCase(change.fulfilled, (_, action) => {
    if (!action.payload) {
      return;
    }
    if (Object.keys(action.payload.facetSet).length === 0) {
      return;
    }
    return action.payload.facetSet;
  }).addCase(restoreSearchParameters$1, (state, action) => {
    const f2 = action.payload.f || {};
    const fExcluded = action.payload.fExcluded || {};
    const facetIds = Object.keys(state);
    facetIds.forEach((id2) => {
      const { request } = state[id2];
      const selectedValues = f2[id2] || [];
      const excludedValues = fExcluded[id2] || [];
      const activeValueCount = selectedValues.length + excludedValues.length;
      const idleValues = request.currentValues.filter((facetValue) => !selectedValues.includes(facetValue.value) && !excludedValues.includes(facetValue.value));
      request.currentValues = [
        ...selectedValues.map(buildSelectedFacetValueRequest$1),
        ...excludedValues.map(buildExcludedFacetValueRequest),
        ...idleValues.map(restoreFacetValueToIdleState)
      ];
      request.preventAutoSelect = activeValueCount > 0;
      request.numberOfValues = Math.max(activeValueCount, request.numberOfValues);
    });
  }).addCase(toggleSelectFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.currentValues.find((req2) => req2.value === selection.value);
    if (!existingValue) {
      insertNewValue$1(facetRequest, selection);
      return;
    }
    const isSelected = existingValue.state === "selected";
    existingValue.previousState = existingValue.state;
    existingValue.state = isSelected ? "idle" : "selected";
    facetRequest.freezeCurrentValues = true;
  }).addCase(toggleExcludeFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.currentValues.find((req2) => req2.value === selection.value);
    if (!existingValue) {
      insertNewValue$1(facetRequest, selection);
      return;
    }
    const isExcluded = existingValue.state === "excluded";
    existingValue.previousState = existingValue.state;
    existingValue.state = isExcluded ? "idle" : "excluded";
    facetRequest.freezeCurrentValues = true;
  }).addCase(updateFreezeCurrentValues, (state, action) => {
    const { facetId: facetId2, freezeCurrentValues } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.freezeCurrentValues = freezeCurrentValues;
  }).addCase(deselectAllFacetValues, (state, action) => {
    handleFacetDeselectAll(state[action.payload]?.request);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.values(state).filter((slice) => slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
  }).addCase(deselectAllNonBreadcrumbs, (state) => {
    Object.values(state).filter((slice) => !slice.hasBreadcrumbs).forEach(({ request }) => handleFacetDeselectAll(request));
  }).addCase(updateFacetAutoSelection, (state, action) => Object.values(state).forEach((slice) => {
    slice.request.preventAutoSelect = !action.payload.allow;
  })).addCase(updateFacetSortCriterion, (state, action) => {
    handleFacetSortCriterionUpdate(state, action.payload);
  }).addCase(updateFacetNumberOfValues, (state, action) => {
    const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
    handleFacetUpdateNumberOfValues(state[facetId2]?.request, numberOfValues2);
  }).addCase(updateFacetIsFieldExpanded, (state, action) => {
    const { facetId: facetId2, isFieldExpanded } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.isFieldExpanded = isFieldExpanded;
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    facets.forEach((facetResponse) => mutateStateFromFacetResponse(state[facetResponse.facetId]?.request, facetResponse));
  }).addCase(fetchFacetValues.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    facets.forEach((facetResponse) => mutateStateFromFacetResponse(state[facetResponse.facetId]?.request, facetResponse));
  }).addCase(selectFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    const { rawValue } = value;
    const { currentValues } = facetRequest;
    const matchingValue = currentValues.find((v) => v.value === rawValue);
    if (matchingValue) {
      matchingValue.state = "selected";
      return;
    }
    const searchResultValue = buildSelectedFacetValueRequest$1(rawValue);
    insertNewValue$1(facetRequest, searchResultValue);
    facetRequest.freezeCurrentValues = true;
    facetRequest.preventAutoSelect = true;
  }).addCase(excludeFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    const { rawValue } = value;
    const { currentValues } = facetRequest;
    const matchingValue = currentValues.find((v) => v.value === rawValue);
    if (matchingValue) {
      matchingValue.state = "excluded";
      return;
    }
    const searchResultValue = buildExcludedFacetValueRequest(rawValue);
    insertNewValue$1(facetRequest, searchResultValue);
    facetRequest.freezeCurrentValues = true;
    facetRequest.preventAutoSelect = true;
  }).addCase(disableFacet, (state, action) => {
    if (!(action.payload in state)) {
      return;
    }
    const { request } = state[action.payload];
    handleFacetDeselectAll(request);
  });
});
function insertNewValue$1(facetRequest, facetValue) {
  const { currentValues } = facetRequest;
  const firstIdleIndex = currentValues.findIndex((v) => v.state === "idle");
  const indexToInsertAt = firstIdleIndex === -1 ? currentValues.length : firstIdleIndex;
  facetRequest.currentValues.splice(indexToInsertAt, 0, facetValue);
  if (firstIdleIndex > -1) {
    facetRequest.currentValues.pop();
  }
  facetRequest.numberOfValues = facetRequest.currentValues.length;
}
function mutateStateFromFacetResponse(facetRequest, facetResponse) {
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues = facetResponse.values.map(convertFacetValueToRequest);
  facetRequest.freezeCurrentValues = false;
  facetRequest.preventAutoSelect = false;
}
const defaultFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "automatic",
  resultsMustMatch: "atLeastOneValue"
};
function buildFacetRequest(config) {
  return {
    ...defaultFacetOptions,
    type: "specific",
    currentValues: [],
    freezeCurrentValues: false,
    isFieldExpanded: false,
    preventAutoSelect: false,
    ...config
  };
}
function convertFacetValueToRequest(facetValue) {
  const { value, state } = facetValue;
  return { value, state };
}
function buildSelectedFacetValueRequest$1(value) {
  return { value, state: "selected" };
}
function buildExcludedFacetValueRequest(value) {
  return { value, state: "excluded" };
}
function restoreFacetValueToIdleState(facetValue) {
  return { ...facetValue, state: "idle" };
}
const logClearBreadcrumbs = () => makeAnalyticsAction("analytics/facet/deselectAllBreadcrumbs", (client) => {
  return client.makeBreadcrumbResetAll();
});
function buildDateRange(config) {
  const start = buildDate(config.start, config);
  const end = buildDate(config.end, config);
  const endInclusive = config.endInclusive ?? false;
  const state = config.state ?? "idle";
  return {
    start,
    end,
    endInclusive,
    state
  };
}
function buildDate(rawDate, options2) {
  const { dateFormat } = options2;
  if (isRelativeDate(rawDate)) {
    validateRelativeDate(rawDate);
    return serializeRelativeDate(rawDate);
  }
  if (typeof rawDate === "string" && isRelativeDateFormat(rawDate)) {
    validateRelativeDate(rawDate);
    return rawDate;
  }
  validateAbsoluteDate(rawDate, dateFormat);
  return formatDateForSearchApi(parseDate$1(rawDate, dateFormat));
}
const updateRangeFacetSortCriterion = createAction("rangeFacet/updateSortCriterion", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  criterion: new Value({ required: true })
}));
const numericFacetValueDefinition$1 = {
  state: requiredNonEmptyString,
  start: new NumberValue({ required: true }),
  end: new NumberValue({ required: true }),
  endInclusive: new BooleanValue({ required: true }),
  numberOfResults: new NumberValue({ required: true, min: 0 })
};
const dateFacetValueDefinition = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new BooleanValue({ required: true }),
  state: requiredNonEmptyString,
  numberOfResults: new NumberValue({ required: true, min: 0 })
};
const rangeFacetSelectionPayloadDefinition = (selection) => ({
  facetId: facetIdDefinition,
  selection: typeof selection.start === "string" ? new RecordValue({ values: dateFacetValueDefinition }) : new RecordValue({ values: numericFacetValueDefinition$1 })
});
const dateRangeRequestDefinition$1 = {
  start: requiredNonEmptyString,
  end: requiredNonEmptyString,
  endInclusive: new BooleanValue({ required: true }),
  state: requiredNonEmptyString
};
const dateFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  currentValues: new ArrayValue({
    required: false,
    each: new RecordValue({ values: dateRangeRequestDefinition$1 })
  }),
  generateAutomaticRanges: new BooleanValue({ required: true }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  rangeAlgorithm: new Value({ required: false })
};
function getAbsoluteDate(date) {
  return isRelativeDateFormat(date) ? formatRelativeDateForSearchApi(date) : date;
}
function validateManualDateRanges(options2) {
  if (!options2.currentValues) {
    return;
  }
  options2.currentValues.forEach((value) => {
    const { start, end } = buildDateRange(value);
    if (parseDate$1(getAbsoluteDate(start)).isAfter(parseDate$1(getAbsoluteDate(end)))) {
      throw new Error(`The start value is greater than the end value for the date range ${value.start} to ${value.end}`);
    }
  });
}
const registerDateFacet = createAction("dateFacet/register", (payload) => {
  try {
    validatePayloadAndThrow(payload, dateFacetRegistrationOptionsDefinition);
    validateManualDateRanges(payload);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const toggleSelectDateFacetValue$1 = createAction("dateFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: dateFacetValueDefinition })
}));
const toggleExcludeDateFacetValue$1 = createAction("dateFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: dateFacetValueDefinition })
}));
const updateDateFacetValues$1 = createAction("dateFacet/updateFacetValues", (payload) => {
  try {
    validatePayloadAndThrow(payload, {
      facetId: facetIdDefinition,
      values: new ArrayValue({
        each: new RecordValue({ values: dateFacetValueDefinition })
      })
    });
    validateManualDateRanges({ currentValues: payload.values });
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const updateDateFacetSortCriterion = updateRangeFacetSortCriterion;
const deselectAllDateFacetValues = deselectAllFacetValues;
const getRangeFacetMetadata = (state, { facetId: facetId2, selection }) => {
  const facet = state.dateFacetSet[facetId2] || state.numericFacetSet[facetId2];
  const facetField = facet.request.field;
  const facetTitle = `${facetField}_${facetId2}`;
  return {
    facetId: facetId2,
    facetField,
    facetTitle,
    facetRangeEndInclusive: selection.endInclusive,
    facetRangeEnd: `${selection.end}`,
    facetRangeStart: `${selection.start}`
  };
};
const rangeBreadcrumbFacet = () => ({
  actionCause: SearchPageEvents.breadcrumbFacet
});
const logDateFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/dateFacet/breadcrumb", (client, state) => {
  validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection));
  const metadata = getRangeFacetMetadata(state, payload);
  return client.makeBreadcrumbFacet(metadata);
});
const dateBreadcrumbFacet = rangeBreadcrumbFacet;
function isDateFacetResponse(state, response) {
  return !!response && response.facetId in state.dateFacetSet;
}
const dateFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isDateFacetResponse(state, response)) {
    return response;
  }
  return void 0;
};
const dateFacetSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = dateFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state === "selected");
};
const dateFacetActiveValuesSelector = (state, facetId2) => {
  const facetResponse = dateFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state !== "idle");
};
const defaultRangeFacetOptions = {
  filterFacetCount: true,
  injectionDepth: 1e3,
  numberOfValues: 8,
  sortCriteria: "ascending",
  rangeAlgorithm: "even",
  resultsMustMatch: "atLeastOneValue"
};
function registerRangeFacet(state, slice) {
  const { request } = slice;
  const { facetId: facetId2 } = request;
  if (facetId2 in state) {
    return;
  }
  const numberOfValues2 = calculateNumberOfValues(request);
  request.numberOfValues = numberOfValues2;
  state[facetId2] = slice;
}
function updateRangeValues(state, facetId2, values) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  request.currentValues = values;
  request.numberOfValues = calculateNumberOfValues(request);
}
function toggleSelectRangeValue(state, facetId2, selection) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isSelected = value.state === "selected";
  value.previousState = value.state;
  value.state = isSelected ? "idle" : "selected";
  request.preventAutoSelect = true;
}
function toggleExcludeRangeValue(state, facetId2, selection) {
  const request = state[facetId2]?.request;
  if (!request) {
    return;
  }
  const value = findRange(request.currentValues, selection);
  if (!value) {
    return;
  }
  const isExcluded = value.state === "excluded";
  value.previousState = value.state;
  value.state = isExcluded ? "idle" : "excluded";
  request.preventAutoSelect = true;
}
function handleRangeFacetDeselectAll(state, facetId2) {
  const facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    return;
  }
  facetRequest.currentValues.forEach((request) => {
    if (request.state !== "idle") {
      request.previousState = request.state;
    }
    request.state = "idle";
  });
}
function handleRangeFacetSearchParameterRestoration(state, rangeFacets) {
  Object.entries(state).forEach(([facetId2, { request }]) => {
    const rangesToSelect = rangeFacets[facetId2] || [];
    request.currentValues.forEach((range) => {
      const found = !!findRange(rangesToSelect, range);
      if (found) {
        range.state = "selected";
      }
      return range;
    });
    const missingRanges = rangesToSelect.filter((range) => !findRange(request.currentValues, range));
    const currentValues = request.currentValues;
    currentValues.push(...missingRanges);
    request.numberOfValues = Math.max(request.numberOfValues, currentValues.length);
  });
}
function onRangeFacetRequestFulfilled(state, facets, convert) {
  facets.forEach((facetResponse) => {
    const id2 = facetResponse.facetId;
    const facetRequest = state[id2]?.request;
    if (!facetRequest) {
      return;
    }
    const values = convert(facetResponse.values);
    facetRequest.currentValues = values;
    facetRequest.preventAutoSelect = false;
  });
}
function findRange(values, value) {
  const { start, end } = value;
  return values.find((range) => range.start === start && range.end === end);
}
function findExactRangeValue(values, value) {
  const { start, end, endInclusive } = value;
  return values.find((range) => range.start === start && range.end === end && range.endInclusive === endInclusive);
}
function calculateNumberOfValues(request) {
  const { generateAutomaticRanges: generateAutomaticRanges2, currentValues, numberOfValues: numberOfValues2 } = request;
  return generateAutomaticRanges2 ? Math.max(numberOfValues2, currentValues.length) : currentValues.length;
}
const dateFacetSetReducer = createReducer(getDateFacetSetInitialState(), (builder) => {
  builder.addCase(registerDateFacet, (state, action) => {
    const { payload } = action;
    const request = buildDateFacetRequest(payload);
    registerRangeFacet(state, getDateFacetSetSliceInitialState(request));
  }).addCase(change.fulfilled, (state, action) => action.payload?.dateFacetSet ?? state).addCase(restoreSearchParameters$1, (state, action) => {
    const df = action.payload.df || {};
    handleRangeFacetSearchParameterRestoration(state, df);
  }).addCase(toggleSelectDateFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleSelectRangeValue(state, facetId2, selection);
  }).addCase(toggleExcludeDateFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleExcludeRangeValue(state, facetId2, selection);
  }).addCase(updateDateFacetValues$1, (state, action) => {
    const { facetId: facetId2, values } = action.payload;
    updateRangeValues(state, facetId2, values);
  }).addCase(deselectAllDateFacetValues, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.keys(state).forEach((facetId2) => {
      handleRangeFacetDeselectAll(state, facetId2);
    });
  }).addCase(updateDateFacetSortCriterion, (state, action) => {
    handleFacetSortCriterionUpdate(state, action.payload);
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    onRangeFacetRequestFulfilled(state, facets, convertToDateRangeRequests);
  }).addCase(disableFacet, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  });
});
function buildDateFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "dateRange",
    ...config
  };
}
function convertToDateRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}
const numericFacetRequestDefinition = {
  state: requiredNonEmptyString,
  start: new NumberValue({ required: true }),
  end: new NumberValue({ required: true }),
  endInclusive: new BooleanValue({ required: true })
};
const numericFacetRegistrationOptionsDefinition = {
  facetId: facetIdDefinition,
  field: requiredNonEmptyString,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  activeTab: new StringValue({ required: false }),
  currentValues: new ArrayValue({
    required: false,
    each: new RecordValue({ values: numericFacetRequestDefinition })
  }),
  generateAutomaticRanges: new BooleanValue({ required: true }),
  filterFacetCount: new BooleanValue({ required: false }),
  injectionDepth: new NumberValue({ required: false, min: 0 }),
  numberOfValues: new NumberValue({ required: false, min: 1 }),
  sortCriteria: new Value({ required: false }),
  rangeAlgorithm: new Value({ required: false })
};
function validateManualNumericRanges(options2) {
  if (!options2.currentValues) {
    return;
  }
  options2.currentValues.forEach(({ start, end }) => {
    if (start > end) {
      throw new Error(`The start value is greater than the end value for the numeric range ${start} to ${end}`);
    }
  });
}
const registerNumericFacet = createAction("numericFacet/register", (payload) => {
  try {
    validatePayload(payload, numericFacetRegistrationOptionsDefinition);
    validateManualNumericRanges(payload);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const toggleSelectNumericFacetValue$1 = createAction("numericFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: numericFacetValueDefinition$1 })
}));
const toggleExcludeNumericFacetValue$1 = createAction("numericFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: numericFacetValueDefinition$1 })
}));
const updateNumericFacetValues$1 = createAction("numericFacet/updateFacetValues", (payload) => {
  try {
    validatePayloadAndThrow(payload, {
      facetId: facetIdDefinition,
      values: new ArrayValue({
        each: new RecordValue({ values: numericFacetValueDefinition$1 })
      })
    });
    validateManualNumericRanges({ currentValues: payload.values });
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const updateNumericFacetSortCriterion = updateRangeFacetSortCriterion;
const deselectAllNumericFacetValues = deselectAllFacetValues;
const logNumericFacetBreadcrumb = (payload) => makeAnalyticsAction("analytics/numericFacet/breadcrumb", (client, state) => {
  validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection));
  const metadata = getRangeFacetMetadata(state, payload);
  return client.makeBreadcrumbFacet(metadata);
});
const numericBreadcrumbFacet = rangeBreadcrumbFacet;
function isNumericFacetResponse(state, response) {
  return !!response && response.facetId in state.numericFacetSet;
}
const numericFacetResponseSelector = (state, facetId2) => {
  const response = baseFacetResponseSelector(state, facetId2);
  if (isNumericFacetResponse(state, response)) {
    return response;
  }
  return void 0;
};
const numericFacetActiveValuesSelector = (state, facetId2) => {
  const facetResponse = numericFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state !== "idle");
};
const numericFacetSelectedValuesSelector = (state, facetId2) => {
  const facetResponse = numericFacetResponseSelector(state, facetId2) || {
    values: []
  };
  return facetResponse.values.filter((value) => value.state === "selected");
};
const numericFacetSetReducer = createReducer(getNumericFacetSetInitialState(), (builder) => {
  builder.addCase(registerNumericFacet, (state, action) => {
    const { payload } = action;
    const request = buildNumericFacetRequest(payload);
    registerRangeFacet(state, getNumericFacetSetSliceInitialState(request));
  }).addCase(change.fulfilled, (state, action) => action.payload?.numericFacetSet ?? state).addCase(restoreSearchParameters$1, (state, action) => {
    const nf = action.payload.nf || {};
    handleRangeFacetSearchParameterRestoration(state, nf);
  }).addCase(toggleSelectNumericFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleSelectRangeValue(state, facetId2, selection);
  }).addCase(toggleExcludeNumericFacetValue$1, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    toggleExcludeRangeValue(state, facetId2, selection);
  }).addCase(updateNumericFacetValues$1, (state, action) => {
    const { facetId: facetId2, values } = action.payload;
    updateRangeValues(state, facetId2, values);
  }).addCase(deselectAllNumericFacetValues, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.keys(state).forEach((facetId2) => {
      handleRangeFacetDeselectAll(state, facetId2);
    });
  }).addCase(updateNumericFacetSortCriterion, (state, action) => {
    handleFacetSortCriterionUpdate(state, action.payload);
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    const facets = action.payload.response.facets;
    onRangeFacetRequestFulfilled(state, facets, convertToNumericRangeRequests);
  }).addCase(disableFacet, (state, action) => {
    handleRangeFacetDeselectAll(state, action.payload);
  });
});
function buildNumericFacetRequest(config) {
  return {
    ...defaultRangeFacetOptions,
    currentValues: [],
    preventAutoSelect: false,
    type: "numericalRange",
    ...config
  };
}
function convertToNumericRangeRequests(values) {
  return values.map((value) => {
    const { numberOfResults: _numberOfResults, ...rest } = value;
    return rest;
  });
}
const staticFilterIdSchema = requiredNonEmptyString;
const staticFilterValueSchema = new RecordValue({
  options: { required: true },
  values: {
    caption: requiredEmptyAllowedString,
    expression: requiredEmptyAllowedString,
    state: new StringValue({
      constrainTo: ["idle", "selected", "excluded"]
    })
  }
});
const staticFilterValuesSchema = new ArrayValue({
  required: true,
  each: staticFilterValueSchema
});
const registerStaticFilter = createAction("staticFilter/register", (payload) => {
  const schema = {
    id: staticFilterIdSchema,
    values: staticFilterValuesSchema
  };
  return validatePayload(payload, schema);
});
const toggleSelectStaticFilterValue = createAction("staticFilter/toggleSelect", (payload) => {
  const schema = {
    id: staticFilterIdSchema,
    value: staticFilterValueSchema
  };
  return validatePayload(payload, schema);
});
const toggleExcludeStaticFilterValue = createAction("staticFilter/toggleExclude", (payload) => {
  const schema = {
    id: staticFilterIdSchema,
    value: staticFilterValueSchema
  };
  return validatePayload(payload, schema);
});
const deselectAllStaticFilterValues = createAction("staticFilter/deselectAllFilterValues", (payload) => {
  return validatePayload(payload, staticFilterIdSchema);
});
const logStaticFilterSelect = (metadata) => makeAnalyticsAction("analytics/staticFilter/select", (client) => client.makeStaticFilterSelect(metadata));
const logStaticFilterDeselect = (metadata) => makeAnalyticsAction("analytics/staticFilter/deselect", (client) => client.makeStaticFilterDeselect(metadata));
const logStaticFilterClearAll = (metadata) => makeAnalyticsAction("analytics/staticFilter/clearAll", (client) => client.makeStaticFilterClearAll(metadata));
function buildController(engine) {
  let prevState;
  const listeners = /* @__PURE__ */ new Map();
  const hasNoListeners = () => listeners.size === 0;
  const hasStateChanged = (currentState) => {
    try {
      const stringifiedState = JSON.stringify(currentState);
      const hasChanged = prevState !== stringifiedState;
      prevState = stringifiedState;
      return hasChanged;
    } catch (e) {
      console.warn('Could not detect if state has changed, check the controller "get state method"', e);
      return true;
    }
  };
  return {
    subscribe(listener) {
      listener();
      const symbol = Symbol();
      let unsubscribe;
      if (hasNoListeners()) {
        prevState = JSON.stringify(this.state);
        unsubscribe = engine.subscribe(() => {
          if (hasStateChanged(this.state)) {
            listeners.forEach((listener2) => listener2());
          }
        });
      }
      listeners.set(symbol, listener);
      return () => {
        listeners.delete(symbol);
        if (hasNoListeners()) {
          unsubscribe?.();
        }
      };
    },
    get state() {
      return {};
    }
  };
}
const getBreadcrumbs = (config) => {
  return Object.keys(config.facetSet).map((facetId2) => {
    const values = config.facetValuesSelector(config.engine.state, facetId2).map((selection) => ({
      value: selection,
      deselect: () => {
        if (selection.state === "selected") {
          config.executeToggleSelect({ facetId: facetId2, selection });
        } else if (selection.state === "excluded") {
          config.executeToggleExclude({ facetId: facetId2, selection });
        }
      }
    }));
    return {
      facetId: facetId2,
      field: config.facetSet[facetId2].request.field,
      values
    };
  }).filter((breadcrumb) => breadcrumb.values.length);
};
function buildCoreBreadcrumbManager$1(engine) {
  const controller = buildController(engine);
  const { dispatch } = engine;
  return {
    ...controller,
    get state() {
      return {
        facetBreadcrumbs: [],
        categoryFacetBreadcrumbs: [],
        numericFacetBreadcrumbs: [],
        dateFacetBreadcrumbs: [],
        staticFilterBreadcrumbs: [],
        hasBreadcrumbs: false
      };
    },
    deselectAll: () => {
      dispatch(deselectAllBreadcrumbs());
    },
    deselectBreadcrumb(value) {
      value.deselect();
    }
  };
}
function buildBreadcrumbManager(engine) {
  if (!loadBreadcrumbManagerReducers(engine)) ;
  const controller = buildCoreBreadcrumbManager$1(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().facetSet,
      executeToggleSelect: ({ facetId: facetId2, selection }) => {
        dispatch(toggleSelectFacetValue$1({ facetId: facetId2, selection }));
        dispatch(updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false }));
        dispatch(executeSearch$1({
          legacy: logFacetBreadcrumb({
            facetId: facetId2,
            facetValue: selection.value
          }),
          next: breadcrumbFacet()
        }));
      },
      executeToggleExclude: ({ facetId: facetId2, selection }) => {
        dispatch(toggleExcludeFacetValue$1({ facetId: facetId2, selection }));
        dispatch(updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false }));
        dispatch(executeSearch$1({
          legacy: logFacetBreadcrumb({
            facetId: facetId2,
            facetValue: selection.value
          }),
          next: breadcrumbFacet()
        }));
      },
      facetValuesSelector: facetResponseActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getNumericFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().numericFacetSet,
      executeToggleSelect: (payload) => {
        dispatch(toggleSelectNumericFacetValue$1(payload));
        dispatch(executeSearch$1({
          legacy: logNumericFacetBreadcrumb(payload),
          next: numericBreadcrumbFacet()
        }));
      },
      executeToggleExclude: (payload) => {
        dispatch(toggleExcludeNumericFacetValue$1(payload));
        dispatch(executeSearch$1({
          legacy: logNumericFacetBreadcrumb(payload),
          next: numericBreadcrumbFacet()
        }));
      },
      facetValuesSelector: numericFacetActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getDateFacetBreadcrumbs = () => {
    const config = {
      engine,
      facetSet: getState().dateFacetSet,
      executeToggleSelect: (payload) => {
        dispatch(toggleSelectDateFacetValue$1(payload));
        dispatch(executeSearch$1({
          legacy: logDateFacetBreadcrumb(payload),
          next: dateBreadcrumbFacet()
        }));
      },
      executeToggleExclude: (payload) => {
        dispatch(toggleExcludeDateFacetValue$1(payload));
        dispatch(executeSearch$1({
          legacy: logDateFacetBreadcrumb(payload),
          next: dateBreadcrumbFacet()
        }));
      },
      facetValuesSelector: dateFacetActiveValuesSelector
    };
    return getBreadcrumbs(config);
  };
  const getCategoryFacetBreadcrumbs = () => {
    return Object.keys(getState().categoryFacetSet).map(buildCategoryFacetBreadcrumb).filter((breadcrumb) => breadcrumb.path.length);
  };
  const buildCategoryFacetBreadcrumb = (facetId2) => {
    const path = categoryFacetResponseSelectedValuesSelector(getState(), facetId2);
    return {
      facetId: facetId2,
      field: getState().categoryFacetSet[facetId2].request.field,
      path,
      deselect: () => {
        dispatch(deselectAllCategoryFacetValues(facetId2));
        dispatch(executeSearch$1({
          legacy: logCategoryFacetBreadcrumb({
            categoryFacetPath: path.map((categoryFacetValue) => categoryFacetValue.value),
            categoryFacetId: facetId2
          }),
          next: categoryBreadcrumbFacet()
        }));
      }
    };
  };
  const getStaticFilterBreadcrumbs = () => {
    const set2 = getState().staticFilterSet ?? {};
    return Object.values(set2).map(buildStaticFilterBreadcrumb);
  };
  const buildStaticFilterBreadcrumb = (filter) => {
    const { id: id2, values: filterValues } = filter;
    const values = filterValues.filter((value) => value.state !== "idle").map((value) => buildStaticFilterBreadcrumbValue(id2, value));
    return { id: id2, values };
  };
  const buildStaticFilterBreadcrumbValue = (id2, value) => {
    return {
      value,
      deselect: () => {
        const { caption, expression } = value;
        if (value.state === "selected") {
          dispatch(toggleSelectStaticFilterValue({ id: id2, value }));
        } else if (value.state === "excluded") {
          dispatch(toggleExcludeStaticFilterValue({ id: id2, value }));
        }
        dispatch(executeSearch$1({
          legacy: logStaticFilterDeselect({
            staticFilterId: id2,
            staticFilterValue: { caption, expression }
          })
        }));
      }
    };
  };
  const getAutomaticFacetBreadcrumbs = () => {
    const set2 = getState().automaticFacetSet?.set ?? {};
    return Object.values(set2).map((slice) => buildAutomaticFacetBreadcrumb(slice.response)).filter((breadcrumb) => breadcrumb.values.length > 0);
  };
  const buildAutomaticFacetBreadcrumb = (response) => {
    const { field: field2, label } = response;
    const values = response.values.filter((value) => value.state !== "idle").map((value) => buildAutomaticFacetBreadcrumbValue(field2, value));
    return {
      facetId: field2,
      field: field2,
      label,
      values
    };
  };
  const buildAutomaticFacetBreadcrumbValue = (field2, selection) => {
    return {
      value: selection,
      deselect: () => {
        dispatch(toggleSelectAutomaticFacetValue({
          field: field2,
          selection
        }));
        dispatch(executeSearch$1({
          legacy: logFacetBreadcrumb({
            facetId: field2,
            facetValue: selection.value
          }),
          next: breadcrumbFacet()
        }));
      }
    };
  };
  function hasBreadcrumbs2() {
    return !![
      ...getFacetBreadcrumbs(),
      ...getNumericFacetBreadcrumbs(),
      ...getDateFacetBreadcrumbs(),
      ...getCategoryFacetBreadcrumbs(),
      ...getStaticFilterBreadcrumbs(),
      ...getAutomaticFacetBreadcrumbs()
    ].length;
  }
  return {
    ...controller,
    get state() {
      return {
        facetBreadcrumbs: getFacetBreadcrumbs(),
        categoryFacetBreadcrumbs: getCategoryFacetBreadcrumbs(),
        numericFacetBreadcrumbs: getNumericFacetBreadcrumbs(),
        dateFacetBreadcrumbs: getDateFacetBreadcrumbs(),
        staticFilterBreadcrumbs: getStaticFilterBreadcrumbs(),
        automaticFacetBreadcrumbs: getAutomaticFacetBreadcrumbs(),
        hasBreadcrumbs: hasBreadcrumbs2()
      };
    },
    deselectAll: () => {
      controller.deselectAll();
      dispatch(executeSearch$1({
        legacy: logClearBreadcrumbs()
      }));
    }
  };
}
function loadBreadcrumbManagerReducers(engine) {
  engine.addReducers({
    configuration,
    search: searchReducer,
    facetSet: facetSetReducer,
    numericFacetSet: numericFacetSetReducer,
    dateFacetSet: dateFacetSetReducer,
    categoryFacetSet: categoryFacetSetReducer
  });
  return true;
}
const nonEmptyArray = new ArrayValue({
  each: requiredNonEmptyString,
  required: true
});
const nonEmptyPayload = (contextKey, contextValue) => {
  validatePayload(contextKey, requiredNonEmptyString);
  if (isString(contextValue)) {
    validatePayload(contextValue, requiredNonEmptyString);
  } else {
    validatePayload(contextValue, nonEmptyArray);
  }
  return { payload: { contextKey, contextValue } };
};
const setContext$2 = createAction("context/set", (payload) => {
  for (const [k, v] of Object.entries(payload)) {
    nonEmptyPayload(k, v);
  }
  return { payload };
});
const addContext$1 = createAction("context/add", (payload) => nonEmptyPayload(payload.contextKey, payload.contextValue));
const removeContext$1 = createAction("context/remove", (payload) => validatePayload(payload, requiredNonEmptyString));
const contextReducer$1 = createReducer(getContextInitialState$1(), (builder) => {
  builder.addCase(setContext$2, (state, action) => {
    state.contextValues = action.payload;
  }).addCase(addContext$1, (state, action) => {
    state.contextValues[action.payload.contextKey] = action.payload.contextValue;
  }).addCase(removeContext$1, (state, action) => {
    delete state.contextValues[action.payload];
  }).addCase(change.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    state.contextValues = action.payload.context.contextValues;
  });
});
const ReservedContextKeys = ["caseId", "caseNumber"];
const ReservedContextKeysToControllerMap = {
  caseId: "caseContext",
  caseNumber: "caseContext"
};
class ReservedContextKeyError extends Error {
  constructor(key) {
    super(`The key "${key}" is reserved for internal use. Use ${ReservedContextKeysToControllerMap[key]} to set this value.}`);
  }
}
function isReservedContextKey(contextKey) {
  return ReservedContextKeys.includes(contextKey);
}
const initialStateSchema$9 = new Schema({
  values: new RecordValue({
    options: { required: false }
  })
});
function buildCoreContext(engine, props = {}) {
  if (!loadContextReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const initialState2 = validateInitialState(engine, initialStateSchema$9, props.initialState, "buildContext");
  if (initialState2.values) {
    dispatch(setContext$2(initialState2.values));
  }
  return {
    ...controller,
    get state() {
      return {
        values: getState().context.contextValues
      };
    },
    set(context) {
      dispatch(setContext$2(context));
    },
    ...getState().configuration.analytics.analyticsMode === "legacy" ? legacyCoreContext(dispatch) : nextCoreContext(dispatch)
  };
}
const legacyCoreContext = (dispatch) => ({
  add(contextKey, contextValue) {
    dispatch(addContext$1({ contextKey, contextValue }));
  },
  remove(key) {
    dispatch(removeContext$1(key));
  }
});
const nextCoreContext = (dispatch) => ({
  add(contextKey, contextValue) {
    if (isReservedContextKey(contextKey)) {
      throw new ReservedContextKeyError(contextKey);
    }
    dispatch(addContext$1({ contextKey, contextValue }));
  },
  remove(contextKey) {
    if (isReservedContextKey(contextKey)) {
      throw new ReservedContextKeyError(contextKey);
    }
    dispatch(removeContext$1(contextKey));
  }
});
function loadContextReducers(engine) {
  engine.addReducers({ context: contextReducer$1 });
  return true;
}
function buildContext(engine, props) {
  return buildCoreContext(engine, props);
}
const facetOptionsReducer = createReducer(getFacetOptionsInitialState(), (builder) => {
  builder.addCase(updateFacetOptions, (state, action) => {
    return { ...state, ...action.payload };
  }).addCase(executeSearch$1.fulfilled, (state) => {
    state.freezeFacetOrder = false;
  }).addCase(executeSearch$1.rejected, (state) => {
    state.freezeFacetOrder = false;
  }).addCase(change.fulfilled, (state, action) => action.payload?.facetOptions ?? state).addCase(registerCategoryFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(registerFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(registerDateFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(registerNumericFacet, (state, action) => {
    const { facetId: facetId2, tabs } = action.payload;
    handleRegisterFacetTabs(tabs, state, facetId2);
  }).addCase(enableFacet, (state, action) => {
    state.facets[action.payload].enabled = true;
  }).addCase(disableFacet, (state, action) => {
    state.facets[action.payload].enabled = false;
  }).addCase(restoreSearchParameters$1, (state, action) => {
    [
      ...Object.keys(action.payload.f ?? {}),
      ...Object.keys(action.payload.fExcluded ?? {}),
      ...Object.keys(action.payload.cf ?? {}),
      ...Object.keys(action.payload.nf ?? {}),
      ...Object.keys(action.payload.df ?? {})
    ].forEach((facetId2) => {
      if (!(facetId2 in state)) {
        state.facets[facetId2] = getFacetOptionsSliceInitialState();
      }
      state.facets[facetId2].enabled = true;
    });
  });
});
function handleRegisterFacetTabs(tabs, state, facetId2) {
  const newFacetState = {
    ...getFacetOptionsSliceInitialState(),
    tabs: tabs ?? {}
  };
  state.facets[facetId2] = newFacetState;
}
const isFacetVisibleOnTab = (facetTabs, activeTab) => {
  if (typeof facetTabs === "object" && Object.keys({ ...facetTabs }).length === 0 || !activeTab || !facetTabs) {
    return true;
  }
  if (facetTabs.excluded?.includes(activeTab)) {
    return false;
  }
  if (facetTabs.included && (facetTabs.included.length === 0 || facetTabs.included.includes(activeTab))) {
    return true;
  }
  return false;
};
const tabSetReducer = createReducer(getTabSetInitialState(), (builder) => {
  builder.addCase(registerTab, (state, action) => {
    const tab = action.payload;
    const { id: id2 } = tab;
    if (id2 in state) {
      return;
    }
    state[id2] = { ...tab, isActive: false };
  }).addCase(updateActiveTab, (state, action) => {
    const id2 = action.payload;
    activateTabIfIdExists(state, id2);
  }).addCase(restoreTab, (state, action) => {
    const id2 = action.payload;
    activateTabIfIdExists(state, id2);
  }).addCase(change.fulfilled, (state, action) => {
    return action.payload?.tabSet ?? state;
  }).addCase(restoreSearchParameters$1, (state, action) => {
    const id2 = action.payload.tab;
    if (!isNullOrUndefined(id2)) {
      Object.keys(state).forEach((tabId) => {
        state[tabId].isActive = tabId === id2;
      });
    }
  });
});
function activateTabIfIdExists(state, id2) {
  const hasId = id2 in state;
  if (!hasId) {
    return;
  }
  Object.keys(state).forEach((tabId) => {
    state[tabId].isActive = tabId === id2;
  });
}
function buildCoreTabManager(engine) {
  if (!loadTabReducers$1(engine)) ;
  const controller = buildController(engine);
  const currentTab = createSelector((state) => state.tabSet, (state) => {
    const activeTab = Object.values(state).find((tab) => tab.isActive);
    return activeTab?.id ?? "";
  });
  return {
    ...controller,
    get state() {
      return { activeTab: currentTab(engine.state) };
    }
  };
}
function loadTabReducers$1(engine) {
  engine.addReducers({ tabSet: tabSetReducer });
  return true;
}
function buildCoreFacetConditionsManager(engine, props) {
  if (!loadFacetConditionsManagerReducers(engine)) ;
  const tabManager = buildCoreTabManager(engine);
  const isFacetEnabled = (facetId2) => {
    return engine.state.facetOptions.facets[facetId2]?.enabled ?? false;
  };
  const getFacetValuesById = (facetId2) => engine.state.facetSet?.[facetId2]?.request?.currentValues ?? engine.state.categoryFacetSet?.[facetId2]?.request?.currentValues ?? engine.state.numericFacetSet?.[facetId2]?.request?.currentValues ?? engine.state.dateFacetSet?.[facetId2]?.request?.currentValues ?? null;
  const isFacetRegistered = (facetId2) => facetId2 in engine.state.facetOptions.facets;
  const selectTabSettings = (facetId2) => engine.state.facetOptions.facets[facetId2]?.tabs;
  const getRelevantStateHash = () => getObjectHash({
    isFacetRegistered: isFacetRegistered(props.facetId),
    parentFacets: props.conditions.map(({ parentFacetId }) => isFacetRegistered(parentFacetId) ? {
      enabled: isFacetEnabled(parentFacetId),
      values: getFacetValuesById(parentFacetId)
    } : null),
    isTabEnabled: isFacetVisibleOnTab(selectTabSettings(props.facetId), tabManager.state.activeTab)
  });
  const relevantStateHasChanged = () => {
    const newStateHash = getRelevantStateHash();
    if (newStateHash === relevantStateHash) {
      return false;
    }
    relevantStateHash = newStateHash;
    return true;
  };
  const areConditionsMet = () => {
    return props.conditions.length > 0 ? props.conditions.some((condition) => {
      if (!isFacetEnabled(condition.parentFacetId)) {
        return false;
      }
      const values = getFacetValuesById(condition.parentFacetId);
      if (values === null) {
        return false;
      }
      return condition.condition(values);
    }) : true;
  };
  const unfreezeFacetValues = () => {
    if (engine.state.facetSet) {
      Object.entries(engine.state.facetSet).forEach(([facetId2, slice]) => slice.request.freezeCurrentValues && engine.dispatch(updateFreezeCurrentValues({ facetId: facetId2, freezeCurrentValues: false })));
    }
  };
  const ensureConditions = () => {
    if (!isFacetRegistered(props.facetId)) {
      return;
    }
    const isEnabled = isFacetEnabled(props.facetId);
    const conditionsMet = areConditionsMet();
    const isVisibleOnTab = isFacetVisibleOnTab(selectTabSettings(props.facetId), tabManager.state.activeTab);
    const shouldBeEnabled = conditionsMet && isVisibleOnTab;
    if (isEnabled !== shouldBeEnabled) {
      engine.dispatch(shouldBeEnabled ? enableFacet(props.facetId) : disableFacet(props.facetId));
      unfreezeFacetValues();
    }
  };
  let relevantStateHash = getRelevantStateHash();
  const unsubscribe = engine.subscribe(() => {
    if (relevantStateHasChanged()) {
      ensureConditions();
    }
  });
  ensureConditions();
  return {
    stopWatching() {
      unsubscribe();
    }
  };
}
function loadFacetConditionsManagerReducers(engine) {
  engine.addReducers({ facetOptions: facetOptionsReducer });
  return true;
}
const setContext$1 = createAction("dictionaryFieldContext/set", (payload) => {
  const objSchema = new RecordValue({ options: { required: true } });
  const objError = validatePayload(payload, objSchema).error;
  if (objError) {
    return { payload, error: objError };
  }
  const values = Object.values(payload);
  const valueSchema = new ArrayValue({ each: requiredEmptyAllowedString });
  const valuesError = validatePayload(values, valueSchema).error;
  if (valuesError) {
    return { payload, error: valuesError };
  }
  return { payload };
});
const addContext = createAction("dictionaryFieldContext/add", (payload) => {
  const schema = new RecordValue({
    options: { required: true },
    values: {
      field: requiredEmptyAllowedString,
      key: requiredEmptyAllowedString
    }
  });
  return validatePayload(payload, schema);
});
const removeContext = createAction("dictionaryFieldContext/remove", (payload) => {
  return validatePayload(payload, requiredEmptyAllowedString);
});
const dictionaryFieldContextReducer = createReducer(getDictionaryFieldContextInitialState(), (builder) => {
  builder.addCase(setContext$1, (state, action) => {
    state.contextValues = action.payload;
  }).addCase(addContext, (state, action) => {
    const { field: field2, key } = action.payload;
    state.contextValues[field2] = key;
  }).addCase(removeContext, (state, action) => {
    delete state.contextValues[action.payload];
  }).addCase(change.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    state.contextValues = action.payload.dictionaryFieldContext.contextValues;
  });
});
function buildDictionaryFieldContext(engine) {
  if (!loadReducers$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      return {
        values: getState().dictionaryFieldContext.contextValues
      };
    },
    set(context) {
      dispatch(setContext$1(context));
    },
    add(field2, key) {
      dispatch(addContext({ field: field2, key }));
    },
    remove(field2) {
      dispatch(removeContext(field2));
    }
  };
}
function loadReducers$1(engine) {
  engine.addReducers({ dictionaryFieldContext: dictionaryFieldContextReducer });
  return true;
}
const hasQueryCorrectionSelector = createSelector((state) => state.queryCorrection.correctedQuery !== "" || state.wasCorrectedTo !== "", (hasQueryCorrection) => hasQueryCorrection);
const emptyLegacyCorrection = () => ({
  correctedQuery: "",
  wordCorrections: [],
  originalQuery: ""
});
const emptyNextCorrection = () => ({
  correctedQuery: "",
  corrections: [],
  originalQuery: ""
});
function getDidYouMeanInitialState$1() {
  return {
    enableDidYouMean: false,
    wasCorrectedTo: "",
    wasAutomaticallyCorrected: false,
    queryCorrection: emptyLegacyCorrection(),
    originalQuery: "",
    automaticallyCorrectQuery: true,
    queryCorrectionMode: "legacy"
  };
}
const setToNonEmptyQueryCorrection = (state, correction) => {
  const nonOptionalQueryCorrection = {
    ...emptyNextCorrection(),
    ...correction,
    correctedQuery: correction?.correctedQuery || correction?.corrections[0]?.correctedQuery || ""
  };
  state.queryCorrection = nonOptionalQueryCorrection;
  state.wasCorrectedTo = nonOptionalQueryCorrection.correctedQuery;
};
const didYouMeanReducer$1 = createReducer(getDidYouMeanInitialState$1(), (builder) => {
  builder.addCase(enableDidYouMean, (state) => {
    state.enableDidYouMean = true;
  }).addCase(disableDidYouMean, (state) => {
    state.enableDidYouMean = false;
  }).addCase(enableAutomaticQueryCorrection, (state) => {
    state.automaticallyCorrectQuery = true;
  }).addCase(disableAutomaticQueryCorrection, (state) => {
    state.automaticallyCorrectQuery = false;
  }).addCase(executeSearch$1.pending, (state) => {
    state.queryCorrection = emptyLegacyCorrection();
    state.wasAutomaticallyCorrected = false;
    state.wasCorrectedTo = "";
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    const { queryCorrection, queryCorrections } = action.payload.response;
    if (state.queryCorrectionMode === "legacy") {
      const nonOptionalQueryCorrections = queryCorrections?.[0] ? queryCorrections[0] : emptyLegacyCorrection();
      state.queryCorrection = nonOptionalQueryCorrections;
    }
    if (state.queryCorrectionMode === "next") {
      setToNonEmptyQueryCorrection(state, queryCorrection);
    }
    state.wasAutomaticallyCorrected = action.payload.automaticallyCorrected;
    state.originalQuery = action.payload.originalQuery;
  }).addCase(applyDidYouMeanCorrection, (state, action) => {
    state.wasCorrectedTo = action.payload;
  }).addCase(setCorrectionMode, (state, action) => {
    state.queryCorrectionMode = action.payload;
  });
});
function buildCoreDidYouMean(engine, props = {}) {
  if (!loadDidYouMeanReducers$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  dispatch(enableDidYouMean());
  if (props.options?.automaticallyCorrectQuery === false) {
    dispatch(disableAutomaticQueryCorrection());
  }
  dispatch(setCorrectionMode(props.options?.queryCorrectionMode || "next"));
  const getState = () => engine.state;
  const hasQueryCorrection = () => hasQueryCorrectionSelector(getState().didYouMean);
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        originalQuery: state.didYouMean.originalQuery,
        wasCorrectedTo: state.didYouMean.wasCorrectedTo,
        wasAutomaticallyCorrected: state.didYouMean.wasAutomaticallyCorrected,
        queryCorrection: state.didYouMean.queryCorrection,
        hasQueryCorrection: hasQueryCorrection()
      };
    },
    applyCorrection() {
      dispatch(applyDidYouMeanCorrection(this.state.queryCorrection.correctedQuery));
    },
    updateQueryCorrectionMode(queryCorrectionMode) {
      dispatch(setCorrectionMode(queryCorrectionMode));
    }
  };
}
function loadDidYouMeanReducers$1(engine) {
  engine.addReducers({ configuration, didYouMean: didYouMeanReducer$1 });
  return true;
}
function buildDidYouMean$1(engine, props = {}) {
  const controller = buildCoreDidYouMean(engine, props);
  const { dispatch } = engine;
  return {
    ...controller,
    get state() {
      return controller.state;
    },
    applyCorrection() {
      controller.applyCorrection();
      dispatch(executeSearch$1({
        legacy: logDidYouMeanClick(),
        next: didYouMeanClick()
      }));
    }
  };
}
function buildCoreFacetManager(engine) {
  if (!loadFacetManagerReducers(engine)) ;
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    sort(facets) {
      return sortFacets(facets, this.state.facetIds);
    },
    get state() {
      const facets = getState().search.response.facets;
      const facetIds = facets.map((f2) => f2.facetId);
      return { facetIds };
    }
  };
}
function loadFacetManagerReducers(engine) {
  engine.addReducers({ search: searchReducer, facetOptions: facetOptionsReducer });
  return true;
}
function buildFacetManager(engine) {
  return buildCoreFacetManager(engine);
}
const automaticFacetSetReducer = createReducer(getAutomaticFacetSetInitialState(), (builder) => {
  builder.addCase(executeSearch$1.fulfilled, (state, action) => {
    state.set = {};
    const facets = action.payload.response.generateAutomaticFacets?.facets;
    facets?.forEach((response) => {
      state.set[response.field] = { response };
    });
  }).addCase(setOptions, (state, action) => {
    if (action.payload.desiredCount) {
      state.desiredCount = action.payload.desiredCount;
    }
    if (action.payload.numberOfValues) {
      state.numberOfValues = action.payload.numberOfValues;
    }
  }).addCase(toggleSelectAutomaticFacetValue, (state, action) => {
    const { field: field2, selection } = action.payload;
    const facet = state.set[field2]?.response;
    if (!facet) {
      return;
    }
    const value = facet.values.find((value2) => value2.value === selection.value);
    if (!value) {
      return;
    }
    const isSelected = value.state === "selected";
    value.state = isSelected ? "idle" : "selected";
  }).addCase(deselectAllAutomaticFacetValues, (state, action) => {
    const field2 = action.payload;
    const facet = state.set[field2]?.response;
    if (!facet) {
      return;
    }
    for (const value of facet.values) {
      value.state = "idle";
    }
  }).addCase(restoreSearchParameters$1, (state, action) => {
    const af = action.payload.af ?? {};
    const currentFields = Object.keys(state.set);
    for (const field2 in af) {
      if (!state.set[field2]) {
        const response = buildTemporaryAutomaticFacetResponse(field2);
        const values = af[field2].map((value) => buildTemporarySelectedFacetValue(value));
        response.values.push(...values);
        state.set[field2] = { response };
      }
    }
    for (const field2 of currentFields) {
      if (!(field2 in af)) {
        const facet = state.set[field2]?.response;
        for (const value of facet.values) {
          value.state = "idle";
        }
      }
    }
    for (const field2 in af) {
      const facet = state.set[field2]?.response;
      if (facet) {
        const stateFacetValues = facet.values;
        const urlFacetValues = new Set(af[field2]);
        for (const value of stateFacetValues) {
          if (urlFacetValues.has(value.value)) {
            value.state = "selected";
            urlFacetValues.delete(value.value);
          } else {
            value.state = "idle";
          }
        }
        for (const value of urlFacetValues) {
          facet.values.push(buildTemporarySelectedFacetValue(value));
        }
      }
    }
  }).addCase(change.fulfilled, (_, action) => {
    if (!action.payload) {
      return;
    }
    if (Object.keys(action.payload.automaticFacetSet.set).length === 0) {
      return;
    }
    return action.payload.automaticFacetSet;
  }).addCase(deselectAllBreadcrumbs, (state) => {
    Object.values(state.set).forEach(({ response }) => {
      response.values.forEach((value) => {
        value.state = "idle";
      });
    });
  });
});
function buildTemporaryAutomaticFacetResponse(field2) {
  return {
    field: field2,
    values: [],
    moreValuesAvailable: false,
    label: "",
    indexScore: 0
  };
}
function buildTemporarySelectedFacetValue(value) {
  return {
    value,
    state: "selected",
    numberOfResults: 0
  };
}
const isFacetValueSelected = (value) => {
  return value.state === "selected";
};
const isFacetValueExcluded = (value) => {
  return value.state === "excluded";
};
const getLegacyAnalyticsActionForToggleFacetSelect = (facetId2, selection) => {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  return isFacetValueSelected(selection) ? logFacetDeselect(payload) : logFacetSelect(payload);
};
const getAnalyticsActionForToggleFacetSelect$1 = (selection) => isFacetValueSelected(selection) ? facetDeselect() : facetSelect();
const getLegacyAnalyticsActionForToggleFacetExclude = (facetId2, selection) => {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  return isFacetValueExcluded(selection) ? logFacetUnexclude(payload) : logFacetExclude(payload);
};
const getAnalyticsActionForToggleFacetExclude = (selection) => isFacetValueExcluded(selection) ? facetUnexclude() : facetExclude();
function buildAutomaticFacet(engine, props) {
  const { dispatch } = engine;
  const controller = buildController(engine);
  const { field: field2 } = props;
  return {
    ...controller,
    toggleSelect(selection) {
      dispatch(toggleSelectAutomaticFacetValue({ field: field2, selection }));
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggleFacetSelect(field2, selection),
        next: getAnalyticsActionForToggleFacetSelect$1(selection)
      }));
    },
    deselectAll() {
      dispatch(deselectAllAutomaticFacetValues(field2));
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(field2),
        next: facetClearAll()
      }));
    },
    get state() {
      const response = engine.state.automaticFacetSet?.set[field2]?.response;
      const defaultState = { field: "", values: [], label: "" };
      return response ? {
        field: response.field,
        label: response.label,
        values: response.values
      } : defaultState;
    }
  };
}
function buildOptions(options2) {
  return {
    desiredCount: options2.desiredCount,
    numberOfValues: options2.numberOfValues
  };
}
function buildAutomaticFacetGenerator(engine, props) {
  if (!loadAutomaticFacetGeneratorReducers(engine)) ;
  const { dispatch } = engine;
  const options2 = buildOptions(props.options);
  dispatch(setOptions(options2));
  const controller = buildController(engine);
  return {
    ...controller,
    get state() {
      const automaticFacets = engine.state.search.response.generateAutomaticFacets?.facets.map((facet) => buildAutomaticFacet(engine, { field: facet.field })) ?? [];
      return {
        automaticFacets
      };
    }
  };
}
function loadAutomaticFacetGeneratorReducers(engine) {
  engine.addReducers({ automaticFacetSet: automaticFacetSetReducer, configuration, search: searchReducer });
  return true;
}
var SortBy;
(function(SortBy2) {
  SortBy2["Relevance"] = "relevance";
  SortBy2["Fields"] = "fields";
})(SortBy || (SortBy = {}));
var SortDirection;
(function(SortDirection2) {
  SortDirection2["Ascending"] = "asc";
  SortDirection2["Descending"] = "desc";
})(SortDirection || (SortDirection = {}));
const buildRelevanceSortCriterion = () => ({
  by: SortBy.Relevance
});
const buildFieldsSortCriterion = (fields) => ({
  by: SortBy.Fields,
  fields
});
const sortCriterionDefinition = new RecordValue({
  options: {
    required: false
  },
  values: {
    by: new EnumValue({ enum: SortBy, required: true }),
    fields: new ArrayValue({
      each: new RecordValue({
        values: {
          field: new StringValue({ required: true }),
          direction: new EnumValue({ enum: SortDirection }),
          displayName: new StringValue()
        }
      })
    })
  }
});
const getRequestOptions = (req2, path) => {
  return {
    ...baseRequest(req2, path),
    requestParams: prepareRequestParams$1(req2)
  };
};
const prepareRequestParams$1 = (req2) => {
  const { trackingId, clientId, context, language, country, currency, page, perPage, facets, sort } = req2;
  return {
    trackingId,
    clientId,
    context,
    language,
    country,
    currency,
    page,
    perPage,
    facets,
    sort
  };
};
const baseRequest = (req2, path) => {
  const { url, accessToken } = req2;
  const baseUrl = `${url}/${path}`;
  return {
    accessToken,
    method: "POST",
    contentType: "application/json",
    url: baseUrl,
    origin: "commerceApiFetch",
    requestMetadata: { method: path }
  };
};
const buildRecommendationsRequest = (req2, path) => {
  return {
    ...baseRequest(req2, path),
    requestParams: prepareRecommendationsRequestParams(req2)
  };
};
const prepareRecommendationsRequestParams = (req2) => {
  const { slotId, trackingId, clientId, context, language, country, currency, page, perPage } = req2;
  return {
    slotId,
    trackingId,
    clientId,
    context,
    language,
    country,
    currency,
    page,
    perPage
  };
};
const getQuerySuggestRequestOptions = (req2) => {
  return {
    ...baseRequest(req2, "search/querySuggest"),
    requestParams: prepareRequestParams(req2)
  };
};
const prepareRequestParams = (req2) => {
  const { trackingId, query: query2, clientId, context, language, country, currency } = req2;
  return {
    trackingId,
    query: query2,
    clientId,
    context,
    language,
    country,
    currency
  };
};
const isErrorResponse = (r) => {
  return r.error !== void 0;
};
class CommerceAPIClient {
  options;
  constructor(options2) {
    this.options = options2;
  }
  async getProductListing(req2) {
    return this.query({
      ...getRequestOptions(req2, "listing"),
      ...this.options
    });
  }
  async search(req2) {
    const requestOptions = getRequestOptions(req2, "search");
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req2?.query
      },
      ...this.options
    });
  }
  async getRecommendations(req2) {
    return this.query({
      ...buildRecommendationsRequest(req2, "recommendations"),
      ...this.options
    });
  }
  async productSuggestions(req2) {
    const requestOptions = getRequestOptions(req2, "search/productSuggest");
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req2?.query
      },
      ...this.options
    });
  }
  async querySuggest(req2) {
    const requestOptions = getQuerySuggestRequestOptions(req2);
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req2?.query
      },
      ...this.options
    });
  }
  async facetSearch(req2, type) {
    const requestOptions = getRequestOptions(req2, "facet");
    return this.query({
      ...requestOptions,
      url: `${requestOptions.url}?type=${type}`,
      requestParams: {
        ...requestOptions.requestParams,
        facetId: req2?.facetId,
        facetQuery: req2?.facetQuery,
        query: req2?.query,
        numberOfValues: req2?.numberOfValues
      },
      ...this.options
    });
  }
  // eslint-disable-next-line @cspell/spellchecker
  // TODO: CAPI-867 - Use Commerce API's equivalent of the /plan endpoint when it becomes available.
  async plan(req2) {
    const requestOptions = getRequestOptions(req2, "search");
    return this.query({
      ...requestOptions,
      requestParams: {
        ...requestOptions.requestParams,
        query: req2?.query
      },
      ...this.options
    });
  }
  async query(options2) {
    const response = await PlatformClient.call(options2);
    if (response instanceof Error) {
      return buildAPIResponseFromErrorOrThrow(response);
    }
    const body = await response.json();
    return response.ok ? { success: body } : { error: body };
  }
}
function getCommerceApiBaseUrl(organizationId, environment = "prod") {
  const platformEndpoint = getOrganizationEndpoint(organizationId, environment);
  return `${platformEndpoint}/rest/organizations/${organizationId}/commerce/v2`;
}
const getCartInitialState = () => ({
  cartItems: [],
  cart: {},
  purchasedItems: [],
  purchased: {}
});
const getProductsFromCartState = (state) => getProductsFromCart(state.cartItems, state.cart);
const getProductsFromCartPurchasedState = (state) => getProductsFromCart(state.purchasedItems, state.purchased);
function getProductsFromCart(items, itemMap) {
  const productsMap = items.reduce((acc, key) => {
    const { productId, quantity } = itemMap[key];
    if (!(productId in acc)) {
      acc[productId] = {
        productId,
        quantity: 0
      };
    }
    acc[productId].quantity += quantity;
    return acc;
  }, {});
  return [...Object.values(productsMap)];
}
const buildBaseCommerceAPIRequest = (state, navigatorContext) => {
  const { view, location, ...restOfContext } = state.commerceContext;
  return {
    accessToken: state.configuration.accessToken,
    url: state.configuration.commerce.apiBaseUrl ?? getCommerceApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    organizationId: state.configuration.organizationId,
    trackingId: state.configuration.analytics.trackingId,
    ...restOfContext,
    ...state.configuration.analytics.enabled ? { clientId: navigatorContext.clientId } : {},
    context: {
      user: {
        ...location,
        ...navigatorContext.userAgent ? { userAgent: navigatorContext.userAgent } : {}
      },
      view: {
        ...view,
        ...navigatorContext.referrer ? { referrer: navigatorContext.referrer } : {}
      },
      capture: navigatorContext.capture ?? state.configuration.analytics.enabled,
      cart: getProductsFromCartState(state.cart),
      source: getAnalyticsSource(state.configuration.analytics)
    }
  };
};
const buildPaginatedCommerceAPIRequest = (state, navigatorContext, slotId) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    ...effectivePagination(state, slotId)
  };
};
const effectivePagination = (state, slotId) => {
  const effectiveSlice = slotId ? state.commercePagination?.recommendations[slotId] : state.commercePagination?.principal;
  return effectiveSlice && {
    page: effectiveSlice.page,
    ...effectiveSlice.perPage && {
      perPage: effectiveSlice.perPage
    }
  };
};
const buildFilterableCommerceAPIRequest = (state, navigatorContext) => {
  return {
    ...buildPaginatedCommerceAPIRequest(state, navigatorContext),
    facets: [...getFacets$1(state)],
    ...state.commerceSort && {
      sort: getSort(state.commerceSort.appliedSort)
    }
  };
};
function getFacets$1(state) {
  if (!state.facetOrder || !state.commerceFacetSet) {
    return [];
  }
  return state.facetOrder.filter((facetId2) => state.commerceFacetSet?.[facetId2]).map((facetId2) => {
    return state.manualNumericFacetSet?.[facetId2]?.manualRange ? {
      facetId: facetId2,
      field: facetId2,
      numberOfValues: 1,
      isFieldExpanded: false,
      preventAutoSelect: true,
      type: "numericalRange",
      values: [state.manualNumericFacetSet[facetId2].manualRange],
      initialNumberOfValues: 1
    } : state.commerceFacetSet[facetId2].request;
  }).filter((facet) => facet && facet.values.length > 0);
}
function getSort(appliedSort) {
  if (appliedSort.by === SortBy.Relevance) {
    return {
      sortCriteria: SortBy.Relevance
    };
  } else {
    return {
      sortCriteria: SortBy.Fields,
      fields: appliedSort.fields.map(({ name, direction }) => ({
        field: name,
        direction
      }))
    };
  }
}
const buildCategoryFacetSearchRequest$1 = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  const baseFacetQuery = state.categoryFacetSearchSet[facetId2].options.query;
  const facetQuery = `*${baseFacetQuery}*`;
  const categoryFacet = state.commerceFacetSet[getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2)]?.request;
  const path = categoryFacet && isCategoryFacetRequest(categoryFacet) ? categoryFacet && getPathToSelectedCategoryFacetItem$1(categoryFacet) : [];
  const ignorePaths = path.length ? [path] : [];
  const query2 = isFieldSuggestionsRequest ? baseFacetQuery : state.commerceQuery?.query;
  const numberOfValues2 = state.categoryFacetSearchSet[facetId2].options.numberOfValues;
  const { url, accessToken, organizationId, trackingId, language, country, currency, clientId, context, ...restOfCommerceAPIRequest } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    ignorePaths,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};
function isCategoryFacetRequest(request) {
  return request.type === "hierarchical";
}
const getPathToSelectedCategoryFacetItem$1 = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.values[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};
const buildFacetSearchRequest = (facetId2, state, isFieldSuggestionsRequest, navigatorContext) => {
  const baseFacetQuery = state.facetSearchSet[facetId2].options.query;
  const numberOfValues2 = state.facetSearchSet[facetId2].options.numberOfValues;
  const facetQuery = `*${baseFacetQuery}*`;
  const query2 = !isFieldSuggestionsRequest ? state.commerceQuery?.query : baseFacetQuery;
  const { url, accessToken, organizationId, trackingId, language, country, currency, clientId, context, ...restOfCommerceAPIRequest } = buildFilterableCommerceAPIRequest(state, navigatorContext);
  return {
    url,
    accessToken,
    organizationId,
    facetId: getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2),
    facetQuery: isFieldSuggestionsRequest ? "*" : facetQuery,
    numberOfValues: numberOfValues2,
    trackingId,
    language,
    country,
    currency,
    clientId,
    context,
    query: query2,
    ...!isFieldSuggestionsRequest && { ...restOfCommerceAPIRequest }
  };
};
const getExecuteFacetSearchThunkPayloadCreator$1 = (isFieldSuggestionsRequest) => async ({ facetId: facetId2, facetSearchType }, { getState, extra: { validatePayload: validatePayload2, navigatorContext, apiClient } }) => {
  const state = getState();
  validatePayload2(facetId2, requiredNonEmptyString);
  const req2 = isRegularFacetSearchState(state, facetId2) || isRegularFieldSuggestionsState(state, facetId2) ? buildFacetSearchRequest(facetId2, state, isFieldSuggestionsRequest, navigatorContext) : buildCategoryFacetSearchRequest$1(facetId2, state, isFieldSuggestionsRequest, navigatorContext);
  const response = await apiClient.facetSearch(req2, facetSearchType);
  return { facetId: facetId2, response };
};
const executeCommerceFacetSearch = createAsyncThunk("commerce/facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator$1(false));
const executeCommerceFieldSuggest = createAsyncThunk("commerce/facetSearch/facetFieldSuggest", getExecuteFacetSearchThunkPayloadCreator$1(true));
const isRegularFacetSearchState = (s, facetId2) => {
  return "facetSearchSet" in s && s.facetSearchSet[facetId2] !== void 0 && s.commerceFacetSet[facetId2] !== void 0;
};
const isRegularFieldSuggestionsState = (s, facetId2) => {
  if (!("fieldSuggestionsOrder" in s)) {
    return false;
  }
  return s.fieldSuggestionsOrder.some((facet) => facet.facetId === facetId2 && facet.type === "regular");
};
const commerceFieldSuggestionNamespace = "field_suggestion:";
function getFacetIdWithoutCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2.slice(commerceFieldSuggestionNamespace.length) : facetId2;
}
function getFacetIdWithCommerceFieldSuggestionNamespace(facetId2) {
  return facetId2.startsWith(commerceFieldSuggestionNamespace) ? facetId2 : `${commerceFieldSuggestionNamespace}${facetId2}`;
}
const perPagePrincipalSelector = createSelector((state) => state.commercePagination?.principal.perPage || 0, (perPage) => perPage);
const perPageRecommendationSelector = createSelector((state, slotId) => state.commercePagination?.recommendations[slotId]?.perPage || 0, (perPage) => perPage);
const totalEntriesPrincipalSelector = createSelector((state) => state.commercePagination?.principal.totalEntries || 0, (totalEntries) => totalEntries);
const totalEntriesRecommendationSelector = createSelector((state, slotId) => state.commercePagination?.recommendations[slotId]?.totalEntries || 0, (totalEntries) => totalEntries);
const pagePrincipalSelector = createSelector((state) => state.commercePagination?.principal.page || 0, (page) => page);
const pageRecommendationSelector = createSelector((state, slotId) => state.commercePagination?.recommendations[slotId]?.page || 0, (page) => page);
createSelector((engine) => engine[stateKey].productListing.responseId, (responseId) => responseId);
const responseIdSelector$1 = createSelector((state) => state.productListing.responseId, (responseId) => responseId);
const requestIdSelector$1 = createSelector((state) => state.productListing.requestId, (requestId) => requestId);
const numberOfProductsSelector$1 = createSelector((state) => state.productListing?.products.length || 0, (len) => len);
const moreProductsAvailableSelector$1 = createSelector((state) => ({
  total: totalEntriesPrincipalSelector(state),
  current: numberOfProductsSelector$1(state)
}), ({ current: current2, total }) => current2 < total);
const isLoadingSelector$2 = createSelector((state) => state.productListing?.isLoading, (isLoading) => isNullOrUndefined(isLoading) ? false : isLoading);
const errorSelector$1 = createSelector((state) => state.productListing?.error, (error) => error ?? null);
const fetchProductListing = createAsyncThunk("commerce/productListing/fetch", async (_action, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const state = getState();
  const fetched = await apiClient.getProductListing(buildFilterableCommerceAPIRequest(state, navigatorContext));
  if (isErrorResponse(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: fetched.success
  };
});
const fetchMoreProducts$1 = createAsyncThunk("commerce/productListing/fetchMoreProducts", async (_action, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const state = getState();
  const moreProductsAvailable = moreProductsAvailableSelector$1(state);
  if (!moreProductsAvailable) {
    return null;
  }
  const perPage = perPagePrincipalSelector(state);
  const numberOfProducts = numberOfProductsSelector$1(state);
  const nextPageToRequest = numberOfProducts / perPage;
  const fetched = await apiClient.getProductListing({
    ...buildFilterableCommerceAPIRequest(state, navigatorContext),
    page: nextPageToRequest
  });
  if (isErrorResponse(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: fetched.success
  };
});
const promoteChildToParentDefinition$3 = {
  child: new RecordValue({
    options: { required: true },
    values: {
      permanentid: new StringValue({ required: true })
    }
  })
};
const promoteChildToParent$3 = createAction("commerce/productListing/promoteChildToParent", (payload) => validatePayload(payload, promoteChildToParentDefinition$3));
const buildQuerySuggestRequest$1 = (id2, state, navigatorContext) => {
  return {
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    query: state.querySet[id2]
  };
};
const clearQuerySuggest$1 = createAction("commerce/querySuggest/clear", (payload) => validatePayload(payload, { id: requiredNonEmptyString }));
const fetchQuerySuggestions$1 = createAsyncThunk("commerce/querySuggest/fetch", async (payload, { getState, rejectWithValue, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  validatePayload2(payload, {
    id: requiredNonEmptyString
  });
  const state = getState();
  const request = buildQuerySuggestRequest$1(payload.id, state, navigatorContext);
  const response = await apiClient.querySuggest(request);
  if (isErrorResponse(response)) {
    return rejectWithValue(response.error);
  }
  return {
    id: payload.id,
    query: request.query,
    ...response.success
  };
});
const registerQuerySuggest$1 = createAction("commerce/querySuggest/register", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  count: new NumberValue({ min: 0 })
}));
const selectQuerySuggestion$1 = createAction("commerce/querySuggest/selectSuggestion", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  expression: requiredEmptyAllowedString
}));
const updateCoreFacetNumberOfValues = createAction("commerce/facets/core/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  numberOfValues: new NumberValue({ required: true, min: 1 })
}));
const updateCoreFacetIsFieldExpanded = createAction("commerce/facets/core/updateIsFieldExpanded", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  isFieldExpanded: new BooleanValue({ required: true })
}));
const clearAllCoreFacets = createAction("commerce/facets/core/clearAll");
const deleteAllCoreFacets = createAction("commerce/facets/core/deleteAll");
const deselectAllValuesInCoreFacet = createAction("commerce/facets/core/deselectAllValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString
}));
const updateCoreFacetFreezeCurrentValues = createAction("commerce/facets/core/updateFreezeCurrentValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  freezeCurrentValues: new BooleanValue({ required: true })
}));
const updateAutoSelectionForAllCoreFacets = createAction("commerce/facets/core/updateAutoSelectionForAll", (payload) => validatePayload(payload, {
  allow: new BooleanValue({ required: true })
}));
const slotIdDefinition = {
  slotId: nonRequiredEmptyAllowedString
};
const setPageSizeDefinition = {
  ...slotIdDefinition,
  pageSize: new NumberValue({ required: true, min: 0 })
};
const setPageSize = createAction("commerce/pagination/setPageSize", (payload) => validatePayload(payload, setPageSizeDefinition));
const selectPageDefinition = {
  ...slotIdDefinition,
  page: new NumberValue({ required: true, min: 0 })
};
const selectPage = createAction("commerce/pagination/selectPage", (payload) => validatePayload(payload, selectPageDefinition));
const nextPage = createAction("commerce/pagination/nextPage", (payload) => validatePayload(payload, slotIdDefinition));
const previousPage = createAction("commerce/pagination/previousPage", (payload) => validatePayload(payload, slotIdDefinition));
const registerRecommendationsSlotPagination = createAction("commerce/pagination/registerRecommendationsSlot", (payload) => validatePayload(payload, {
  slotId: requiredNonEmptyString
}));
const updateQuery$1 = createAction("commerce/query/update", (payload) => validatePayload(payload, {
  query: new StringValue()
}));
const updateIgnoreQueryTrigger = createAction("commerce/triggers/query/updateIgnore", (payload) => validatePayload(payload, {
  q: new StringValue({ emptyAllowed: true, required: true })
}));
const applyQueryTriggerModification = createAction("commerce/triggers/query/applyModification", (payload) => validatePayload(payload, new RecordValue({
  values: { originalQuery: nonEmptyString, modification: nonEmptyString }
})));
function getQ(section, querySelector2, initialState2) {
  if (section === void 0) {
    return {};
  }
  const q = querySelector2(section);
  const shouldInclude = q !== initialState2;
  return shouldInclude ? { q } : {};
}
function getSortCriteria(section, sortCriteriaSelector, initialState2) {
  if (section === void 0) {
    return {};
  }
  const sortCriteria = sortCriteriaSelector(section);
  const shouldInclude = sortCriteria !== initialState2;
  return shouldInclude ? { sortCriteria } : {};
}
function getFacets(section, facetIsEnabled2, valuesSelector, out) {
  if (section === void 0) {
    return {};
  }
  const facets = Object.entries(section).filter(([facetId2]) => facetIsEnabled2(facetId2)).map(([facetId2, { request }]) => {
    const selectedValues = valuesSelector(request);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(facets).length ? { [out]: facets } : {};
}
function getTab(section, tabSelector, initialState2) {
  if (section === void 0) {
    return {};
  }
  const tab = tabSelector(section);
  const shouldInclude = tab !== initialState2;
  return shouldInclude ? { tab } : {};
}
function getCommercePaginationInitialState() {
  return {
    principal: getCommercePaginationInitialSlice(),
    recommendations: {}
  };
}
function getCommercePaginationInitialSlice() {
  return {
    page: 0,
    perPage: 0,
    totalEntries: 0,
    totalPages: 0
  };
}
function getCommerceSortInitialState() {
  return {
    appliedSort: buildRelevanceSortCriterion(),
    availableSorts: [buildRelevanceSortCriterion()]
  };
}
function activeParametersSelector$1(state) {
  return {
    ...getPage(state?.commercePagination, (s) => s.principal.page, getCommercePaginationInitialSlice().page),
    ...getPerPage(state?.commercePagination, (s) => s.principal.perPage, getCommercePaginationInitialSlice().perPage),
    ...getSortCriteria(state?.commerceSort, (s) => s.appliedSort, getCommerceSortInitialState().appliedSort),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "regular"), getSelectedValues$1, "f"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "regular"), getExcludedValues$1, "fExcluded"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "location"), getSelectedLocationValues, "lf"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "hierarchical"), getSelectedCategoryValues, "cf"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "dateRange"), getSelectedRangeValues$1, "df"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "dateRange"), getExcludedRangeValues, "dfExcluded"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "numericalRange"), getSelectedRangeValues$1, "nf"),
    ...getFacets(state.commerceFacetSet, facetIsOfType(state, "numericalRange"), getExcludedRangeValues, "nfExcluded"),
    ...getManualNumericFacet("selected", state.manualNumericFacetSet),
    ...getManualNumericFacet("excluded", state.manualNumericFacetSet)
  };
}
function getPage(section, pageSelector, initialState2) {
  if (section === void 0) {
    return {};
  }
  const page = pageSelector(section);
  const shouldInclude = page !== initialState2;
  return shouldInclude ? { page } : {};
}
function getPerPage(section, perPageSelector, initialState2) {
  if (section === void 0) {
    return {};
  }
  const perPage = perPageSelector(section);
  const shouldInclude = perPage !== initialState2;
  return shouldInclude ? { perPage } : {};
}
function getSelectedValues$1(request) {
  return request.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getExcludedValues$1(request) {
  return request.values.filter((fv) => fv.state === "excluded").map((fv) => fv.value);
}
function getSelectedLocationValues(request) {
  return request.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getSelectedRangeValues$1(request) {
  return request.values.filter((fv) => fv.state === "selected");
}
function getExcludedRangeValues(request) {
  return request.values.filter((fv) => fv.state === "excluded");
}
function getManualNumericFacet(state, section) {
  if (!section || state === "idle") {
    return {};
  }
  const manualNumericFacets = Object.entries(section).map(([facetId2, manualFacetRange]) => {
    if (manualFacetRange.manualRange === void 0 || manualFacetRange.manualRange.state !== state) {
      return;
    }
    return { [facetId2]: [manualFacetRange.manualRange] };
  }).filter((manualRange) => manualRange !== void 0).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return state === "selected" ? { mnf: manualNumericFacets } : { mnfExcluded: manualNumericFacets };
}
function getSelectedCategoryValues(request) {
  const categoryRequest = request;
  return findActiveValueAncestry(categoryRequest.values).map((v) => v.value);
}
function facetIsOfType(state, type) {
  return (facetId2) => {
    return state.commerceFacetSet[facetId2].request.type === type;
  };
}
const getCommerceQueryInitialState = () => ({
  query: ""
});
createSelector((engine) => engine[stateKey].commerceSearch.responseId, (responseId) => responseId);
const responseIdSelector = createSelector((state) => state.commerceSearch.responseId, (responseId) => responseId);
const requestIdSelector = createSelector((state) => state.commerceSearch.requestId, (requestId) => requestId);
const numberOfProductsSelector = createSelector((state) => state.commerceSearch?.products.length || 0, (len) => len);
const moreProductsAvailableSelector = createSelector((state) => ({
  total: totalEntriesPrincipalSelector(state),
  current: numberOfProductsSelector(state)
}), ({ current: current2, total }) => current2 < total);
const isLoadingSelector$1 = createSelector((state) => state.commerceSearch?.isLoading, (isLoading) => isNullOrUndefined(isLoading) ? false : isLoading);
const errorSelector = createSelector((state) => state.commerceSearch?.error, (error) => error ?? null);
const querySelector = createSelector((state) => state.commerceQuery?.query, (query2) => query2 ?? "");
const queryExecutedSelector = createSelector((state) => state.commerceSearch?.queryExecuted, (query2) => query2);
const queryExecutedFromResponseSelector = (state, response) => {
  if (!isNullOrUndefined(response.queryCorrection?.correctedQuery)) {
    return response.queryCorrection.correctedQuery;
  }
  return querySelector(state);
};
const activeParametersSelector = (state) => {
  return {
    ...getQ(state?.commerceQuery, (s) => s.query, getCommerceQueryInitialState().query),
    ...activeParametersSelector$1(state)
  };
};
function enrichedSummarySelector(state) {
  return {
    query: queryExecutedSelector(state) || ""
  };
}
class AsyncSearchThunkProcessor3 {
  config;
  constructor(config) {
    this.config = config;
  }
  async process(fetched) {
    return this.processQueryErrorOrContinue(fetched) ?? await this.processQueryCorrectionsOrContinue(fetched) ?? await this.processQueryTriggersOrContinue(fetched) ?? this.processSuccessResponse(fetched);
  }
  async fetchFromAPI(request) {
    const startedAt = Date.now();
    const response = await this.extra.apiClient.search(request);
    const duration = Date.now() - startedAt;
    const queryExecuted = this.getState().commerceQuery.query || "";
    return { response, duration, queryExecuted, requestExecuted: request };
  }
  processSuccessResponse(fetched) {
    return {
      ...fetched,
      response: this.getSuccessResponse(fetched),
      originalQuery: this.getCurrentQuery()
    };
  }
  processQueryErrorOrContinue(fetched) {
    if (isErrorResponse(fetched.response)) {
      return this.rejectWithValue(fetched.response.error);
    }
    return null;
  }
  async processQueryCorrectionsOrContinue(fetched) {
    const state = this.getState();
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse || !state.didYouMean) {
      return null;
    }
    const { queryCorrection } = successResponse;
    const shouldExecuteQueryCorrection = !isNullOrUndefined(queryCorrection) && !isNullOrUndefined(queryCorrection.correctedQuery);
    if (!shouldExecuteQueryCorrection) {
      return null;
    }
    const { correctedQuery, originalQuery } = successResponse.queryCorrection;
    this.onUpdateQueryForCorrection(correctedQuery ?? "");
    return {
      ...fetched,
      response: {
        ...successResponse
      },
      queryExecuted: queryExecutedFromResponseSelector(state, successResponse),
      originalQuery: originalQuery ?? ""
    };
  }
  async processQueryTriggersOrContinue(fetched) {
    const successResponse = this.getSuccessResponse(fetched);
    if (!successResponse) {
      return null;
    }
    const correctedQuery = successResponse.triggers.find((trigger) => trigger.type === "query")?.content || "";
    if (!correctedQuery) {
      return null;
    }
    const ignored = this.getState().triggers?.queryModification.queryToIgnore;
    if (ignored === correctedQuery) {
      this.dispatch(updateIgnoreQueryTrigger({ q: "" }));
      return null;
    }
    const originalQuery = this.getCurrentQuery();
    const retried = await this.automaticallyRetryQueryWithTriggerModification(correctedQuery);
    if (isErrorResponse(retried.response)) {
      return this.rejectWithValue(retried.response.error);
    }
    return {
      ...retried,
      response: {
        ...retried.response.success
      },
      originalQuery
    };
  }
  async automaticallyRetryQueryWithTriggerModification(modified) {
    this.dispatch(applyQueryTriggerModification({
      newQuery: modified,
      originalQuery: this.getCurrentQuery()
    }));
    this.onUpdateQueryForCorrection(modified);
    const fetched = await this.fetchFromAPI({
      ...buildFilterableCommerceAPIRequest(this.getState(), this.navigatorContext),
      query: modified
    });
    return fetched;
  }
  get dispatch() {
    return this.config.dispatch;
  }
  get rejectWithValue() {
    return this.config.rejectWithValue;
  }
  getState() {
    return this.config.getState();
  }
  get navigatorContext() {
    return this.config.extra.navigatorContext;
  }
  getCurrentQuery() {
    const state = this.getState();
    return state.commerceQuery.query !== void 0 ? state.commerceQuery.query : "";
  }
  getSuccessResponse(fetched) {
    if (isErrorResponse(fetched.response)) {
      return null;
    }
    return fetched.response.success;
  }
  get extra() {
    return this.config.extra;
  }
  onUpdateQueryForCorrection(modification) {
    this.dispatch(updateQuery$1({ query: modification }));
  }
}
const executeSearch = createAsyncThunk("commerce/search/executeSearch", async (_action, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const query2 = querySelector(state);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({ ...request, query: query2 });
  return processor.process(fetchedResponse);
});
const fetchMoreProducts = createAsyncThunk("commerce/search/fetchMoreProducts", async (_action, config) => {
  const { getState } = config;
  const state = getState();
  const { navigatorContext } = config.extra;
  const moreProductsAvailable = moreProductsAvailableSelector(state);
  if (!moreProductsAvailable) {
    return null;
  }
  const perPage = perPagePrincipalSelector(state);
  const numberOfProducts = numberOfProductsSelector(state);
  const nextPageToRequest = numberOfProducts / perPage;
  const query2 = querySelector(state);
  const request = buildFilterableCommerceAPIRequest(state, navigatorContext);
  const processor = new AsyncSearchThunkProcessor3(config);
  const fetchedResponse = await processor.fetchFromAPI({
    ...request,
    query: query2,
    page: nextPageToRequest
  });
  return processor.process(fetchedResponse);
});
createAsyncThunk("commerce/search/prepareForSearchWithQuery", (payload, thunk2) => {
  const { dispatch } = thunk2;
  validatePayload(payload, {
    query: new StringValue(),
    clearFilters: new BooleanValue()
  });
  if (payload.clearFilters) {
    dispatch(deleteAllCoreFacets());
  }
  dispatch(updateAutoSelectionForAllCoreFacets({ allow: true }));
  dispatch(updateQuery$1({
    query: payload.query
  }));
  dispatch(selectPage({ page: 0 }));
});
const fetchInstantProducts = createAsyncThunk("commerce/search/fetchInstantProducts", async (payload, { getState, rejectWithValue, extra }) => {
  const state = getState();
  const { apiClient, navigatorContext } = extra;
  const { q } = payload;
  const fetched = await apiClient.productSuggestions({
    ...buildBaseCommerceAPIRequest(state, navigatorContext),
    query: q
  });
  if (isErrorResponse(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: { ...fetched.success, products: fetched.success.products }
  };
});
const promoteChildToParentDefinition$2 = {
  child: new RecordValue({
    options: { required: true },
    values: {
      permanentid: new StringValue({ required: true })
    }
  })
};
const promoteChildToParent$2 = createAction("commerce/search/promoteChildToParent", (payload) => validatePayload(payload, promoteChildToParentDefinition$2));
function handleFacetSearchRegistration(state, payload, buildEmptyResponse2) {
  const { facetId: facetId2 } = payload;
  if (state[facetId2]) {
    return;
  }
  const isLoading = false;
  const options2 = { ...defaultFacetSearchOptions, ...payload };
  const response = buildEmptyResponse2();
  state[facetId2] = {
    options: options2,
    isLoading,
    response,
    initialNumberOfValues: options2.numberOfValues,
    requestId: ""
  };
}
function handleFacetSearchUpdate(state, payload) {
  const { facetId: facetId2, ...rest } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.options = { ...search.options, ...rest };
}
function handleFacetSearchPending(state, facetId2, requestId) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = requestId;
  search.isLoading = true;
}
function handleFacetSearchRejected(state, facetId2) {
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.isLoading = false;
}
function handleFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  search.response = response;
}
function handleCommerceFacetSearchFulfilled(state, payload, requestId) {
  const { facetId: facetId2, response } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFacetFieldSuggestionsFulfilled(state, payload, requestId, buildEmptyResponse2) {
  const { facetId: facetId2, response } = payload;
  const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(facetId2);
  let search = state[namespacedFacetId];
  if (!search) {
    handleFacetSearchRegistration(state, { facetId: namespacedFacetId }, buildEmptyResponse2);
    search = state[namespacedFacetId];
  } else if (search.requestId !== requestId) {
    return;
  }
  search.isLoading = false;
  if ("success" in response) {
    search.response = response.success;
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(state, payload, requestId, buildEmptyResponse2) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    if (fieldSuggestionFacet.facetId in state || fieldSuggestionFacet.type !== "regular") {
      continue;
    }
    state[fieldSuggestionFacet.facetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse2(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(state, payload, requestId, buildEmptyResponse2) {
  if (!payload.fieldSuggestionsFacets) {
    return;
  }
  for (const fieldSuggestionFacet of payload.fieldSuggestionsFacets) {
    const namespacedFacetId = getFacetIdWithCommerceFieldSuggestionNamespace(fieldSuggestionFacet.facetId);
    if (namespacedFacetId in state || fieldSuggestionFacet.type !== "hierarchical") {
      continue;
    }
    state[namespacedFacetId] = {
      options: {
        ...defaultFacetSearchOptions,
        query: payload.query ?? ""
      },
      isLoading: false,
      response: buildEmptyResponse2(),
      initialNumberOfValues: defaultFacetSearchOptions.numberOfValues,
      requestId
    };
  }
}
function handleFacetSearchClear(state, payload, buildEmptyResponse2) {
  const { facetId: facetId2 } = payload;
  const search = state[facetId2];
  if (!search) {
    return;
  }
  search.requestId = "";
  search.isLoading = false;
  search.response = buildEmptyResponse2();
  search.options.numberOfValues = search.initialNumberOfValues;
  search.options.query = defaultFacetSearchOptions.query;
}
function handleFacetSearchSetClear(state, buildEmptyResponse2) {
  Object.keys(state).forEach((facetId2) => handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse2));
}
const defaultFacetSearchOptions = {
  captions: {},
  numberOfValues: 10,
  query: ""
};
const buildCategoryFacetSearchRequest = async (id2, state, navigatorContext, isFieldSuggestionsRequest) => {
  const options2 = state.categoryFacetSearchSet[id2].options;
  const categoryFacet = state.categoryFacetSet[id2].request;
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = options2;
  const { field: field2, delimitingCharacter: delimitingCharacter2, basePath: basePath2, filterFacetCount: filterFacetCount2 } = categoryFacet;
  const path = getPathToSelectedCategoryFacetItem(categoryFacet);
  const ignorePaths = path.length ? [path] : [];
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    basePath: basePath2,
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    delimitingCharacter: delimitingCharacter2,
    ignorePaths,
    filterFacetCount: filterFacetCount2,
    type: "hierarchical",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest(state, navigatorContext)).request
    }
  };
};
const getPathToSelectedCategoryFacetItem = (categoryFacet) => {
  const path = [];
  let selectedValue = categoryFacet.currentValues[0];
  while (selectedValue) {
    path.push(selectedValue.value);
    selectedValue = selectedValue.children[0];
  }
  return path;
};
const buildSpecificFacetSearchRequest = async (id2, state, navigatorContext, isFieldSuggestionsRequest) => {
  const { captions: captions2, query: query2, numberOfValues: numberOfValues2 } = state.facetSearchSet[id2].options;
  const { field: field2, currentValues, filterFacetCount: filterFacetCount2 } = state.facetSet[id2].request;
  const ignoreValues = currentValues.filter((v) => v.state !== "idle").map((facetValue) => facetValue.value);
  const newQuery = `*${query2}*`;
  return {
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    ...state.configuration.search.authenticationProviders && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    },
    captions: captions2,
    numberOfValues: numberOfValues2,
    query: newQuery,
    field: field2,
    ignoreValues,
    filterFacetCount: filterFacetCount2,
    type: "specific",
    ...isFieldSuggestionsRequest ? {} : {
      searchContext: (await buildSearchRequest(state, navigatorContext)).request
    }
  };
};
const getExecuteFacetSearchThunkPayloadCreator = (isFieldSuggestionsRequest) => async (facetId2, { getState, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  const state = getState();
  let req2;
  validatePayload2(facetId2, requiredNonEmptyString);
  if (isSpecificFacetSearchState(state, facetId2)) {
    req2 = await buildSpecificFacetSearchRequest(facetId2, state, navigatorContext, isFieldSuggestionsRequest);
  } else {
    req2 = await buildCategoryFacetSearchRequest(facetId2, state, navigatorContext, isFieldSuggestionsRequest);
  }
  const response = await apiClient.facetSearch(req2);
  return { facetId: facetId2, response };
};
const executeFacetSearch = createAsyncThunk("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator(false));
const executeFieldSuggest = createAsyncThunk("facetSearch/executeSearch", getExecuteFacetSearchThunkPayloadCreator(true));
const clearFacetSearch = createAction("facetSearch/clearResults", (payload) => validatePayload(payload, { facetId: facetIdDefinition }));
const isSpecificFacetSearchState = (s, facetId2) => {
  return s.facetSearchSet !== void 0 && s.facetSet !== void 0 && s.facetSet[facetId2] !== void 0;
};
function getCategoryFacetSearchSetInitialState() {
  return {};
}
const categoryFacetSearchSetReducer = createReducer(getCategoryFacetSearchSetInitialState(), (builder) => {
  builder.addCase(registerCategoryFacetSearch, (state, action) => {
    const payload = action.payload;
    handleFacetSearchRegistration(state, payload, buildEmptyResponse$1);
  }).addCase(updateFacetSearch, (state, action) => {
    handleFacetSearchUpdate(state, action.payload);
  }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeFacetSearch.pending, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2));
  }).addCase(executeFacetSearch.rejected, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
    handleCommerceFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
    handleCommerceFacetFieldSuggestionsFulfilled(state, action.payload, action.meta.requestId, buildEmptyResponse$1);
  }).addCase(fetchQuerySuggestions$1.fulfilled, (state, action) => {
    handleCommerceFetchQuerySuggestionsFulfilledForCategoryFacet(state, action.payload, action.meta.requestId, buildEmptyResponse$1);
  }).addCase(executeFacetSearch.fulfilled, (state, action) => {
    handleFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(clearFacetSearch, (state, { payload: { facetId: facetId2 } }) => {
    handleFacetSearchClear(state, { facetId: facetId2 }, buildEmptyResponse$1);
  }).addCase(fetchProductListing.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse$1)).addCase(executeSearch.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse$1)).addCase(executeSearch$1.fulfilled, (state) => {
    handleFacetSearchSetClear(state, buildEmptyResponse$1);
  });
});
function buildEmptyResponse$1() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}
function generateFacetId(config, logger) {
  const { field: field2, state } = config;
  if (!isFieldUsedAsFacetId(config)) {
    return field2;
  }
  const prefix = `${field2}_`;
  const id2 = calculateId(prefix, state);
  logWarningMessage(field2, logger);
  return `${prefix}${id2}`;
}
function isFieldUsedAsFacetId(config) {
  const { field: field2, state } = config;
  const sets = extractFacetSets(state);
  return sets.some((set2) => set2 && field2 in set2);
}
function calculateId(prefix, state) {
  const sets = extractFacetSets(state);
  const keys2 = sets.map((set2) => Object.keys(set2 || {})).reduce((all, current2) => all.concat(current2), []);
  return findMaxId(keys2, prefix) + 1;
}
function extractFacetSets(state) {
  const { facetSet, numericFacetSet, dateFacetSet, categoryFacetSet } = state;
  return [facetSet, numericFacetSet, dateFacetSet, categoryFacetSet];
}
function findMaxId(keys2, prefix) {
  const defaultId = 0;
  const ids = keys2.map((key) => {
    const stringId = key.split(prefix)[1];
    const id2 = parseInt(stringId, 10);
    return Number.isNaN(id2) ? defaultId : id2;
  });
  const lastNumber = ids.sort().pop();
  return lastNumber ?? defaultId;
}
function logWarningMessage(field2, logger) {
  const message = `A facet with field "${field2}" already exists.
  To avoid unexpected behaviour, configure the #id option on the facet controller.`;
  logger.warn(message);
}
function determineFacetId(engine, config) {
  const { state, logger } = engine;
  const { field: field2, facetId: facetId2 } = config;
  return facetId2 || generateFacetId({ field: field2, state }, logger);
}
const categoryFacetSortCriteria = [
  "alphanumeric",
  "occurrences"
];
const categoryFacetOptionsSchema = new Schema({
  field,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  basePath,
  delimitingCharacter,
  facetId,
  facetSearch,
  filterByBasePath,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new StringValue({
    constrainTo: categoryFacetSortCriteria
  })
});
function buildCoreCategoryFacet(engine, props) {
  if (!loadCategoryFacetReducers$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const registrationOptions = {
    ...defaultCategoryFacetOptions,
    ...omit("facetSearch", props.options),
    field: props.options.field,
    facetId: facetId2,
    tabs,
    activeTab
  };
  const options2 = {
    facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
    ...registrationOptions
  };
  validateOptions(engine, categoryFacetOptionsSchema, options2, "buildCategoryFacet");
  const getRequest = () => {
    return categoryFacetRequestSelector(engine.state, facetId2);
  };
  const getResponse = () => {
    return categoryFacetResponseSelector(engine.state, facetId2);
  };
  const getIsLoading = () => isFacetLoadingResponseSelector$2(engine.state);
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  dispatch(registerCategoryFacet(registrationOptions));
  return {
    ...controller,
    toggleSelect(selection) {
      const retrieveCount = options2.numberOfValues;
      dispatch(toggleSelectCategoryFacetValue$1({ facetId: facetId2, selection, retrieveCount }));
      dispatch(updateFacetOptions());
    },
    deselectAll() {
      dispatch(deselectAllCategoryFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateCategoryFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      const request = getRequest();
      return request.sortCriteria === criterion;
    },
    showMoreValues() {
      const { numberOfValues: increment } = options2;
      const { activeValue, valuesAsTrees } = this.state;
      const numberOfValues2 = (activeValue?.children.length ?? valuesAsTrees.length) + increment;
      dispatch(updateCategoryFacetNumberOfValues$1({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetOptions());
    },
    showLessValues() {
      const { numberOfValues: numberOfValues2 } = options2;
      dispatch(updateCategoryFacetNumberOfValues$1({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetOptions());
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = getResponse();
      const isLoading = getIsLoading();
      const enabled = getIsEnabled();
      const valuesAsTrees = response?.values ?? [];
      const isHierarchical = valuesAsTrees.some((value) => value.children.length > 0) ?? false;
      const { parents, values } = partitionIntoParentsAndValues(response?.values);
      const selectedValueAncestry = findActiveValueAncestry(valuesAsTrees);
      const activeValue = selectedValueAncestry.length ? selectedValueAncestry[selectedValueAncestry.length - 1] : void 0;
      const hasActiveValues = !!activeValue;
      const canShowMoreValues = activeValue?.moreValuesAvailable ?? response?.moreValuesAvailable ?? false;
      const canShowLessValues2 = activeValue ? activeValue.children.length > options2.numberOfValues : valuesAsTrees.length > options2.numberOfValues;
      return {
        facetId: facetId2,
        parents,
        selectedValueAncestry,
        values,
        isHierarchical,
        valuesAsTrees,
        activeValue,
        isLoading,
        hasActiveValues,
        canShowMoreValues,
        canShowLessValues: canShowLessValues2,
        sortCriteria: request.sortCriteria,
        enabled
      };
    }
  };
}
function loadCategoryFacetReducers$1(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    facetOptions: facetOptionsReducer,
    configuration,
    search: searchReducer
  });
  return true;
}
function buildGenericFacetSearch(engine, props) {
  const dispatch = engine.dispatch;
  const { options: options2, getFacetSearch, executeFacetSearchActionCreator, executeFieldSuggestActionCreator } = props;
  const { facetId: facetId2 } = options2;
  return {
    /** Updates the facet search query.
     * @param text The new query.
     */
    updateText(text) {
      dispatch(updateFacetSearch({
        facetId: facetId2,
        query: text,
        numberOfValues: getFacetSearch().initialNumberOfValues
      }));
    },
    /** Increases number of results returned by numberOfResults */
    showMoreResults() {
      const { initialNumberOfValues, options: options3 } = getFacetSearch();
      dispatch(updateFacetSearch({
        facetId: facetId2,
        numberOfValues: options3.numberOfValues + initialNumberOfValues
      }));
      dispatch(props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2));
    },
    /** Executes a facet search to update the values.*/
    search() {
      dispatch(props.isForFieldSuggestions ? executeFieldSuggestActionCreator(facetId2) : executeFacetSearchActionCreator(facetId2));
    },
    /** Resets the query and empties the values. */
    clear() {
      dispatch(clearFacetSearch({ facetId: facetId2 }));
    },
    /**
     * Updates the facet value captions.
     * @param captions - A dictionary that maps index field values to facet value display names.
     */
    updateCaptions(captions2) {
      dispatch(updateFacetSearch({
        facetId: facetId2,
        captions: captions2
      }));
    },
    get state() {
      const { response, isLoading, options: options3 } = getFacetSearch();
      const { query: query2 } = options3;
      const values = response.values;
      return {
        ...response,
        values,
        isLoading,
        query: query2
      };
    }
  };
}
function buildCoreCategoryFacetSearch(engine, props) {
  const { dispatch } = engine;
  const options2 = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options2;
  const getFacetSearch = () => "state" in engine ? engine.state.categoryFacetSearchSet[facetId2] : engine[stateKey].categoryFacetSearchSet[facetId2];
  dispatch(registerCategoryFacetSearch(options2));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options: options2,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: props.executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator: props.executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    select(value) {
      dispatch(selectCategoryFacetSearchResult({
        facetId: facetId2,
        value
      }));
      props.select(value);
    },
    get state() {
      return genericFacetSearch.state;
    }
  };
}
function buildCategoryFacetSearch$1(engine, props) {
  const { executeFacetSearchActionCreator, executeFieldSuggestActionCreator, select: propsSelect, isForFieldSuggestions } = props;
  const { dispatch } = engine;
  const options2 = { ...defaultFacetSearchOptions, ...props.options };
  const { facetId: facetId2 } = options2;
  const getFacetSearch = () => engine.state.categoryFacetSearchSet[facetId2];
  const coreFacetSearch = buildCoreCategoryFacetSearch(engine, {
    options: {
      ...options2
    },
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator,
    select: propsSelect,
    isForFieldSuggestions
  });
  dispatch(registerCategoryFacetSearch(options2));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options: options2,
    getFacetSearch,
    isForFieldSuggestions: props.isForFieldSuggestions,
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest
  });
  return {
    ...genericFacetSearch,
    ...coreFacetSearch,
    get state() {
      return {
        ...genericFacetSearch.state,
        ...coreFacetSearch.state
      };
    }
  };
}
function buildCategoryFacet$1(engine, props) {
  if (!loadCategoryFacetReducers(engine)) ;
  const coreController = buildCoreCategoryFacet(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  const facetSearch2 = buildCategoryFacetSearch$1(engine, {
    options: {
      facetId: getFacetId(),
      ...props.options.facetSearch
    },
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest,
    select: (value) => {
      dispatch(updateFacetOptions());
      dispatch(executeSearch$1({
        legacy: logFacetSelect({
          facetId: getFacetId(),
          facetValue: value.rawValue
        }),
        next: facetSelect()
      }));
    },
    isForFieldSuggestions: false
  });
  const { state: _state, ...restOfFacetSearch } = facetSearch2;
  return {
    ...coreController,
    facetSearch: restOfFacetSearch,
    toggleSelect(selection) {
      coreController.toggleSelect(selection);
      dispatch(executeSearch$1({
        legacy: getLegacyToggleSelectAnalyticsAction(getFacetId(), selection),
        next: getToggleSelectAnalyticsAction(selection)
      }));
    },
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch$1({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    showMoreValues() {
      coreController.showMoreValues();
      dispatch(fetchFacetValues({ legacy: logFacetShowMore(getFacetId()) }));
    },
    showLessValues() {
      coreController.showLessValues();
      dispatch(fetchFacetValues({ legacy: logFacetShowLess(getFacetId()) }));
    },
    get state() {
      return {
        ...coreController.state,
        facetSearch: facetSearch2.state
      };
    }
  };
}
function loadCategoryFacetReducers(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    configuration,
    search: searchReducer
  });
  return true;
}
function getLegacyToggleSelectAnalyticsAction(facetId2, selection) {
  const payload = {
    facetId: facetId2,
    facetValue: selection.value
  };
  const isSelected = selection.state === "selected";
  return isSelected ? logFacetDeselect(payload) : logFacetSelect(payload);
}
function getToggleSelectAnalyticsAction(selection) {
  const isSelected = selection.state === "selected";
  return isSelected ? facetDeselect() : facetSelect();
}
const currencies = Intl.supportedValuesOf("currency");
const currencyDefinition = new StringValue({
  required: true,
  emptyAllowed: false,
  constrainTo: currencies
});
const viewDefinition = {
  url: requiredNonEmptyString
};
const locationDefinition = {
  latitude: new NumberValue({ min: -90, max: 90, required: true }),
  longitude: new NumberValue({ min: -180, max: 180, required: true })
};
const contextDefinition = {
  language: requiredNonEmptyString,
  country: requiredNonEmptyString,
  currency: currencyDefinition,
  view: new RecordValue({
    options: { required: true },
    values: viewDefinition
  }),
  location: new RecordValue({
    options: { required: false },
    values: locationDefinition
  })
};
const setContext = createAction("commerce/context/set", (payload) => validatePayload(payload, contextDefinition));
const setView = createAction("commerce/context/setView", (payload) => validatePayload(payload, viewDefinition));
const setLocation = createAction("commerce/context/setLocation", (payload) => validatePayload(payload, locationDefinition));
function getFacetSearchSetInitialState() {
  return {};
}
const specificFacetSearchSetReducer = createReducer(getFacetSearchSetInitialState(), (builder) => {
  builder.addCase(registerFacetSearch, (state, action) => {
    const payload = action.payload;
    handleFacetSearchRegistration(state, payload, buildEmptyResponse);
  }).addCase(updateFacetSearch, (state, action) => {
    handleFacetSearchUpdate(state, action.payload);
  }).addCase(executeCommerceFacetSearch.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.pending, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchPending(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2), action.meta.requestId);
  }).addCase(executeFacetSearch.pending, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchPending(state, facetId2, action.meta.requestId);
  }).addCase(executeCommerceFacetSearch.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFieldSuggest.rejected, (state, action) => {
    const { facetId: facetId2 } = action.meta.arg;
    handleFacetSearchRejected(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2));
  }).addCase(executeFacetSearch.rejected, (state, action) => {
    const facetId2 = action.meta.arg;
    handleFacetSearchRejected(state, facetId2);
  }).addCase(executeCommerceFacetSearch.fulfilled, (state, action) => {
    handleCommerceFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => {
    handleCommerceFacetFieldSuggestionsFulfilled(state, action.payload, action.meta.requestId, buildEmptyResponse);
  }).addCase(fetchQuerySuggestions$1.fulfilled, (state, action) => {
    handleCommerceFetchQuerySuggestionsFulfilledForRegularFacet(state, action.payload, action.meta.requestId, buildEmptyResponse);
  }).addCase(executeFacetSearch.fulfilled, (state, action) => {
    handleFacetSearchFulfilled(state, action.payload, action.meta.requestId);
  }).addCase(clearFacetSearch, (state, { payload }) => {
    handleFacetSearchClear(state, payload, buildEmptyResponse);
  }).addCase(executeSearch$1.fulfilled, (state) => {
    handleFacetSearchSetClear(state, buildEmptyResponse);
  }).addCase(fetchProductListing.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse)).addCase(executeSearch.fulfilled, (state) => handleFacetSearchSetClear(state, buildEmptyResponse)).addCase(setView, (state) => handleFacetSearchSetClear(state, buildEmptyResponse));
});
function buildEmptyResponse() {
  return {
    moreValuesAvailable: false,
    values: []
  };
}
const definition$2 = {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: facetValueDefinition })
};
const executeToggleFacetSelect = createAsyncThunk("facet/executeToggleSelect", ({ facetId: facetId2, selection }, thunk2) => {
  const { dispatch, extra: { validatePayload: validatePayload2 } } = thunk2;
  validatePayload2({ facetId: facetId2, selection }, definition$2);
  dispatch(toggleSelectFacetValue$1({ facetId: facetId2, selection }));
  dispatch(updateFacetOptions());
});
const executeToggleFacetExclude = createAsyncThunk("facet/executeToggleExclude", ({ facetId: facetId2, selection }, thunk2) => {
  const { dispatch, extra: { validatePayload: validatePayload2 } } = thunk2;
  validatePayload2({ facetId: facetId2, selection }, definition$2);
  dispatch(toggleExcludeFacetValue$1({ facetId: facetId2, selection }));
  dispatch(updateFacetOptions());
});
const facetResultsMustMatch = [
  "allValues",
  "atLeastOneValue"
];
const facetSortCriteria = [
  "score",
  "alphanumeric",
  "alphanumericDescending",
  "occurrences",
  "automatic",
  "alphanumericNatural",
  "alphanumericNaturalDescending"
];
const facetOptionsSchema$1 = new Schema({
  facetId,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  field,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new StringValue({ constrainTo: facetSortCriteria }),
  resultsMustMatch: new StringValue({ constrainTo: facetResultsMustMatch }),
  facetSearch
});
function buildCoreFacet(engine, props, optionsSchema2 = facetOptionsSchema$1) {
  if (!loadFacetReducers$1(engine)) ;
  const { dispatch } = engine;
  const controller = buildController(engine);
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const registrationOptions = {
    ...defaultFacetOptions,
    ...omit("facetSearch", props.options),
    field: props.options.field,
    facetId: facetId2,
    tabs,
    activeTab
  };
  const options2 = {
    facetSearch: { ...defaultFacetSearchOptions, ...props.options.facetSearch },
    ...registrationOptions
  };
  validateOptions(engine, optionsSchema2, options2, "buildFacet");
  const getRequest = () => facetRequestSelector$1(engine.state, facetId2);
  const getResponse = () => facetResponseSelector$2(engine.state, facetId2);
  const getIsLoading = () => isFacetLoadingResponseSelector$2(engine.state);
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  const getNumberOfActiveValues = () => {
    const { currentValues } = getRequest();
    return currentValues.filter((v) => v.state !== "idle").length;
  };
  const computeCanShowLessValues = () => {
    const { currentValues } = getRequest();
    const initialNumberOfValues = options2.numberOfValues;
    const hasIdleValues = !!currentValues.find((v) => v.state === "idle");
    return initialNumberOfValues < currentValues.length && hasIdleValues;
  };
  dispatch(registerFacet(registrationOptions));
  return {
    ...controller,
    toggleSelect: (selection) => dispatch(executeToggleFacetSelect({ facetId: options2.facetId, selection })),
    toggleExclude: (selection) => dispatch(executeToggleFacetExclude({ facetId: options2.facetId, selection })),
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleExclude: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleExclude(selection);
    },
    isValueSelected: isFacetValueSelected,
    isValueExcluded: isFacetValueExcluded,
    deselectAll() {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    showMoreValues() {
      const numberInState = getRequest().numberOfValues;
      const initialNumberOfValues = options2.numberOfValues;
      const numberToNextMultipleOfConfigured = initialNumberOfValues - numberInState % initialNumberOfValues;
      const numberOfValues2 = numberInState + numberToNextMultipleOfConfigured;
      dispatch(updateFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: true }));
      dispatch(updateFacetOptions());
    },
    showLessValues() {
      const initialNumberOfValues = options2.numberOfValues;
      const newNumberOfValues = Math.max(initialNumberOfValues, getNumberOfActiveValues());
      dispatch(updateFacetNumberOfValues({ facetId: facetId2, numberOfValues: newNumberOfValues }));
      dispatch(updateFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: false }));
      dispatch(updateFacetOptions());
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = getResponse();
      const isLoading = getIsLoading();
      const enabled = getIsEnabled();
      let sortCriterion;
      if (typeof request.sortCriteria === "object") {
        sortCriterion = request.sortCriteria.order === "descending" ? "alphanumericDescending" : "alphanumeric";
      } else {
        sortCriterion = request.sortCriteria;
      }
      const values = response ? response.values : [];
      const hasActiveValues = values.some((facetValue) => facetValue.state !== "idle");
      const canShowMoreValues = response ? response.moreValuesAvailable : false;
      const resultsMustMatch = request.resultsMustMatch;
      return {
        label: response?.label,
        facetId: facetId2,
        tabs,
        values,
        sortCriterion,
        resultsMustMatch,
        isLoading,
        hasActiveValues,
        canShowMoreValues,
        canShowLessValues: computeCanShowLessValues(),
        enabled
      };
    }
  };
}
function loadFacetReducers$1(engine) {
  engine.addReducers({ facetSet: facetSetReducer, facetOptions: facetOptionsReducer, configuration, facetSearchSet: specificFacetSearchSetReducer });
  return true;
}
function buildFacetSearch(engine, props) {
  const { dispatch } = engine;
  const { options: options2, select: propsSelect, exclude: propsExclude, isForFieldSuggestions, executeFacetSearchActionCreator, executeFieldSuggestActionCreator } = props;
  const { facetId: facetId2 } = options2;
  const getFacetSearch = () => "state" in engine ? engine.state.facetSearchSet[facetId2] : engine[stateKey].facetSearchSet[facetId2];
  dispatch(registerFacetSearch(options2));
  const genericFacetSearch = buildGenericFacetSearch(engine, {
    options: options2,
    getFacetSearch,
    isForFieldSuggestions,
    executeFacetSearchActionCreator,
    executeFieldSuggestActionCreator
  });
  return {
    ...genericFacetSearch,
    /**
     * Selects the provided value.
     * @param result A single specificFacetSearchResult object
     */
    select(value) {
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value.
     * @param result A single specificFacetSearchResult object
     */
    exclude(value) {
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    /**
     * Selects the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleSelect(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(selectFacetSearchResult({ facetId: facetId2, value }));
      propsSelect(value);
    },
    /**
     * Excludes the provided value, and deselects other values.
     * @param result A single specificFacetSearchResult object
     */
    singleExclude(value) {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(excludeFacetSearchResult({ facetId: facetId2, value }));
      propsExclude(value);
    },
    get state() {
      const { values } = genericFacetSearch.state;
      return {
        ...genericFacetSearch.state,
        values: values.map(({ count, displayValue, rawValue }) => ({
          count,
          displayValue,
          rawValue
        }))
      };
    }
  };
}
const facetOptionsSchema = new Schema({
  facetId,
  field,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  sortCriteria: new StringValue({ constrainTo: facetSortCriteria }),
  resultsMustMatch: new StringValue({ constrainTo: facetResultsMustMatch }),
  facetSearch,
  allowedValues,
  hasBreadcrumbs,
  customSort
});
function buildFacet(engine, props) {
  if (!loadFacetReducers(engine)) ;
  const { dispatch } = engine;
  const coreController = buildCoreFacet(engine, {
    ...props,
    options: {
      ...props.options,
      ...props.options.allowedValues && {
        allowedValues: {
          type: "simple",
          values: props.options.allowedValues
        }
      }
    }
  }, facetOptionsSchema);
  const getFacetId = () => coreController.state.facetId;
  const createFacetSearch = () => {
    const { facetSearch: facetSearch3 } = props.options;
    return buildFacetSearch(engine, {
      options: { facetId: getFacetId(), ...facetSearch3 },
      select: (value) => {
        dispatch(updateFacetOptions());
        dispatch(executeSearch$1({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: value.rawValue
          }),
          next: facetSelect()
        }));
      },
      exclude: (value) => {
        dispatch(updateFacetOptions());
        dispatch(executeSearch$1({
          legacy: logFacetExclude({
            facetId: getFacetId(),
            facetValue: value.rawValue
          }),
          next: facetExclude()
        }));
      },
      isForFieldSuggestions: false,
      executeFacetSearchActionCreator: executeFacetSearch,
      executeFieldSuggestActionCreator: executeFieldSuggest
    });
  };
  const facetSearch2 = createFacetSearch();
  const { state: _state, ...restOfFacetSearch } = facetSearch2;
  return {
    ...coreController,
    facetSearch: restOfFacetSearch,
    toggleSelect(selection) {
      coreController.toggleSelect(selection);
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggleFacetSelect(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetSelect$1(selection)
      }));
    },
    toggleExclude(selection) {
      coreController.toggleExclude(selection);
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggleFacetExclude(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetExclude(selection)
      }));
    },
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch$1({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    showMoreValues() {
      coreController.showMoreValues();
      dispatch(fetchFacetValues({ legacy: logFacetShowMore(getFacetId()) }));
    },
    showLessValues() {
      coreController.showLessValues();
      dispatch(fetchFacetValues({ legacy: logFacetShowLess(getFacetId()) }));
    },
    get state() {
      return {
        ...coreController.state,
        facetSearch: facetSearch2.state
      };
    }
  };
}
function loadFacetReducers(engine) {
  engine.addReducers({ facetSet: facetSetReducer, configuration, facetSearchSet: specificFacetSearchSetReducer, search: searchReducer });
  return true;
}
const isRangeFacetValueSelected = (selection) => {
  return selection.state === "selected";
};
const isRangeFacetValueExcluded = (selection) => {
  return selection.state === "excluded";
};
const getLegacyAnalyticsActionForToggleRangeFacetSelect = (facetId2, selection) => {
  const facetValue = `${selection.start}..${selection.end}`;
  const payload = { facetId: facetId2, facetValue };
  return isRangeFacetValueSelected(selection) ? logFacetDeselect(payload) : logFacetSelect(payload);
};
const getAnalyticsActionForToggleFacetSelect = (selection) => {
  return isRangeFacetValueSelected(selection) ? facetDeselect() : facetSelect();
};
const getLegacyAnalyticsActionForToggleRangeFacetExclude = (facetId2, selection) => {
  const facetValue = `${selection.start}..${selection.end}`;
  const payload = { facetId: facetId2, facetValue };
  return isRangeFacetValueExcluded(selection) ? logFacetUnexclude(payload) : logFacetExclude(payload);
};
const executeToggleRangeFacetSelect = createAction("rangeFacet/executeToggleSelect", (payload) => validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection)));
const executeToggleRangeFacetExclude = createAction("rangeFacet/executeToggleExclude", (payload) => validatePayload(payload, rangeFacetSelectionPayloadDefinition(payload.selection)));
const definition$1 = {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: dateFacetValueDefinition })
};
const executeToggleDateFacetSelect = createAsyncThunk("dateFacet/executeToggleSelect", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition$1);
  dispatch(toggleSelectDateFacetValue$1(payload));
  dispatch(executeToggleRangeFacetSelect(payload));
  dispatch(updateFacetOptions());
});
const executeToggleDateFacetExclude = createAsyncThunk("dateFacet/executeToggleExclude", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition$1);
  dispatch(toggleExcludeDateFacetValue$1(payload));
  dispatch(executeToggleRangeFacetExclude(payload));
  dispatch(updateFacetOptions());
});
function assertRangeFacetOptions(options2, controllerName) {
  if (!options2.generateAutomaticRanges && options2.currentValues === void 0) {
    const message = `currentValues should be specified for ${controllerName} when generateAutomaticRanges is false.`;
    throw new Error(message);
  }
}
function buildCoreRangeFacet(engine, props) {
  const { facetId: facetId2, getRequest } = props;
  const controller = buildController(engine);
  const dispatch = engine.dispatch;
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    isValueSelected: isRangeFacetValueSelected,
    isValueExcluded: isRangeFacetValueExcluded,
    deselectAll() {
      dispatch(deselectAllFacetValues(facetId2));
      dispatch(updateFacetOptions());
    },
    sortBy(criterion) {
      dispatch(updateRangeFacetSortCriterion({ facetId: facetId2, criterion }));
      dispatch(updateFacetOptions());
    },
    isSortedBy(criterion) {
      return this.state.sortCriterion === criterion;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const request = getRequest();
      const response = baseFacetResponseSelector(engine.state, facetId2);
      const sortCriterion = request.sortCriteria;
      const resultsMustMatch = request.resultsMustMatch;
      const values = response ? response.values : [];
      const isLoading = isFacetLoadingResponseSelector$2(engine.state);
      const enabled = getIsEnabled();
      const hasActiveValues = values.some((facetValue) => facetValue.state !== "idle");
      const domain = response?.domain;
      return {
        facetId: facetId2,
        values,
        sortCriterion,
        resultsMustMatch,
        hasActiveValues,
        isLoading,
        enabled,
        domain
      };
    }
  };
}
const facetValueStates = [
  "idle",
  "selected",
  "excluded"
];
const rangeFacetSortCriteria = [
  "ascending",
  "descending"
];
const rangeFacetRangeAlgorithm = [
  "even",
  "equiprobable"
];
const dateRangeRequestDefinition = {
  start: new StringValue(),
  end: new StringValue(),
  endInclusive: new BooleanValue(),
  state: new StringValue({ constrainTo: facetValueStates })
};
const dateFacetOptionsSchema = new Schema({
  facetId,
  field,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new ArrayValue({
    each: new RecordValue({ values: dateRangeRequestDefinition })
  }),
  sortCriteria: new StringValue({ constrainTo: rangeFacetSortCriteria }),
  rangeAlgorithm: new StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});
function validateDateFacetOptions(engine, options2) {
  validateOptions(engine, dateFacetOptionsSchema, options2, "buildDateFacet");
  validateManualDateRanges(options2);
}
function buildCoreDateFacet(engine, props) {
  if (!loadDateFacetReducers(engine)) ;
  assertRangeFacetOptions(props.options, "buildDateFacet");
  const dispatch = engine.dispatch;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options2 = {
    currentValues: [],
    ...props.options,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateDateFacetOptions(engine, options2);
  dispatch(registerDateFacet(options2));
  const rangeFacet = buildCoreRangeFacet(engine, {
    facetId: facetId2,
    getRequest: () => engine.state.dateFacetSet[facetId2].request
  });
  return {
    ...rangeFacet,
    toggleSelect: (selection) => dispatch(executeToggleDateFacetSelect({ facetId: facetId2, selection })),
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    toggleExclude: (selection) => dispatch(executeToggleDateFacetExclude({ facetId: facetId2, selection })),
    toggleSingleExclude: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleExclude(selection);
    },
    get state() {
      return rangeFacet.state;
    }
  };
}
function loadDateFacetReducers(engine) {
  engine.addReducers({ configuration, search: searchReducer, dateFacetSet: dateFacetSetReducer, facetOptions: facetOptionsReducer });
  return true;
}
function buildDateFacet(engine, props) {
  const coreController = buildCoreDateFacet(engine, props);
  const dispatch = engine.dispatch;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch$1({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    toggleSelect: (selection) => {
      coreController.toggleSelect(selection);
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggleRangeFacetSelect(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetSelect(selection)
      }));
    },
    toggleExclude: (selection) => {
      coreController.toggleExclude(selection);
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggleRangeFacetExclude(getFacetId(), selection)
      }));
    },
    get state() {
      return coreController.state;
    }
  };
}
function buildCoreDateFilter(engine, props) {
  if (!loadDateFilterReducer$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options2 = {
    ...props.options,
    currentValues: props.initialState?.range ? [{ ...props.initialState.range, endInclusive: true, state: "selected" }] : [],
    generateAutomaticRanges: false,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateDateFacetOptions(engine, options2);
  dispatch(registerDateFacet(options2));
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    clear: () => {
      dispatch(updateDateFacetValues$1({
        facetId: facetId2,
        values: []
      }));
      dispatch(updateFacetOptions());
    },
    setRange: (range) => {
      const facetValue = {
        ...range,
        state: "selected",
        numberOfResults: 0,
        endInclusive: true
      };
      const updateFacetValuesAction = updateDateFacetValues$1({
        facetId: facetId2,
        values: [facetValue]
      });
      if (updateFacetValuesAction.error) {
        return false;
      }
      dispatch(updateFacetValuesAction);
      dispatch(updateFacetOptions());
      return true;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const isLoading = isFacetLoadingResponseSelector$2(getState());
      const enabled = getIsEnabled();
      const selectedRanges = dateFacetSelectedValuesSelector(getState(), facetId2);
      const range = selectedRanges.length ? selectedRanges[0] : void 0;
      return {
        facetId: facetId2,
        isLoading,
        range,
        enabled
      };
    }
  };
}
function loadDateFilterReducer$1(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}
function buildDateFilter(engine, props) {
  if (!loadDateFilterReducer(engine)) ;
  const coreController = buildCoreDateFilter(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    clear: () => {
      coreController.clear();
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    setRange: (range) => {
      const success = coreController.setRange(range);
      if (success) {
        dispatch(executeSearch$1({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: `${range.start}..${range.end}`
          }),
          next: facetSelect()
        }));
      }
      return success;
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadDateFilterReducer(engine) {
  engine.addReducers({ dateFacetSet: dateFacetSetReducer, configuration, search: searchReducer });
  return true;
}
const definition = {
  facetId: facetIdDefinition,
  selection: new RecordValue({ values: numericFacetValueDefinition$1 })
};
const executeToggleNumericFacetSelect = createAsyncThunk("numericFacet/executeToggleSelect", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition);
  dispatch(toggleSelectNumericFacetValue$1(payload));
  dispatch(executeToggleRangeFacetSelect(payload));
  dispatch(updateFacetOptions());
});
createAsyncThunk("numericFacet/executeToggleExclude", (payload, { dispatch, extra: { validatePayload: validatePayload2 } }) => {
  validatePayload2(payload, definition);
  dispatch(toggleExcludeNumericFacetValue$1(payload));
  dispatch(executeToggleRangeFacetExclude(payload));
  dispatch(updateFacetOptions());
});
const numericRangeRequestDefinition = {
  start: new NumberValue(),
  end: new NumberValue(),
  endInclusive: new BooleanValue(),
  state: new StringValue({ constrainTo: facetValueStates })
};
const numericFacetOptionsSchema = new Schema({
  facetId,
  tabs: new RecordValue({
    options: {
      required: false
    },
    values: {
      included: new ArrayValue({ each: new StringValue() }),
      excluded: new ArrayValue({ each: new StringValue() })
    }
  }),
  field,
  generateAutomaticRanges,
  filterFacetCount,
  injectionDepth,
  numberOfValues,
  currentValues: new ArrayValue({
    each: new RecordValue({ values: numericRangeRequestDefinition })
  }),
  sortCriteria: new StringValue({ constrainTo: rangeFacetSortCriteria }),
  resultsMustMatch: new StringValue({ constrainTo: facetResultsMustMatch }),
  rangeAlgorithm: new StringValue({ constrainTo: rangeFacetRangeAlgorithm })
});
function validateNumericFacetOptions(engine, options2) {
  validateOptions(engine, numericFacetOptionsSchema, options2, "buildNumericFacet");
  validateManualNumericRanges(options2);
}
function buildNumericRange(config) {
  return {
    endInclusive: false,
    state: "idle",
    ...config
  };
}
function buildCoreNumericFacet(engine, props) {
  if (!loadNumericFacetReducers$1(engine)) ;
  assertRangeFacetOptions(props.options, "buildNumericFacet");
  const dispatch = engine.dispatch;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options2 = {
    currentValues: [],
    ...props.options,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateNumericFacetOptions(engine, options2);
  dispatch(registerNumericFacet(options2));
  const rangeFacet = buildCoreRangeFacet(engine, {
    facetId: facetId2,
    getRequest: () => engine.state.numericFacetSet[facetId2].request
  });
  return {
    ...rangeFacet,
    toggleSelect: (selection) => dispatch(executeToggleNumericFacetSelect({ facetId: facetId2, selection })),
    toggleSingleSelect(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllFacetValues(facetId2));
      }
      this.toggleSelect(selection);
    },
    get state() {
      return rangeFacet.state;
    }
  };
}
function loadNumericFacetReducers$1(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}
function buildNumericFacet(engine, props) {
  if (!loadNumericFacetReducers(engine)) ;
  const coreController = buildCoreNumericFacet(engine, props);
  const dispatch = engine.dispatch;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    deselectAll() {
      coreController.deselectAll();
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    sortBy(criterion) {
      coreController.sortBy(criterion);
      dispatch(executeSearch$1({
        legacy: logFacetUpdateSort({ facetId: getFacetId(), criterion })
      }));
    },
    toggleSelect: (selection) => {
      coreController.toggleSelect(selection);
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggleRangeFacetSelect(getFacetId(), selection),
        next: getAnalyticsActionForToggleFacetSelect(selection)
      }));
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadNumericFacetReducers(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, configuration, search: searchReducer });
  return true;
}
function buildCoreNumericFilter(engine, props) {
  if (!loadNumericFilterReducer$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const facetId2 = determineFacetId(engine, props.options);
  const tabs = props.options.tabs ?? {};
  const activeTab = selectActiveTab(engine.state.tabSet);
  const options2 = {
    ...props.options,
    currentValues: props.initialState?.range ? [{ ...props.initialState.range, endInclusive: true, state: "selected" }] : [],
    generateAutomaticRanges: false,
    facetId: facetId2,
    tabs,
    activeTab
  };
  validateNumericFacetOptions(engine, options2);
  dispatch(registerNumericFacet(options2));
  const getIsEnabled = () => isFacetEnabledSelector(engine.state, facetId2);
  return {
    ...controller,
    clear: () => {
      dispatch(updateNumericFacetValues$1({
        facetId: facetId2,
        values: []
      }));
      dispatch(updateFacetOptions());
    },
    setRange: (range) => {
      const facetValue = {
        ...range,
        state: "selected",
        numberOfResults: 0,
        endInclusive: true
      };
      const updateFacetValuesAction = updateNumericFacetValues$1({
        facetId: facetId2,
        values: [facetValue]
      });
      if (updateFacetValuesAction.error) {
        return false;
      }
      dispatch(updateFacetValuesAction);
      dispatch(updateFacetOptions());
      return true;
    },
    enable() {
      dispatch(enableFacet(facetId2));
    },
    disable() {
      dispatch(disableFacet(facetId2));
    },
    get state() {
      const isLoading = isFacetLoadingResponseSelector$2(getState());
      const enabled = getIsEnabled();
      const selectedRanges = numericFacetSelectedValuesSelector(getState(), facetId2);
      const range = selectedRanges.length ? selectedRanges[0] : void 0;
      return {
        facetId: facetId2,
        isLoading,
        range,
        enabled
      };
    }
  };
}
function loadNumericFilterReducer$1(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, facetOptions: facetOptionsReducer, configuration, search: searchReducer });
  return true;
}
function buildNumericFilter(engine, props) {
  if (!loadNumericFilterReducer(engine)) ;
  const coreController = buildCoreNumericFilter(engine, props);
  const { dispatch } = engine;
  const getFacetId = () => coreController.state.facetId;
  return {
    ...coreController,
    clear: () => {
      coreController.clear();
      dispatch(executeSearch$1({
        legacy: logFacetClearAll(getFacetId()),
        next: facetClearAll()
      }));
    },
    setRange: (range) => {
      const success = coreController.setRange(range);
      if (success) {
        dispatch(executeSearch$1({
          legacy: logFacetSelect({
            facetId: getFacetId(),
            facetValue: `${range.start}..${range.end}`
          }),
          next: facetSelect()
        }));
      }
      return success;
    },
    get state() {
      return {
        ...coreController.state
      };
    }
  };
}
function loadNumericFilterReducer(engine) {
  engine.addReducers({ numericFacetSet: numericFacetSetReducer, configuration, search: searchReducer });
  return true;
}
function buildCategoryFieldSuggestions(engine, props) {
  if (!loadCategoryFieldSuggestionsReducers(engine)) ;
  const { facetSearch: facetSearchOptions, ...facetOptions } = props.options.facet;
  const facetId2 = determineFacetId(engine, facetOptions);
  engine.dispatch(registerCategoryFacet({
    ...defaultCategoryFacetOptions,
    ...facetOptions,
    facetId: facetId2
  }));
  const facetSearch2 = buildCategoryFacetSearch$1(engine, {
    options: { ...facetSearchOptions, facetId: facetId2 },
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest,
    select: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(executeSearch$1({
        legacy: logFacetSelect({ facetId: facetId2, facetValue: value.rawValue }),
        next: facetSelect()
      }));
    },
    isForFieldSuggestions: true
  });
  const controller = buildController(engine);
  return {
    ...controller,
    ...facetSearch2,
    updateText: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    get state() {
      return facetSearch2.state;
    }
  };
}
function loadCategoryFieldSuggestionsReducers(engine) {
  engine.addReducers({
    categoryFacetSet: categoryFacetSetReducer,
    configuration,
    categoryFacetSearchSet: categoryFacetSearchSetReducer,
    search: searchReducer
  });
  return true;
}
function buildFieldSuggestions(engine, props) {
  if (!loadFieldSuggestionsReducers(engine)) ;
  const { facetSearch: facetSearchOptions, allowedValues: allowedValues2, ...facetOptions } = props.options.facet;
  const facetId2 = determineFacetId(engine, facetOptions);
  engine.dispatch(registerFacet({
    ...defaultFacetOptions,
    ...facetOptions,
    facetId: facetId2,
    ...allowedValues2 && {
      allowedValues: {
        type: "simple",
        values: allowedValues2
      }
    }
  }));
  const facetSearch2 = buildFacetSearch(engine, {
    options: { ...facetSearchOptions, facetId: facetId2 },
    select: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(executeSearch$1({
        legacy: logFacetSelect({ facetId: facetId2, facetValue: value.rawValue }),
        next: facetSelect()
      }));
    },
    exclude: (value) => {
      engine.dispatch(updateFacetOptions());
      engine.dispatch(executeSearch$1({
        legacy: logFacetExclude({ facetId: facetId2, facetValue: value.rawValue }),
        next: facetExclude()
      }));
    },
    isForFieldSuggestions: true,
    executeFacetSearchActionCreator: executeFacetSearch,
    executeFieldSuggestActionCreator: executeFieldSuggest
  });
  const controller = buildController(engine);
  return {
    ...controller,
    ...facetSearch2,
    updateText: (text) => {
      facetSearch2.updateText(text);
      facetSearch2.search();
    },
    get state() {
      return facetSearch2.state;
    }
  };
}
function loadFieldSuggestionsReducers(engine) {
  engine.addReducers({ facetSet: facetSetReducer, configuration, facetSearchSet: specificFacetSearchSetReducer, search: searchReducer });
  return true;
}
const foldingOptionsSchemaDefinition = {
  collectionField: new StringValue({ emptyAllowed: false, required: false }),
  parentField: new StringValue({ emptyAllowed: false, required: false }),
  childField: new StringValue({ emptyAllowed: false, required: false }),
  numberOfFoldedResults: new NumberValue({ min: 0, required: false })
};
const registerFolding = createAction("folding/register", (payload) => validatePayload(payload, foldingOptionsSchemaDefinition));
const loadCollection = createAsyncThunk("folding/loadCollection", async (collectionId, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const state = getState();
  const sharedWithSearchRequest = state.configuration.analytics.analyticsMode === "legacy" ? await buildSearchAndFoldingLoadCollectionRequest(state) : buildSearchAndFoldingLoadCollectionRequest$1(state, navigatorContext);
  const response = await apiClient.search({
    ...sharedWithSearchRequest,
    q: getQForHighlighting(state),
    enableQuerySyntax: true,
    cq: `@${state.folding.fields.collection}="${collectionId}"`,
    filterField: state.folding.fields.collection,
    childField: state.folding.fields.parent,
    parentField: state.folding.fields.child,
    filterFieldRange: 100
  }, { origin: "foldingCollection" });
  if (isErrorResponse$1(response)) {
    return rejectWithValue(response.error);
  }
  return {
    collectionId,
    results: response.success.results,
    searchUid: response.success.searchUid,
    rootResult: state.folding.collections[collectionId].result
  };
});
function getQForHighlighting(state) {
  if (state.query.q === "") {
    return "";
  }
  return state.query.enableQuerySyntax ? `${state.query.q} OR @uri` : `( <@- ${state.query.q} -@> ) OR @uri`;
}
const logShowMoreFoldedResults = (result) => makeAnalyticsAction("analytics/folding/showMore", (client, state) => {
  validateResultPayload(result);
  return client.makeShowMoreFoldedResults(partialDocumentInformation(result, state), documentIdentifier(result));
});
const logShowLessFoldedResults = () => makeAnalyticsAction("analytics/folding/showLess", (client) => {
  return client.makeShowLessFoldedResults();
});
const foldedResultAnalyticsClient = {
  logShowMoreFoldedResults,
  logShowLessFoldedResults
};
const getFoldingInitialState = () => ({
  enabled: false,
  fields: {
    collection: "foldingcollection",
    parent: "foldingparent",
    child: "foldingchild"
  },
  filterFieldRange: 2,
  collections: {}
});
function getCollectionField(result, fields) {
  return result.raw[fields.collection];
}
function getParentField(result, fields) {
  return result.raw[fields.parent];
}
function getChildField(result, fields) {
  const rawValue = result.raw[fields.child];
  if (isArray$1(rawValue)) {
    return rawValue[0];
  }
  return rawValue;
}
function areDefinedAndEqual(value1, value2) {
  return (value1 || value2) !== void 0 && value1 === value2;
}
function resolveChildrenFromFields(parent, results, fields, resolvedAncestors = []) {
  const sourceChildValue = getChildField(parent, fields);
  if (!sourceChildValue) {
    return [];
  }
  if (resolvedAncestors.indexOf(sourceChildValue) !== -1) {
    return [];
  }
  return results.filter((result) => {
    const isSameResultAsSource = getChildField(result, fields) === getChildField(parent, fields);
    const isChildOfSource = getParentField(result, fields) === sourceChildValue;
    return isChildOfSource && !isSameResultAsSource;
  }).map((result) => {
    const extendedResult = { ...result, searchUid: parent.searchUid };
    return {
      result: extendedResult,
      children: resolveChildrenFromFields(extendedResult, results, fields, [
        ...resolvedAncestors,
        sourceChildValue
      ])
    };
  });
}
function resolveRootFromFields(results, fields) {
  return results.find((result) => {
    const hasNoParent = getParentField(result, fields) === void 0;
    const isParentOfItself = areDefinedAndEqual(getParentField(result, fields), getChildField(result, fields));
    return hasNoParent || isParentOfItself;
  });
}
function resolveRootFromParentResult(result) {
  if (result.parentResult) {
    return resolveRootFromParentResult(result.parentResult);
  }
  return result;
}
function createCollectionFromResult(relevantResult, fields, searchUid, rootResult) {
  const resultsInCollection = getAllIncludedResultsFrom(relevantResult);
  const resultToUseAsRoot = rootResult ?? resolveRootFromFields(resultsInCollection, fields) ?? resolveRootFromParentResult(relevantResult);
  const extendedResultToUseAsRoot = { ...resultToUseAsRoot, searchUid };
  return {
    result: extendedResultToUseAsRoot,
    children: resolveChildrenFromFields(extendedResultToUseAsRoot, resultsInCollection, fields),
    // To understand why "1" instead of "0", see here : https://coveord.atlassian.net/browse/SEARCHAPI-11075. totalNumberOfChildResults is off by 1 by the index design.
    moreResultsAvailable: relevantResult.totalNumberOfChildResults > 1,
    isLoadingMoreResults: false
  };
}
function createCollections(results, fields, searchUid, rootResult) {
  const collections = {};
  results.forEach((result) => {
    const collectionId = getCollectionField(result, fields);
    if (!collectionId) {
      return;
    }
    if (!getChildField(result, fields) && !result.parentResult) {
      return;
    }
    collections[collectionId] = createCollectionFromResult(result, fields, searchUid, rootResult);
  });
  return collections;
}
function tryGetCollectionFromStateOrThrow(state, collectionId) {
  if (!state.collections[collectionId]) {
    throw new Error(`Missing collection ${collectionId} from ${Object.keys(state.collections)}: Folding most probably in an invalid state...`);
  }
  return state.collections[collectionId];
}
const foldingReducer = createReducer(getFoldingInitialState(), (builder) => builder.addCase(executeSearch$1.fulfilled, (state, { payload }) => {
  state.collections = state.enabled ? createCollections(payload.response.results, state.fields, payload.response.searchUid) : {};
}).addCase(fetchPage.fulfilled, (state, { payload }) => {
  state.collections = state.enabled ? createCollections(payload.response.results, state.fields, payload.response.searchUid) : {};
}).addCase(fetchMoreResults.fulfilled, (state, { payload }) => {
  state.collections = state.enabled ? {
    ...state.collections,
    ...createCollections(payload.response.results, state.fields, payload.response.searchUid)
  } : {};
}).addCase(registerFolding, (state, { payload }) => state.enabled ? state : {
  enabled: true,
  collections: {},
  fields: {
    collection: payload.collectionField ?? state.fields.collection,
    parent: payload.parentField ?? state.fields.parent,
    child: payload.childField ?? state.fields.child
  },
  filterFieldRange: payload.numberOfFoldedResults ?? state.filterFieldRange
}).addCase(loadCollection.pending, (state, { meta: meta2 }) => {
  const collectionId = meta2.arg;
  tryGetCollectionFromStateOrThrow(state, collectionId).isLoadingMoreResults = true;
}).addCase(loadCollection.rejected, (state, { meta: meta2 }) => {
  const collectionId = meta2.arg;
  tryGetCollectionFromStateOrThrow(state, collectionId).isLoadingMoreResults = false;
}).addCase(loadCollection.fulfilled, (state, { payload: { collectionId, results, rootResult, searchUid } }) => {
  const newCollections = createCollections(results, state.fields, searchUid, rootResult);
  if (!newCollections || !newCollections[collectionId]) {
    throw new Error(`Unable to create collection ${collectionId} from received results: ${JSON.stringify(results)}. Folding most probably in an invalid state... `);
  }
  state.collections[collectionId] = newCollections[collectionId];
  state.collections[collectionId].moreResultsAvailable = false;
}));
const idDefinition = {
  id: requiredNonEmptyString
};
const registerQuerySuggest = createAction("querySuggest/register", (payload) => validatePayload(payload, {
  ...idDefinition,
  count: new NumberValue({ min: 0 })
}));
const unregisterQuerySuggest = createAction("querySuggest/unregister", (payload) => validatePayload(payload, idDefinition));
const selectQuerySuggestion = createAction("querySuggest/selectSuggestion", (payload) => validatePayload(payload, {
  ...idDefinition,
  expression: requiredEmptyAllowedString
}));
const clearQuerySuggest = createAction("querySuggest/clear", (payload) => validatePayload(payload, idDefinition));
const fetchQuerySuggestions = createAsyncThunk("querySuggest/fetch", async (payload, { getState, rejectWithValue, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  validatePayload2(payload, idDefinition);
  const id2 = payload.id;
  const request = await buildQuerySuggestRequest(id2, getState(), navigatorContext);
  const response = await apiClient.querySuggest(request);
  if (isErrorResponse$1(response)) {
    return rejectWithValue(response.error);
  }
  return {
    id: id2,
    q: request.q,
    ...response.success
  };
});
const buildQuerySuggestRequest = async (id2, s, navigatorContext) => {
  return {
    accessToken: s.configuration.accessToken,
    organizationId: s.configuration.organizationId,
    url: s.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(s.configuration.organizationId, s.configuration.environment),
    count: s.querySuggest[id2].count,
    q: s.querySet[id2],
    locale: s.configuration.search.locale,
    timezone: s.configuration.search.timezone,
    actionsHistory: s.configuration.analytics.enabled ? HistoryStore2.getInstance().getHistory() : [],
    ...s.context && { context: s.context.contextValues },
    ...s.pipeline && { pipeline: s.pipeline },
    ...s.searchHub && { searchHub: s.searchHub },
    tab: s.configuration.analytics.originLevel2,
    ...s.configuration.analytics.enabled && {
      ...s.configuration.analytics.enabled && s.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams(s.configuration.analytics) : fromAnalyticsStateToAnalyticsParams$1(s.configuration.analytics, navigatorContext)
    },
    ...s.configuration.search.authenticationProviders.length && {
      authentication: s.configuration.search.authenticationProviders.join(",")
    }
  };
};
const queryReducer$1 = createReducer(getQueryInitialState(), (builder) => builder.addCase(updateQuery$2, (state, action) => ({ ...state, ...action.payload })).addCase(applyDidYouMeanCorrection, (state, action) => {
  state.q = action.payload;
}).addCase(selectQuerySuggestion, (state, action) => {
  state.q = action.payload.expression;
}).addCase(change.fulfilled, (state, action) => action.payload?.query ?? state).addCase(restoreSearchParameters$1, (state, action) => {
  state.q = action.payload.q ?? state.q;
  state.enableQuerySyntax = action.payload.enableQuerySyntax ?? state.enableQuerySyntax;
}));
const registerFieldsToInclude = createAction("fields/registerFieldsToInclude", (payload) => validatePayload(payload, nonEmptyStringArray));
const enableFetchAllFields = createAction("fields/fetchall/enable");
const disableFetchAllFields = createAction("fields/fetchall/disable");
const fetchFieldsDescription = createAsyncThunk("fields/fetchDescription", async (_, { extra, getState, rejectWithValue }) => {
  const state = getState();
  const { accessToken, environment, organizationId } = state.configuration;
  const { apiBaseUrl } = state.configuration.search;
  const descriptions = await extra.apiClient.fieldDescriptions({
    accessToken,
    organizationId,
    url: apiBaseUrl ?? getSearchApiBaseUrl(organizationId, environment)
  });
  if (isErrorResponse$1(descriptions)) {
    return rejectWithValue(descriptions.error);
  }
  return descriptions.success.fields;
});
const MinimumFieldsToInclude = [
  "author",
  "language",
  "urihash",
  "objecttype",
  "collection",
  "source",
  "permanentid"
];
[
  ...MinimumFieldsToInclude,
  "date",
  "filetype",
  "parents"
];
const getFieldsInitialState = () => ({
  fieldsToInclude: MinimumFieldsToInclude,
  fetchAllFields: false,
  fieldsDescription: []
});
const fieldsReducer = createReducer(getFieldsInitialState(), (builder) => builder.addCase(registerFieldsToInclude, (state, action) => {
  state.fieldsToInclude = [
    ...new Set(state.fieldsToInclude.concat(action.payload))
  ];
}).addCase(enableFetchAllFields, (state) => {
  state.fetchAllFields = true;
}).addCase(disableFetchAllFields, (state) => {
  state.fetchAllFields = false;
}).addCase(fetchFieldsDescription.fulfilled, (state, { payload }) => {
  state.fieldsDescription = payload;
}).addCase(registerFolding, (state, { payload }) => {
  const defaultFields = getFoldingInitialState().fields;
  state.fieldsToInclude.push(payload.collectionField ?? defaultFields.collection, payload.parentField ?? defaultFields.parent, payload.childField ?? defaultFields.child);
}));
function buildCoreStatus(engine) {
  if (!loadSearchStateReducers(engine)) ;
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        hasError: state.search.error !== null,
        isLoading: state.search.isLoading,
        hasResults: !!state.search.results.length,
        firstSearchExecuted: firstSearchExecutedSelector(state)
      };
    }
  };
}
function loadSearchStateReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}
const optionsSchema$8 = new Schema({
  fieldsToInclude: new ArrayValue({
    required: false,
    each: new StringValue({
      required: true,
      emptyAllowed: false
    })
  })
});
function buildCoreResultList(engine, props) {
  if (!loadResultListReducers(engine)) ;
  const controller = buildController(engine);
  const status = buildCoreStatus(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options2 = validateOptions(engine, optionsSchema$8, props?.options, "buildCoreResultList");
  if (options2.fieldsToInclude) {
    dispatch(registerFieldsToInclude(options2.fieldsToInclude));
  }
  const moreResultsAvailable = () => engine.state.search.results.length < engine.state.search.response.totalCountFiltered;
  let lastFetchCompleted = 0;
  let consecutiveFetches = 0;
  const maxConsecutiveFetches = 5;
  const minDelayBetweenFetches = 200;
  let errorLogged = false;
  const triggerFetchMoreResult = async () => {
    if (engine.state.search.isLoading) {
      return;
    }
    if (!moreResultsAvailable()) {
      engine.logger.info("No more results are available for the result list to fetch.");
      return;
    }
    const delayBetweenFetches = Date.now() - lastFetchCompleted;
    if (delayBetweenFetches < minDelayBetweenFetches) {
      consecutiveFetches++;
      if (consecutiveFetches >= maxConsecutiveFetches) {
        lastFetchCompleted = Date.now();
        !errorLogged && engine.logger.error(`The result list method "fetchMoreResults" execution prevented because it has been triggered consecutively ${maxConsecutiveFetches} times, with little delay. Please verify the conditions under which the function is called.`);
        errorLogged = true;
        return;
      }
    } else {
      consecutiveFetches = 0;
    }
    errorLogged = false;
    if (props?.fetchMoreResultsActionCreator) {
      await dispatch(props?.fetchMoreResultsActionCreator());
      lastFetchCompleted = Date.now();
    }
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...status.state,
        results: state.search.results,
        moreResultsAvailable: moreResultsAvailable(),
        searchResponseId: state.search.searchResponseId
      };
    },
    fetchMoreResults: triggerFetchMoreResult
  };
}
function loadResultListReducers(engine) {
  engine.addReducers({ search: searchReducer, configuration, fields: fieldsReducer });
  return true;
}
const optionsSchema$7 = new Schema(foldingOptionsSchemaDefinition);
function buildCoreFoldedResultList(engine, props, analyticsClient) {
  if (!loadFoldingReducer(engine)) ;
  const controller = buildCoreResultList(engine, props);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options2 = props.options?.folding ? validateOptions(engine, optionsSchema$7, props.options.folding, "buildFoldedResultList") : {};
  dispatch(registerFolding({ ...options2 }));
  return {
    ...controller,
    loadCollection: (collection) => {
      dispatch(props.loadCollectionActionCreator(collection.result.raw[engine.state.folding.fields.collection]));
      dispatch(analyticsClient.logShowMoreFoldedResults(collection.result));
    },
    logShowMoreFoldedResults: (result) => {
      dispatch(analyticsClient.logShowMoreFoldedResults(result));
    },
    logShowLessFoldedResults: () => {
      dispatch(analyticsClient.logShowLessFoldedResults());
    },
    findResultById(collection) {
      return searchForResult(this.state.results, (r) => r.result.uniqueId === collection.result.uniqueId);
    },
    findResultByCollection(collection) {
      return searchForResult(this.state.results, (r) => r.result.raw.foldingcollection === collection.result.raw.foldingcollection);
    },
    get state() {
      const state = getState();
      return {
        ...controller.state,
        results: controller.state.results.map((result) => {
          const collectionId = result.raw[state.folding.fields.collection];
          if (!collectionId || !state.folding.collections[collectionId]) {
            return {
              result,
              moreResultsAvailable: false,
              isLoadingMoreResults: false,
              children: []
            };
          }
          return state.folding.collections[collectionId];
        })
      };
    }
  };
}
function loadFoldingReducer(engine) {
  engine.addReducers({ search: searchReducer, configuration: configurationReducer$1, folding: foldingReducer, query: queryReducer$1 });
  return true;
}
function searchForResult(results, compareCb) {
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    if (compareCb(result)) {
      return result;
    }
    if (result.children.length) {
      const childResult = searchForResult(result.children, compareCb);
      if (childResult) {
        return childResult;
      }
    }
  }
  return null;
}
function buildFoldedResultList(engine, props = {}) {
  const foldedResultList = buildCoreFoldedResultList(engine, {
    ...props,
    loadCollectionActionCreator: loadCollection,
    fetchMoreResultsActionCreator: fetchMoreResults
  }, foldedResultAnalyticsClient);
  return {
    ...foldedResultList,
    get state() {
      return foldedResultList.state;
    }
  };
}
function getGeneratedAnswerInitialState() {
  return {
    id: "",
    isVisible: true,
    isEnabled: true,
    isLoading: false,
    isStreaming: false,
    citations: [],
    liked: false,
    disliked: false,
    responseFormat: {
      contentFormat: ["text/plain"]
    },
    feedbackModalOpen: false,
    feedbackSubmitted: false,
    fieldsToIncludeInCitations: [],
    isAnswerGenerated: false,
    expanded: false,
    cannotAnswer: false,
    answerApiQueryParams: void 0,
    answerId: void 0,
    answerGenerationMode: "automatic"
  };
}
function filterOutDuplicatedCitations(citations) {
  const citationUris = /* @__PURE__ */ new Set();
  return citations.filter((citation) => {
    const isCitationUriUnique = !citationUris.has(citation.uri);
    if (isCitationUriUnique) {
      citationUris.add(citation.uri);
    }
    return isCitationUriUnique;
  });
}
createReducer(getGeneratedAnswerInitialState(), (builder) => builder.addCase(setIsVisible, (state, { payload }) => {
  state.isVisible = payload;
}).addCase(setIsEnabled, (state, { payload }) => {
  state.isEnabled = payload;
}).addCase(setId, (state, { payload }) => {
  state.id = payload.id;
}).addCase(updateMessage, (state, { payload }) => {
  state.isLoading = false;
  state.isStreaming = true;
  if (!state.answer) {
    state.answer = "";
  }
  state.answer += payload.textDelta;
  delete state.error;
}).addCase(updateCitations, (state, { payload }) => {
  state.isLoading = false;
  state.isStreaming = true;
  state.citations = filterOutDuplicatedCitations([
    ...state.citations,
    ...payload.citations
  ]);
  delete state.error;
}).addCase(updateError, (state, { payload }) => {
  state.isLoading = false;
  state.isStreaming = false;
  state.error = {
    ...payload,
    isRetryable: payload.code === RETRYABLE_STREAM_ERROR_CODE
  };
  state.citations = [];
  delete state.answer;
}).addCase(likeGeneratedAnswer, (state) => {
  state.liked = true;
  state.disliked = false;
}).addCase(dislikeGeneratedAnswer, (state) => {
  state.liked = false;
  state.disliked = true;
}).addCase(openGeneratedAnswerFeedbackModal, (state) => {
  state.feedbackModalOpen = true;
}).addCase(closeGeneratedAnswerFeedbackModal, (state) => {
  state.feedbackModalOpen = false;
}).addCase(sendGeneratedAnswerFeedback, (state) => {
  state.feedbackSubmitted = true;
}).addCase(resetAnswer, (state) => {
  return {
    ...getGeneratedAnswerInitialState(),
    ...state.answerConfigurationId ? { answerConfigurationId: state.answerConfigurationId } : {},
    responseFormat: state.responseFormat,
    fieldsToIncludeInCitations: state.fieldsToIncludeInCitations,
    isVisible: state.isVisible,
    id: state.id
  };
}).addCase(setIsLoading, (state, { payload }) => {
  state.isLoading = payload;
}).addCase(setIsStreaming, (state, { payload }) => {
  state.isStreaming = payload;
}).addCase(setAnswerContentFormat, (state, { payload }) => {
  state.answerContentFormat = payload;
}).addCase(updateResponseFormat, (state, { payload }) => {
  state.responseFormat = payload;
}).addCase(registerFieldsToIncludeInCitations, (state, action) => {
  state.fieldsToIncludeInCitations = [
    ...new Set(state.fieldsToIncludeInCitations.concat(action.payload))
  ];
}).addCase(setIsAnswerGenerated, (state, { payload }) => {
  state.isAnswerGenerated = payload;
}).addCase(expandGeneratedAnswer, (state) => {
  state.expanded = true;
}).addCase(collapseGeneratedAnswer, (state) => {
  state.expanded = false;
}).addCase(updateAnswerConfigurationId, (state, { payload }) => {
  state.answerConfigurationId = payload;
}).addCase(setCannotAnswer, (state, { payload }) => {
  state.cannotAnswer = payload;
}).addCase(setAnswerApiQueryParams, (state, { payload }) => {
  state.answerApiQueryParams = payload;
}).addCase(setAnswerId, (state, { payload }) => {
  state.answerId = payload;
}).addCase(setAnswerGenerationMode, (state, { payload }) => {
  state.answerGenerationMode = payload;
}));
answerSlice.injectEndpoints({
  endpoints: (builder) => ({
    /**
     * Based on the RTKQuery documentation, the `query` method is typically utilized for GET requests,
     * while the `mutation` method is designed for POST requests.
     * However, in this instance,
     * we hypothesize that the use of `mutation` is incompatible when paired with an empty response body and an 'application/json' content-type response header.
     * This should be updated as soon as we can remove the content-type header from the response.
     * @see https://redux-toolkit.js.org/rtk-query/usage/mutations#mutations
     */
    post: builder.query({
      query: (body) => ({
        url: "/evaluations",
        method: "POST",
        body
      })
    })
  })
});
function buildInteractiveResultCore(engine, props, action) {
  if (!loadInteractiveResultCoreReducers(engine)) ;
  const defaultDelay = 1e3;
  const options2 = {
    selectionDelay: defaultDelay,
    debounceWait: defaultDelay,
    ...props.options
  };
  let longPressTimer;
  return {
    select: debounce(action, options2.debounceWait, { isImmediate: true }),
    beginDelayedSelect() {
      longPressTimer = setTimeout(action, options2.selectionDelay);
    },
    cancelPendingSelect() {
      longPressTimer && clearTimeout(longPressTimer);
    }
  };
}
function loadInteractiveResultCoreReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}
const parametersDefinition = {
  f: new RecordValue(),
  fExcluded: new RecordValue(),
  lf: new RecordValue(),
  cf: new RecordValue(),
  nf: new RecordValue(),
  nfExcluded: new RecordValue(),
  mnf: new RecordValue(),
  mnfExcluded: new RecordValue(),
  df: new RecordValue(),
  dfExcluded: new RecordValue(),
  sortCriteria: new RecordValue(),
  page: new NumberValue({ min: 0 }),
  perPage: new NumberValue({ min: 1 })
};
const restoreProductListingParameters = createAction("commerce/productListingParameters/restore", (payload) => validatePayload(payload, parametersDefinition));
const searchParametersDefinition = {
  q: new StringValue(),
  ...parametersDefinition
};
const restoreSearchParameters = createAction("commerce/searchParameters/restore", (payload) => validatePayload(payload, searchParametersDefinition));
const facetOrderReducer = createReducer(getFacetOrderInitialState(), (builder) => {
  builder.addCase(executeSearch$1.fulfilled, handleQueryFulfilled$1).addCase(fetchProductListing.fulfilled, handleQueryFulfilled$1).addCase(executeSearch.fulfilled, handleQueryFulfilled$1).addCase(restoreSearchParameters, handleRestoreParameters$2).addCase(restoreProductListingParameters, handleRestoreParameters$2).addCase(change.fulfilled, (state, action) => {
    return action.payload?.facetOrder ?? state;
  }).addCase(setView, () => getFacetOrderInitialState()).addCase(setContext, () => getFacetOrderInitialState());
});
function handleQueryFulfilled$1(_, action) {
  return action.payload.response.facets.map((facet) => facet.facetId);
}
function handleRestoreParameters$2(_, action) {
  return [
    ...Object.keys(action.payload.f ?? {}),
    ...Object.keys(action.payload.lf ?? {}),
    ...Object.keys(action.payload.nf ?? {}),
    ...Object.keys(action.payload.df ?? {}),
    ...Object.keys(action.payload.cf ?? {}),
    ...Object.keys(action.payload.mnf ?? {})
  ];
}
const logNavigateForward = () => makeAnalyticsAction(
  "history/analytics/forward",
  (client) => client.makeSearchEvent("historyForward")
  // TODO: Need to create this event natively in coveo.analytics to remove cast
);
const logNavigateBackward = () => makeAnalyticsAction(
  "history/analytics/backward",
  (client) => client.makeSearchEvent("historyBackward")
  // TODO: Need to create this event natively in coveo.analytics to remove cast
);
const logNoResultsBack = () => makeAnalyticsAction("history/analytics/noresultsback", (client) => client.makeNoResultsBack());
const makeHistory = (state) => ({
  past: [],
  present: state,
  future: []
});
const undo = (state) => {
  const { past, present, future } = state;
  if (!present) {
    return state;
  }
  if (past.length === 0) {
    return state;
  }
  const previous = past[past.length - 1];
  const newPast = past.slice(0, past.length - 1);
  return {
    past: newPast,
    present: previous,
    future: [present, ...future]
  };
};
const redo = (state) => {
  const { past, present, future } = state;
  if (!present) {
    return state;
  }
  if (future.length === 0) {
    return state;
  }
  const next = future[0];
  const newFuture = future.slice(1);
  return {
    past: [...past, present],
    present: next,
    future: newFuture
  };
};
const updateHistory = (options2) => {
  const { action, state, reducer } = options2;
  const { past, present } = state;
  const newPresent = reducer(present, action);
  if (!present) {
    return makeHistory(newPresent);
  }
  if (present === newPresent) {
    return state;
  }
  return {
    past: [...past, present].slice(-10),
    present: newPresent,
    future: []
  };
};
const undoable = (options2) => {
  const { actionTypes, reducer } = options2;
  const emptyHistoryState = makeHistory();
  return (state = emptyHistoryState, action) => {
    switch (action.type) {
      case actionTypes.undo:
        return undo(state);
      case actionTypes.redo:
        return redo(state);
      case actionTypes.snapshot:
        return updateHistory({
          state,
          reducer,
          action
        });
      default:
        return state;
    }
  };
};
var getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual2(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    var cache2 = state.cache;
    var cachedA = cache2.get(a);
    var cachedB = cache2.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache2.set(a, b);
    cache2.set(b, a);
    var result = areItemsEqual(a, b, state);
    cache2.delete(a);
    cache2.delete(b);
    return result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || (function(object, property) {
  return hasOwnProperty.call(object, property);
});
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;
function areArraysEqual(a, b, state) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.entries();
  var aResult;
  var bResult;
  var index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value;
      var bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  var properties = keys(a);
  var index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  var properties = getStrictProperties(a);
  var index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var URL_TAG = "[object URL]";
var isArray = Array.isArray;
var isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a) {
  var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areErrorsEqual2 = _a.areErrorsEqual, areFunctionsEqual2 = _a.areFunctionsEqual, areMapsEqual2 = _a.areMapsEqual, areNumbersEqual2 = _a.areNumbersEqual, areObjectsEqual2 = _a.areObjectsEqual, arePrimitiveWrappersEqual2 = _a.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, areTypedArraysEqual2 = _a.areTypedArraysEqual, areUrlsEqual2 = _a.areUrlsEqual;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    var type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    var constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (isTypedArray != null && isTypedArray(a)) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    var tag = getTag(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a) {
  var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;
  var config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig) {
    config = assign({}, config, createCustomConfig(config));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a, b, state);
  };
}
function createIsEqual(_a) {
  var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;
  if (createState) {
    return function isEqual2(a, b) {
      var _a2 = createState(), _b = _a2.cache, cache2 = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta2 = _a2.meta;
      return comparator(a, b, {
        cache: cache2,
        equals,
        meta: meta2,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual2(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual2(a, b) {
    return comparator(a, b, state);
  };
}
createCustomEqual();
createCustomEqual({ strict: true });
createCustomEqual({ circular: true });
createCustomEqual({
  circular: true,
  strict: true
});
createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a = options2.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options2.createInternalComparator, createState = options2.createState, _b = options2.strict, strict = _b === void 0 ? false : _b;
  var config = createEqualityComparatorConfig(options2);
  var comparator = createEqualityComparator(config);
  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}
function arrayEqual(firstArray, secondArray, isEqual2 = (first, second) => first === second) {
  return firstArray.length === secondArray.length && firstArray.findIndex((val, i) => !isEqual2(secondArray[i], val)) === -1;
}
function arrayEqualAnyOrder(firstArray, secondArray) {
  if (firstArray.length !== secondArray.length) {
    return false;
  }
  return firstArray.every((firstVal) => secondArray.findIndex((secondVal) => deepEqualAnyOrder(firstVal, secondVal)) !== -1);
}
const deepEqualAnyOrder = createCustomEqual({
  createCustomConfig: (config) => {
    return {
      ...config,
      areArraysEqual: arrayEqualAnyOrder
    };
  }
});
const historyReducer = createReducer(getHistoryInitialState(), (builder) => {
  builder.addCase(snapshot, (state, action) => isEqual(state, action.payload) ? void 0 : action.payload);
});
const isEqual = (current2, next) => {
  return isContextEqual(current2.context, next.context) && isDictionaryFieldContextEqual(current2.dictionaryFieldContext, next.dictionaryFieldContext) && isAdvancedSearchQueriesEqual(current2.advancedSearchQueries, next.advancedSearchQueries) && isTabSetEqual(current2.tabSet, next.tabSet) && isStaticFilterSetEqual(current2.staticFilterSet, next.staticFilterSet) && isFacetsEqual(current2.facetSet, next.facetSet) && isFacetsEqual(current2.dateFacetSet, next.dateFacetSet) && isFacetsEqual(current2.numericFacetSet, next.numericFacetSet) && isAutomaticFacetsEqual(current2.automaticFacetSet, next.automaticFacetSet) && isCategoryFacetsEqual(current2.categoryFacetSet, next.categoryFacetSet) && isPaginationEqual(current2.pagination, next.pagination) && isQueryEqual(current2.query, next.query) && isSortEqual(current2, next) && isPipelineEqual(current2.pipeline, next.pipeline) && isSearchHubEqual(current2.searchHub, next.searchHub) && isFacetOrderEqual(current2.facetOrder, next.facetOrder) && isDebugEqual(current2.debug, next.debug);
};
const isContextEqual = (current2, next) => JSON.stringify(current2.contextValues) === JSON.stringify(next.contextValues);
const isDictionaryFieldContextEqual = (current2, next) => JSON.stringify(current2.contextValues) === JSON.stringify(next.contextValues);
const isTabSetEqual = (current2, next) => {
  const currentTab = findActiveTab(current2);
  const nextTab = findActiveTab(next);
  return currentTab?.id === nextTab?.id;
};
const findActiveTab = (tabSet) => {
  return Object.values(tabSet).find((tab) => tab.isActive);
};
const isStaticFilterSetEqual = (current2, next) => {
  for (const [id2, filter] of Object.entries(next)) {
    if (!current2[id2]) {
      return false;
    }
    const currentValues = getActiveStaticFilterValues(current2[id2]);
    const nextValues = getActiveStaticFilterValues(filter);
    if (JSON.stringify(currentValues) !== JSON.stringify(nextValues)) {
      return false;
    }
  }
  return true;
};
const getActiveStaticFilterValues = (filter) => {
  return filter.values.filter((value) => value.state !== "idle");
};
const isFacetsEqual = (current2, next) => {
  for (const [key, value] of Object.entries(next)) {
    if (!current2[key]) {
      return false;
    }
    const currentSelectedValues = current2[key].request.currentValues.filter((value2) => value2.state !== "idle");
    const nextSelectedValues = value.request.currentValues.filter((value2) => value2.state !== "idle");
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
const isCategoryFacetsEqual = (current2, next) => {
  for (const [key, value] of Object.entries(next)) {
    if (!current2[key]) {
      return false;
    }
    const currentSelectedValues = findActiveValueAncestry(current2[key]?.request.currentValues).map(({ value: value2 }) => value2);
    const nextSelectedValues = findActiveValueAncestry(value?.request.currentValues).map(({ value: value2 }) => value2);
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
const isAutomaticFacetsEqual = (current2, next) => {
  for (const [key, value] of Object.entries(next.set)) {
    if (!current2.set[key]) {
      return false;
    }
    const currentSelectedValues = current2.set[key].response.values.filter((value2) => value2.state !== "idle");
    const nextSelectedValues = value.response.values.filter((value2) => value2.state !== "idle");
    if (JSON.stringify(currentSelectedValues) !== JSON.stringify(nextSelectedValues)) {
      return false;
    }
  }
  return true;
};
const isPaginationEqual = (current2, next) => current2.firstResult === next.firstResult && current2.numberOfResults === next.numberOfResults;
const isQueryEqual = (current2, next) => JSON.stringify(current2) === JSON.stringify(next);
const isAdvancedSearchQueriesEqual = (current2, next) => JSON.stringify(current2) === JSON.stringify(next);
const isSortEqual = (current2, next) => current2.sortCriteria === next.sortCriteria;
const isPipelineEqual = (current2, next) => current2 === next;
const isSearchHubEqual = (current2, next) => current2 === next;
const isFacetOrderEqual = (current2, next) => arrayEqual(current2, next);
const isDebugEqual = (current2, next) => current2 === next;
const history$1 = undoable({
  actionTypes: {
    redo: redo$1.type,
    undo: undo$1.type,
    snapshot: snapshot.type
  },
  reducer: historyReducer
});
function buildHistoryManager(engine) {
  if (!loadHistoryManagerReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const canGoBack = (state) => {
    return state.past.length > 0 && !isNullOrUndefined(state.present);
  };
  return {
    ...controller,
    // TODO: https://coveord.atlassian.net/browse/KIT-2969:
    // Should be able to get rid of this local optimization following history management change
    subscribe(listener) {
      listener();
      let previous = JSON.stringify(getState().history.present);
      const strictListener = () => {
        const current2 = JSON.stringify(getState().history.present);
        const hasChanged = previous !== current2;
        if (hasChanged) {
          previous = current2;
          listener();
        }
      };
      return engine.subscribe(() => strictListener());
    },
    get state() {
      return getState().history;
    },
    async back() {
      if (!canGoBack(this.state)) {
        return;
      }
      await dispatch(back());
      dispatch(executeSearch$1({
        legacy: logNavigateBackward()
      }));
    },
    async forward() {
      if (!this.state.future.length || !this.state.present) {
        return;
      }
      await dispatch(forward());
      dispatch(executeSearch$1({
        legacy: logNavigateForward()
      }));
    },
    async backOnNoResults() {
      if (!canGoBack(this.state)) {
        return;
      }
      await dispatch(back());
      dispatch(executeSearch$1({
        legacy: logNoResultsBack()
      }));
    }
  };
}
function loadHistoryManagerReducers(engine) {
  engine.addReducers({ history: history$1, configuration, facetOrder: facetOrderReducer });
  return true;
}
const registerRecentResultsPayloadDefinition = {
  results: new ArrayValue({
    required: true,
    each: new RecordValue({ values: resultPartialDefinition })
  }),
  maxLength: new NumberValue({ required: true, min: 1, default: 10 })
};
const registerRecentResults = createAction("recentResults/registerRecentResults", (payload) => validatePayload(payload, registerRecentResultsPayloadDefinition));
const pushRecentResult = createAction("recentResults/pushRecentResult", (payload) => {
  validateResultPayload(payload);
  return {
    payload
  };
});
const clearRecentResults = createAction("recentResults/clearRecentResults");
function hasExpired(cached) {
  if (!cached) {
    return false;
  }
  return cached.expiresAt && Date.now() >= cached.expiresAt;
}
const registerInstantItem = (payload, state) => {
  const { id: id2 } = payload;
  if (state[id2]) {
    return;
  }
  state[id2] = { q: "", cache: {} };
  return state;
};
const updateInstantItemQuery = (payload, state) => {
  const { q, id: id2 } = payload;
  if (!q) {
    return;
  }
  state[id2].q = q;
};
const clearExpiredItems = (payload, state) => {
  const { id: id2 } = payload;
  Object.entries(state[id2].cache).forEach(([q, cached]) => {
    if (hasExpired(cached)) {
      delete state[id2].cache[q];
    }
  });
};
const fetchItemsPending = (payload, state, toSetEmptyIfNotFound) => {
  for (const id2 in state) {
    for (const query2 in state[id2].cache) {
      state[id2].cache[query2].isActive = false;
    }
  }
  if (!getCached(payload, state)) {
    makeEmptyCache(payload, state, toSetEmptyIfNotFound);
    return;
  }
  const cached = getCached(payload, state);
  cached.isLoading = true;
  cached.isActive = true;
  cached.error = null;
};
const fetchItemsFulfilled = (payload, state, toAddToCache) => {
  const { id: id2, q, searchUid, cacheTimeout, totalCountFiltered, duration } = payload;
  state[id2].cache[q] = {
    ...getCached(payload, state),
    ...toAddToCache,
    isActive: true,
    searchUid,
    isLoading: false,
    error: null,
    expiresAt: cacheTimeout ? cacheTimeout + Date.now() : 0,
    totalCountFiltered,
    duration
  };
};
const fetchItemsRejected = (payload, state) => {
  const { id: id2, q, error } = payload;
  state[id2].cache[q].error = error || null;
  state[id2].cache[q].isLoading = false;
  state[id2].cache[q].isActive = false;
};
const getCached = (payload, state) => {
  const { q, id: id2 } = payload;
  return state[id2].cache[q] || null;
};
const makeEmptyCache = (payload, state, setToEmpty) => {
  const { q, id: id2 } = payload;
  state[id2].cache[q] = {
    isLoading: true,
    error: null,
    expiresAt: 0,
    isActive: true,
    searchUid: "",
    totalCountFiltered: 0,
    duration: 0,
    ...setToEmpty
  };
};
function getInstantResultsInitialState() {
  return {};
}
const instantResultsReducer = createReducer(getInstantResultsInitialState(), (builder) => {
  builder.addCase(registerInstantResults, (state, action) => {
    registerInstantItem(action.payload, state);
  });
  builder.addCase(updateInstantResultsQuery, (state, action) => {
    updateInstantItemQuery(action.payload, state);
  });
  builder.addCase(clearExpiredResults, (state, action) => {
    clearExpiredItems(action.payload, state);
  });
  builder.addCase(fetchInstantResults.pending, (state, action) => {
    fetchItemsPending(action.meta.arg, state, { results: [] });
  });
  builder.addCase(fetchInstantResults.fulfilled, (state, action) => {
    const results = action.payload.results.map((result) => ({
      ...result,
      searchUid: action.payload.searchUid
    }));
    fetchItemsFulfilled({ ...action.payload, ...action.meta.arg }, state, {
      results
    });
  });
  builder.addCase(fetchInstantResults.rejected, (state, action) => {
    fetchItemsRejected(action.meta.arg, state);
  });
});
const instantResultsOptionDefinitions = {
  searchBoxId: nonEmptyString,
  maxResultsPerQuery: new NumberValue({
    required: true,
    min: 1
  }),
  cacheTimeout: new NumberValue()
};
const instantResultsOptionsSchema = new Schema(instantResultsOptionDefinitions);
function buildInstantResults(engine, props) {
  if (!loadInstantResultsReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options2 = {
    searchBoxId: props.options.searchBoxId || randomID("instant-results-"),
    cacheTimeout: props.options.cacheTimeout || 6e4,
    maxResultsPerQuery: props.options.maxResultsPerQuery
  };
  validateOptions(engine, instantResultsOptionsSchema, options2, "buildInstantResults");
  const searchBoxId = options2.searchBoxId;
  dispatch(registerInstantResults({ id: searchBoxId }));
  const getStateForSearchBox = () => getState().instantResults[searchBoxId];
  const getCached2 = (q) => getStateForSearchBox().cache[q];
  const getQ2 = () => getStateForSearchBox().q;
  const getResults = () => {
    const cached = getCached2(getQ2());
    if (!cached) {
      return [];
    }
    if (cached.isLoading) {
      return [];
    }
    return cached.results;
  };
  return {
    ...controller,
    updateQuery(q) {
      if (!q) {
        return;
      }
      const cached = getCached2(q);
      if (!cached || !cached.isLoading && (cached.error || hasExpired(cached))) {
        dispatch(fetchInstantResults({
          id: searchBoxId,
          q,
          maxResultsPerQuery: options2.maxResultsPerQuery,
          cacheTimeout: options2.cacheTimeout
        }));
      }
      dispatch(updateInstantResultsQuery({ id: searchBoxId, q }));
    },
    clearExpired() {
      dispatch(clearExpiredResults({
        id: searchBoxId
      }));
    },
    get state() {
      const q = getQ2();
      const cached = getCached2(q);
      return {
        q,
        isLoading: cached?.isLoading || false,
        error: cached?.error || null,
        results: getResults()
      };
    }
  };
}
function loadInstantResultsReducers(engine) {
  engine.addReducers({ instantResults: instantResultsReducer });
  return true;
}
const paginationReducer$1 = createReducer(getPaginationInitialState(), (builder) => {
  builder.addCase(registerNumberOfResults, (state, action) => {
    const page = determineCurrentPage(state);
    const newNumberOfResults = action.payload;
    state.defaultNumberOfResults = state.numberOfResults = newNumberOfResults;
    state.firstResult = calculateFirstResult(page, newNumberOfResults);
  }).addCase(updateNumberOfResults, (state, action) => {
    state.numberOfResults = action.payload;
    state.firstResult = 0;
  }).addCase(updateActiveTab, (state) => {
    state.firstResult = 0;
  }).addCase(registerPage, (state, action) => {
    const page = action.payload;
    state.firstResult = calculateFirstResult(page, state.numberOfResults);
  }).addCase(updatePage, (state, action) => {
    const page = action.payload;
    state.firstResult = calculateFirstResult(page, state.numberOfResults);
  }).addCase(previousPage$1, (state) => {
    const page = determineCurrentPage(state);
    const previousPage2 = Math.max(page - 1, minimumPage);
    state.firstResult = calculateFirstResult(previousPage2, state.numberOfResults);
  }).addCase(nextPage$1, (state) => {
    const page = determineCurrentPage(state);
    const maxPage = determineMaxPage(state);
    const nextPage2 = Math.min(page + 1, maxPage);
    state.firstResult = calculateFirstResult(nextPage2, state.numberOfResults);
  }).addCase(change.fulfilled, (state, action) => {
    if (action.payload) {
      state.numberOfResults = action.payload.pagination.numberOfResults;
      state.firstResult = action.payload.pagination.firstResult;
    }
  }).addCase(restoreSearchParameters$1, (state, action) => {
    state.firstResult = action.payload.firstResult ?? state.firstResult;
    state.numberOfResults = action.payload.numberOfResults ?? state.defaultNumberOfResults;
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    const { response } = action.payload;
    state.totalCountFiltered = response.totalCountFiltered;
  }).addCase(deselectAllFacetValues, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleExcludeDateFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleExcludeFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleExcludeNumericFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(excludeFacetSearchResult, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleSelectFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(deselectAllCategoryFacetValues, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleSelectCategoryFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(selectCategoryFacetSearchResult, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleSelectDateFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleSelectNumericFacetValue$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(deselectAllBreadcrumbs, (state) => {
    handlePaginationReset$1(state);
  }).addCase(updateDateFacetValues$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(updateNumericFacetValues$1, (state) => {
    handlePaginationReset$1(state);
  }).addCase(selectFacetSearchResult, (state) => {
    handlePaginationReset$1(state);
  }).addCase(toggleSelectAutomaticFacetValue, (state) => {
    handlePaginationReset$1(state);
  });
});
function handlePaginationReset$1(state) {
  state.firstResult = getPaginationInitialState().firstResult;
}
function determineCurrentPage(state) {
  const { firstResult, numberOfResults } = state;
  return calculatePage(firstResult, numberOfResults);
}
function determineMaxPage(state) {
  const { totalCountFiltered, numberOfResults } = state;
  return calculateMaxPage(totalCountFiltered, numberOfResults);
}
function calculateFirstResult(page, numberOfResults) {
  return (page - 1) * numberOfResults;
}
function calculatePage(firstResult, numberOfResults) {
  return Math.round(firstResult / numberOfResults) + 1;
}
function calculateMaxPage(totalCountFiltered, numberOfResults) {
  const totalCount = Math.min(totalCountFiltered, maximumNumberOfResultsFromIndex);
  return Math.ceil(totalCount / numberOfResults);
}
function firstResultSelector(state) {
  return state.pagination.firstResult;
}
function numberOfResultsSelector(state) {
  return state.pagination.numberOfResults;
}
function totalCountFilteredSelector(state) {
  return state.pagination.totalCountFiltered;
}
const currentPageSelector = (state) => {
  const firstResult = firstResultSelector(state);
  const numberOfResults = numberOfResultsSelector(state);
  return calculatePage(firstResult, numberOfResults);
};
const maxPageSelector = (state) => {
  const totalCountFiltered = totalCountFilteredSelector(state);
  const numberOfResults = numberOfResultsSelector(state);
  return calculateMaxPage(totalCountFiltered, numberOfResults);
};
const currentPagesSelector = (state, desiredNumberOfPages) => {
  const page = currentPageSelector(state);
  const maxPage = maxPageSelector(state);
  let range = buildRange(page, desiredNumberOfPages);
  range = shiftRightIfNeeded(range);
  range = shiftLeftIfNeeded(range, maxPage);
  return buildCurrentPages(range);
};
function buildRange(page, desiredNumberOfPages) {
  const isEven = desiredNumberOfPages % 2 === 0;
  const leftCapacity = Math.floor(desiredNumberOfPages / 2);
  const rightCapacity = isEven ? leftCapacity - 1 : leftCapacity;
  const start = page - leftCapacity;
  const end = page + rightCapacity;
  return { start, end };
}
function shiftRightIfNeeded(range) {
  const leftExcess = Math.max(minimumPage - range.start, 0);
  const start = range.start + leftExcess;
  const end = range.end + leftExcess;
  return { start, end };
}
function shiftLeftIfNeeded(range, maxPage) {
  const rightExcess = Math.max(range.end - maxPage, 0);
  const start = Math.max(range.start - rightExcess, minimumPage);
  const end = range.end - rightExcess;
  return { start, end };
}
function buildCurrentPages(range) {
  const currentPages = [];
  for (let counter = range.start; counter <= range.end; ++counter) {
    currentPages.push(counter);
  }
  return currentPages;
}
const logPagerResize = () => makeAnalyticsAction("analytics/pager/resize", (client, state) => client.makePagerResize({
  currentResultsPerPage: state.pagination?.numberOfResults || getPaginationInitialState().numberOfResults
}));
const logPageNumber = () => makeAnalyticsAction("analytics/pager/number", (client, state) => client.makePagerNumber({
  pagerNumber: currentPageSelector(state)
}));
const logPageNext = () => makeAnalyticsAction("analytics/pager/next", (client, state) => client.makePagerNext({
  pagerNumber: currentPageSelector(state)
}));
const logPagePrevious = () => makeAnalyticsAction("analytics/pager/previous", (client, state) => client.makePagerPrevious({
  pagerNumber: currentPageSelector(state)
}));
const browseResults = () => ({
  actionCause: SearchPageEvents.browseResults
});
const optionsSchema$6 = new Schema({
  numberOfPages: new NumberValue({ default: 5, min: 0 })
});
const initialStateSchema$8 = new Schema({
  page: new NumberValue({ min: 1 })
});
function buildCorePager(engine, props = {}) {
  if (!loadPagerReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const options2 = validateOptions(engine, optionsSchema$6, props.options, "buildPager");
  const initialState2 = validateInitialState(engine, initialStateSchema$8, props.initialState, "buildPager");
  const page = initialState2.page;
  if (page) {
    dispatch(registerPage(page));
  }
  const getCurrentPage = () => {
    return currentPageSelector(engine.state);
  };
  const getCurrentPages = () => {
    const { numberOfPages } = options2;
    return currentPagesSelector(engine.state, numberOfPages);
  };
  const getMaxPage = () => {
    return maxPageSelector(engine.state);
  };
  return {
    ...controller,
    get state() {
      const currentPage = getCurrentPage();
      const maxPage = getMaxPage();
      const hasPreviousPage = currentPage > minimumPage && maxPage > 0;
      const hasNextPage = currentPage < maxPage;
      return {
        currentPage,
        currentPages: getCurrentPages(),
        maxPage,
        hasPreviousPage,
        hasNextPage
      };
    },
    selectPage(page2) {
      dispatch(updatePage(page2));
    },
    nextPage() {
      dispatch(nextPage$1());
    },
    previousPage() {
      dispatch(previousPage$1());
    },
    isCurrentPage(page2) {
      return page2 === this.state.currentPage;
    }
  };
}
function loadPagerReducers(engine) {
  engine.addReducers({ configuration, pagination: paginationReducer$1 });
  return true;
}
function buildPager(engine, props = {}) {
  const { dispatch } = engine;
  const pager = buildCorePager(engine, props);
  return {
    ...pager,
    get state() {
      return pager.state;
    },
    selectPage(page) {
      pager.selectPage(page);
      dispatch(fetchPage({ legacy: logPageNumber(), next: browseResults() }));
    },
    nextPage() {
      pager.nextPage();
      dispatch(fetchPage({ legacy: logPageNext(), next: browseResults() }));
    },
    previousPage() {
      pager.previousPage();
      dispatch(fetchPage({ legacy: logPagePrevious(), next: browseResults() }));
    }
  };
}
function buildCoreQueryError(engine) {
  if (!loadQueryErrorReducers(engine)) ;
  const controller = buildController(engine);
  const getState = () => engine.state;
  return {
    ...controller,
    get state() {
      return {
        hasError: getState().search.error !== null,
        error: getState().search.error
      };
    }
  };
}
function loadQueryErrorReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}
function buildQueryError(engine) {
  return buildCoreQueryError(engine);
}
function buildCoreQuerySummary(engine) {
  if (!loadQuerySummaryReducers(engine)) ;
  const controller = buildController(engine);
  const searchStatus = buildCoreStatus(engine);
  const getState = () => engine.state;
  const durationInSeconds = () => {
    const inSeconds = getState().search.duration / 1e3;
    return Math.round((inSeconds + Number.EPSILON) * 100) / 100;
  };
  return {
    ...controller,
    get state() {
      return {
        ...searchStatus.state,
        durationInMilliseconds: getState().search.duration,
        durationInSeconds: durationInSeconds(),
        firstResult: getState().pagination.firstResult + 1,
        hasDuration: getState().search.duration !== 0,
        hasQuery: getState().search.queryExecuted !== "",
        lastResult: getState().pagination.firstResult + getState().search.results.length,
        query: getState().search.queryExecuted,
        total: getState().pagination.totalCountFiltered
      };
    }
  };
}
function loadQuerySummaryReducers(engine) {
  engine.addReducers({ search: searchReducer, pagination: paginationReducer$1 });
  return true;
}
function buildQuerySummary(engine) {
  return buildCoreQuerySummary(engine);
}
async function buildResultPreviewRequest(state, options2) {
  const { search, accessToken, organizationId } = state.configuration;
  const q = state.query?.q || "";
  return {
    url: search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    accessToken,
    organizationId,
    enableNavigation: false,
    q,
    ...options2,
    requestedOutputSize: options2.requestedOutputSize || 0,
    ...search.authenticationProviders.length && {
      authentication: search.authenticationProviders.join(",")
    }
  };
}
const fetchResultContent = createAsyncThunk("resultPreview/fetchResultContent", async (options2, { extra, getState, rejectWithValue }) => {
  const state = getState();
  const req2 = await buildResultPreviewRequest(state, options2);
  const res2 = await extra.apiClient.html(req2);
  if (isErrorResponse$1(res2)) {
    return rejectWithValue(res2.error);
  }
  return {
    content: res2.success,
    uniqueId: options2.uniqueId
  };
});
const nextPreview = createAction("resultPreview/next");
const previousPreview = createAction("resultPreview/previous");
const preparePreviewPagination = createAction("resultPreview/prepare", (payload) => validatePayload(payload, { results: new ArrayValue({ required: true }) }));
const MAX_GET_LENGTH = 2048;
const updateContentURL = createAsyncThunk("resultPreview/updateContentURL", async (options2, { getState, extra }) => {
  const state = getState();
  const contentURL = buildContentURL(await options2.buildResultPreviewRequest(state, {
    uniqueId: options2.uniqueId,
    requestedOutputSize: options2.requestedOutputSize
  }), options2.path);
  if (contentURL?.length > MAX_GET_LENGTH) {
    extra.logger.error(`The content URL was truncated as it exceeds the maximum allowed length of ${MAX_GET_LENGTH} characters.`);
  }
  return {
    contentURL
  };
});
const logDocumentQuickview = (result) => {
  return makeAnalyticsAction({
    prefix: "analytics/resultPreview/open",
    __legacy__getBuilder: (client, state) => {
      validateResultPayload(result);
      const info = partialDocumentInformation(result, state);
      const id2 = documentIdentifier(result);
      return client.makeDocumentQuickview(info, id2);
    },
    analyticsType: "itemClick",
    analyticsPayloadBuilder: (state) => {
      const docInfo = partialDocumentInformation(result, state);
      const docId = documentIdentifier(result);
      return {
        responseId: result.searchUid ?? "",
        position: docInfo.documentPosition,
        itemMetadata: {
          uniqueFieldName: docId.contentIDKey,
          uniqueFieldValue: docId.contentIDValue,
          title: docInfo.documentTitle,
          author: docInfo.documentAuthor,
          url: docInfo.documentUrl
        }
      };
    }
  });
};
function getResultPreviewInitialState() {
  return {
    uniqueId: "",
    content: "",
    isLoading: false,
    position: -1,
    resultsWithPreview: []
  };
}
const resetPreviewContentState = (state) => {
  const { content, isLoading, uniqueId, contentURL } = getResultPreviewInitialState();
  state.content = content;
  state.isLoading = isLoading;
  state.uniqueId = uniqueId;
  state.contentURL = contentURL;
};
const getUniqueIdsOfResultsWithHTMLVersion = (results) => results.filter((r) => r.hasHtmlVersion).map((r) => r.uniqueId);
const resultPreviewReducer = createReducer(getResultPreviewInitialState(), (builder) => {
  builder.addCase(fetchResultContent.pending, (state) => {
    state.isLoading = true;
  }).addCase(fetchResultContent.fulfilled, (state, action) => {
    const { content, uniqueId } = action.payload;
    state.position = state.resultsWithPreview.indexOf(uniqueId);
    state.content = content;
    state.uniqueId = uniqueId;
    state.isLoading = false;
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    resetPreviewContentState(state);
    state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(action.payload.response.results);
  }).addCase(fetchMoreResults.fulfilled, (state, action) => {
    resetPreviewContentState(state);
    state.resultsWithPreview = state.resultsWithPreview.concat(getUniqueIdsOfResultsWithHTMLVersion(action.payload.response.results));
  }).addCase(fetchPage.fulfilled, resetPreviewContentState).addCase(preparePreviewPagination, (state, action) => {
    state.resultsWithPreview = getUniqueIdsOfResultsWithHTMLVersion(action.payload.results);
  }).addCase(nextPreview, (state) => {
    if (state.isLoading) {
      return;
    }
    let newPos = state.position + 1;
    if (newPos > state.resultsWithPreview.length - 1) {
      newPos = 0;
    }
    state.position = newPos;
  }).addCase(previousPreview, (state) => {
    if (state.isLoading) {
      return;
    }
    let newPos = state.position - 1;
    if (newPos < 0) {
      newPos = state.resultsWithPreview.length - 1;
    }
    state.position = newPos;
  }).addCase(updateContentURL.fulfilled, (state, action) => {
    state.contentURL = action.payload.contentURL;
  });
});
function buildCoreQuickview(engine, props, buildResultPreviewRequest2, path, fetchResultContentCallback) {
  if (!loadQuickviewReducers(engine)) ;
  const { dispatch } = engine;
  const getState = () => engine.state;
  const controller = buildController(engine);
  const { result, maximumPreviewSize } = props.options;
  const getUniqueIdFromPosition = () => {
    const { resultsWithPreview, position } = getState().resultPreview;
    return resultsWithPreview[position];
  };
  const onFetchContent = (uniqueId) => {
    dispatch(updateContentURL({
      uniqueId,
      requestedOutputSize: maximumPreviewSize,
      buildResultPreviewRequest: buildResultPreviewRequest2,
      path
    }));
    if (!props.options.onlyContentURL) {
      dispatch(fetchResultContent({
        uniqueId,
        requestedOutputSize: maximumPreviewSize
      }));
    }
    if (fetchResultContentCallback) {
      fetchResultContentCallback();
    }
  };
  return {
    ...controller,
    fetchResultContent() {
      onFetchContent(result.uniqueId);
    },
    next() {
      dispatch(nextPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    previous() {
      dispatch(previousPreview());
      onFetchContent(getUniqueIdFromPosition());
    },
    get state() {
      const state = getState();
      const resultHasPreview = result.hasHtmlVersion;
      const preview = state.resultPreview;
      const content = result.uniqueId === preview.uniqueId ? preview.content : "";
      const isLoading = preview.isLoading;
      const contentURL = preview.contentURL;
      const currentResultUniqueId = getUniqueIdFromPosition();
      return {
        content,
        resultHasPreview,
        isLoading,
        contentURL,
        currentResultUniqueId
      };
    }
  };
}
function loadQuickviewReducers(engine) {
  engine.addReducers({ configuration, resultPreview: resultPreviewReducer });
  return true;
}
function buildQuickview(engine, props) {
  if (!loadSearchQuickviewReducers(engine)) ;
  const { dispatch } = engine;
  const getState = () => engine.state;
  const getResults = () => getState().search.results;
  const fetchResultContentCallback = () => {
    engine.dispatch(logDocumentQuickview(props.options.result));
  };
  const path = "/html";
  const core = buildCoreQuickview(engine, props, buildResultPreviewRequest, path, fetchResultContentCallback);
  dispatch(preparePreviewPagination({ results: getResults() }));
  return {
    ...core,
    get state() {
      return {
        ...core.state,
        currentResult: getResults().findIndex((r) => r.uniqueId === core.state.currentResultUniqueId) + 1,
        totalResults: getResults().length
      };
    }
  };
}
function loadSearchQuickviewReducers(engine) {
  engine.addReducers({ search: searchReducer });
  return true;
}
const logClearRecentQueries = () => makeAnalyticsAction("analytics/recentQueries/clear", (client) => {
  return client.makeClearRecentQueries();
});
const logRecentQueryClick = () => makeAnalyticsAction("analytics/recentQueries/click", (client) => {
  return client.makeRecentQueryClick();
});
const registerRecentQueriesPayloadDefinition = {
  queries: new ArrayValue({
    required: true,
    each: new StringValue({ emptyAllowed: false })
  }),
  maxLength: new NumberValue({ required: true, min: 1, default: 10 })
};
const registerRecentQueries$1 = createAction("recentQueries/registerRecentQueries", (payload) => validatePayload(payload, registerRecentQueriesPayloadDefinition));
const clearRecentQueries$1 = createAction("recentQueries/clearRecentQueries");
function getRecentQueriesInitialState() {
  return {
    queries: [],
    maxLength: 10
  };
}
const recentQueriesReducer = createReducer(getRecentQueriesInitialState(), (builder) => {
  builder.addCase(registerRecentQueries$1, handleRegisterQueries).addCase(clearRecentQueries$1, handleClearRecentQueries).addCase(executeSearch$1.fulfilled, (state, action) => {
    const query2 = action.payload.queryExecuted;
    const results = action.payload.response.results;
    if (!query2.length || !results.length) {
      return;
    }
    handleExecuteSearchFulfilled(query2, state);
  });
});
function handleRegisterQueries(state, action) {
  state.queries = Array.from(new Set(action.payload.queries.map((query2) => query2.trim().toLowerCase()))).slice(0, action.payload.maxLength);
  state.maxLength = action.payload.maxLength;
}
function handleClearRecentQueries(state) {
  state.queries = [];
}
function handleExecuteSearchFulfilled(query2, state) {
  const cleanNewQuery = query2.trim().toLowerCase();
  if (cleanNewQuery === "") {
    return;
  }
  const previousQueries = Array.from(new Set(state.queries.filter((query3) => query3.trim().toLowerCase() !== cleanNewQuery))).slice(0, state.maxLength - 1);
  state.queries = [cleanNewQuery, ...previousQueries];
}
const defaultRecentQueriesState = {
  queries: []
};
const defaultRecentQueriesOptions = {
  maxLength: 10,
  clearFilters: true
};
const initialStateSchema$7 = new Schema({
  queries: new ArrayValue({ required: true })
});
const optionsSchema$5 = new Schema({
  maxLength: new NumberValue({ required: true, min: 1 }),
  clearFilters: new BooleanValue()
});
function validateRecentQueriesProps(engine, props) {
  validateOptions(engine, optionsSchema$5, props?.options, "buildRecentQueriesList");
  validateInitialState(engine, initialStateSchema$7, props?.initialState, "buildRecentQueriesList");
}
function buildCoreRecentQueriesList(engine, props) {
  if (!loadRecentQueriesListReducer(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const registrationOptions = {
    ...defaultRecentQueriesOptions,
    ...props?.options
  };
  const registrationState = {
    ...defaultRecentQueriesState,
    ...props?.initialState
  };
  validateRecentQueriesProps(engine, {
    options: registrationOptions,
    initialState: registrationState
  });
  const options2 = {
    queries: registrationState.queries,
    maxLength: registrationOptions.maxLength
  };
  dispatch(registerRecentQueries$1(options2));
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        ...state.recentQueries,
        analyticsEnabled: state.configuration.analytics.enabled
      };
    },
    clear() {
      dispatch(clearRecentQueries$1());
    },
    updateRecentQueries(queries) {
      const errorMessage = new ArrayValue({
        required: true,
        each: new StringValue({ required: true }),
        min: 1
      }).validate(queries);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      dispatch(registerRecentQueries$1({
        queries,
        maxLength: registrationOptions.maxLength
      }));
    },
    executeRecentQuery(index) {
      const errorMessage = new NumberValue({
        required: true,
        min: 0,
        max: this.state.queries.length
      }).validate(index);
      if (errorMessage) {
        throw new Error(errorMessage);
      }
      const queryOptions = {
        q: this.state.queries[index],
        clearFilters: registrationOptions.clearFilters
      };
      if (isBoolean$1(engine.state.query?.enableQuerySyntax)) {
        queryOptions.enableQuerySyntax = engine.state.query.enableQuerySyntax;
      }
      dispatch(prepareForSearchWithQuery(queryOptions));
    }
  };
}
function loadRecentQueriesListReducer(engine) {
  engine.addReducers({ search: searchReducer, recentQueries: recentQueriesReducer, query: queryReducer$1 });
  return true;
}
function buildRecentQueriesList(engine, props) {
  const coreController = buildCoreRecentQueriesList(engine, props);
  const { dispatch } = engine;
  return {
    ...coreController,
    get state() {
      return coreController.state;
    },
    clear() {
      dispatch(logClearRecentQueries());
      coreController.clear();
    },
    executeRecentQuery(index) {
      coreController.executeRecentQuery(index);
      dispatch(executeSearch$1({
        legacy: logRecentQueryClick()
      }));
    }
  };
}
const logClearRecentResults = () => makeAnalyticsAction("analytics/recentResults/clear", (client) => client.makeClearRecentResults());
function getRecentResultsInitialState() {
  return {
    results: [],
    maxLength: 10
  };
}
const recentResultsReducer = createReducer(getRecentResultsInitialState(), (builder) => {
  builder.addCase(registerRecentResults, (state, action) => {
    state.results = action.payload.results.slice(0, action.payload.maxLength);
    state.maxLength = action.payload.maxLength;
  }).addCase(clearRecentResults, (state) => {
    state.results = [];
  }).addCase(pushRecentResult, (state, action) => {
    const result = action.payload;
    state.results = state.results.filter((r) => r.uniqueId !== result.uniqueId);
    const remaining = state.results.slice(0, state.maxLength - 1);
    state.results = [result, ...remaining];
  });
});
const defaultRecentResultsProps = {
  initialState: {
    results: []
  },
  options: {
    maxLength: 10
  }
};
const initialStateSchema$6 = new Schema({
  results: new ArrayValue({ required: true })
});
const optionsSchema$4 = new Schema({
  maxLength: new NumberValue({ required: true, min: 1 })
});
function validateRecentResultsProps(engine, props) {
  validateOptions(engine, optionsSchema$4, props?.options, "buildRecentResultsList");
  validateInitialState(engine, initialStateSchema$6, props?.initialState, "buildRecentResultsList");
}
function buildRecentResultsList(engine, props) {
  if (!loadRecentResultsListReducer(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const registrationProps = {
    ...defaultRecentResultsProps,
    ...props
  };
  validateRecentResultsProps(engine, registrationProps);
  const options2 = {
    results: registrationProps.initialState.results,
    maxLength: registrationProps.options.maxLength
  };
  dispatch(registerRecentResults(options2));
  return {
    ...controller,
    get state() {
      return getState().recentResults;
    },
    clear() {
      dispatch(logClearRecentResults());
      dispatch(clearRecentResults());
    }
  };
}
function loadRecentResultsListReducer(engine) {
  engine.addReducers({ recentResults: recentResultsReducer });
  return true;
}
const parseRankingInfo = (value) => {
  const REGEX_EXTRACT_DOCUMENT_WEIGHTS = /Document weights:\n((?:.)*?)\n+/g;
  const REGEX_EXTRACT_TERMS_WEIGHTS = /Terms weights:\n((?:.|\n)*)\n+/g;
  const REGEX_EXTRACT_TOTAL_WEIGHTS = /Total weight: ([0-9]+)/g;
  if (!value) {
    return null;
  }
  const docWeightsRegexResult = REGEX_EXTRACT_DOCUMENT_WEIGHTS.exec(value);
  const termsWeightRegexResult = REGEX_EXTRACT_TERMS_WEIGHTS.exec(value);
  const totalWeightRegexResult = REGEX_EXTRACT_TOTAL_WEIGHTS.exec(value);
  const qreWeights = parseQREWeights(value);
  const documentWeights = parseWeights(docWeightsRegexResult ? docWeightsRegexResult[1] : null);
  const termsWeight = parseTermsWeights(termsWeightRegexResult);
  const totalWeight = totalWeightRegexResult ? Number(totalWeightRegexResult[1]) : null;
  return {
    documentWeights,
    termsWeight,
    totalWeight,
    qreWeights
  };
};
const parseWeights = (value) => {
  const REGEX_EXTRACT_LIST_OF_WEIGHTS = /(\w+(?:\s\w+)*): ([-0-9]+)/g;
  const REGEX_EXTRACT_WEIGHT_GROUP = /^(\w+(?:\s\w+)*): ([-0-9]+)$/;
  if (!value) {
    return null;
  }
  const listOfWeight = value.match(REGEX_EXTRACT_LIST_OF_WEIGHTS);
  if (!listOfWeight) {
    return null;
  }
  const weights = {};
  for (const weight of listOfWeight) {
    const weightGroup = weight.match(REGEX_EXTRACT_WEIGHT_GROUP);
    if (weightGroup) {
      const weightAppliedOn = weightGroup[1];
      const weightValue = weightGroup[2];
      weights[weightAppliedOn] = Number(weightValue);
    }
  }
  return weights;
};
const matchExec = (value, regex) => {
  const results = [];
  let arr;
  while (true) {
    arr = regex.exec(value);
    if (arr === null) {
      break;
    }
    results.push(arr);
  }
  return results;
};
const parseTermsWeights = (termsWeight) => {
  const REGEX_EXTRACT_GROUP_OF_TERMS = /((?:[^:]+: [0-9]+, [0-9]+; )+)\n((?:\w+: [0-9]+; )+)/g;
  const REGEX_EXTRACT_SINGLE_TERM = /([^:]+): ([0-9]+), ([0-9]+); /g;
  if (!termsWeight || !termsWeight[1]) {
    return null;
  }
  const listOfTerms = matchExec(termsWeight[1], REGEX_EXTRACT_GROUP_OF_TERMS);
  if (!listOfTerms) {
    return null;
  }
  const terms = {};
  for (const term of listOfTerms) {
    const listOfWords = matchExec(term[1], REGEX_EXTRACT_SINGLE_TERM);
    const words = {};
    for (const word of listOfWords) {
      words[word[1]] = {
        Correlation: Number(word[2]),
        "TF-IDF": Number(word[3])
      };
    }
    const weights = parseWeights(term[2]);
    terms[Object.keys(words).join(", ")] = {
      terms: words,
      Weights: weights
    };
  }
  return terms;
};
const parseQREWeights = (value) => {
  const REGEX_EXTRACT_QRE_WEIGHTS = /(Expression:\s".*")\sScore:\s(?!0)([-0-9]+)\n+/g;
  let qreWeightsRegexResult = REGEX_EXTRACT_QRE_WEIGHTS.exec(value);
  const qreWeights = [];
  while (qreWeightsRegexResult) {
    qreWeights.push({
      expression: qreWeightsRegexResult[1],
      score: parseInt(qreWeightsRegexResult[2], 10)
    });
    qreWeightsRegexResult = REGEX_EXTRACT_QRE_WEIGHTS.exec(value);
  }
  return qreWeights;
};
function rankingInformationSelector(state) {
  const results = state.search.response.results;
  return results.map((result) => {
    const ranking = parseRankingInfo(result.rankingInfo);
    return {
      result,
      ranking
    };
  });
}
const initialStateSchema$5 = new Schema({
  enabled: new BooleanValue({ default: false })
});
function buildRelevanceInspector(engine, props = {}) {
  if (!loadRelevanceInspectorReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const initialState2 = validateInitialState(engine, initialStateSchema$5, props.initialState, "buildRelevanceInspector");
  if (initialState2.enabled) {
    dispatch(enableDebug());
  }
  const warnProductionEnvironment = (flag) => {
    engine.logger.warn(`Flag [ ${flag} ] is now activated. This should *not* be used in any production environment as it negatively impact performance.`);
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      const isEnabled = state.debug;
      if (!state.debug) {
        return { isEnabled };
      }
      const { executionReport, basicExpression, advancedExpression, constantExpression, userIdentities, rankingExpressions } = state.search.response;
      const { fieldsDescription, fetchAllFields } = state.fields;
      return {
        isEnabled,
        rankingInformation: rankingInformationSelector(state),
        executionReport,
        expressions: {
          basicExpression,
          advancedExpression,
          constantExpression
        },
        userIdentities,
        rankingExpressions,
        fieldsDescription,
        fetchAllFields
      };
    },
    enable() {
      dispatch(enableDebug());
      warnProductionEnvironment("debug");
    },
    disable() {
      dispatch(disableDebug());
      dispatch(disableFetchAllFields());
    },
    enableFetchAllFields() {
      dispatch(enableFetchAllFields());
      warnProductionEnvironment("fetchAllFields");
    },
    disableFetchAllFields() {
      dispatch(disableFetchAllFields());
    },
    fetchFieldsDescription() {
      !this.state.isEnabled && dispatch(enableDebug());
      dispatch(fetchFieldsDescription());
      warnProductionEnvironment("fieldsDescription");
      engine.logger.warn(`For production environment, please specify the necessary fields either when instantiating a ResultList controller, or by dispatching a registerFieldsToInclude action.
        
        https://docs.coveo.com/en/headless/latest/reference/interfaces/Search.ResultListOptions.html
        https://docs.coveo.com/en/headless/latest/reference/interfaces/Search.FieldActionCreators.html#registerfieldstoinclude`);
    }
  };
}
function loadRelevanceInspectorReducers(engine) {
  engine.addReducers({
    debug: debugReducer,
    search: searchReducer,
    configuration,
    fields: fieldsReducer
  });
  return true;
}
const logDocumentOpen = (result) => makeAnalyticsAction({
  prefix: "analytics/result/open",
  __legacy__getBuilder: (client, state) => {
    validateResultPayload(result);
    return client.makeDocumentOpen(partialDocumentInformation(result, state), documentIdentifier(result));
  },
  analyticsType: "itemClick",
  analyticsPayloadBuilder: (state) => {
    const docInfo = partialDocumentInformation(result, state);
    const docId = documentIdentifier(result);
    return {
      responseId: result.searchUid ?? "",
      position: docInfo.documentPosition,
      itemMetadata: {
        uniqueFieldName: docId.contentIDKey,
        uniqueFieldValue: docId.contentIDValue,
        title: docInfo.documentTitle,
        author: docInfo.documentAuthor,
        url: docInfo.documentUrl
      }
    };
  }
});
function buildInteractiveResult(engine, props) {
  let wasOpened = false;
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(logDocumentOpen(props.options.result));
  };
  const action = () => {
    logAnalyticsIfNeverOpened();
    engine.dispatch(pushRecentResult(props.options.result));
  };
  return buildInteractiveResultCore(engine, props, action);
}
function buildResultList(engine, props) {
  return buildCoreResultList(engine, {
    ...props,
    fetchMoreResultsActionCreator: fetchMoreResults
  });
}
const initialStateSchema$4 = new Schema({
  numberOfResults: new NumberValue({ min: 0 })
});
function buildCoreResultsPerPage(engine, props = {}) {
  if (!loadResultsPerPageReducers$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const validated = validateInitialState(engine, initialStateSchema$4, props.initialState, "buildResultsPerPage");
  const num = validated.numberOfResults;
  if (num !== void 0) {
    dispatch(registerNumberOfResults(num));
  }
  return {
    ...controller,
    get state() {
      return {
        numberOfResults: getState().pagination.numberOfResults
      };
    },
    set(num2) {
      dispatch(updateNumberOfResults(num2));
    },
    isSetTo(num2) {
      return num2 === this.state.numberOfResults;
    }
  };
}
function loadResultsPerPageReducers$1(engine) {
  engine.addReducers({ pagination: paginationReducer$1, configuration });
  return true;
}
function buildResultsPerPage(engine, props = {}) {
  if (!loadResultsPerPageReducers(engine)) ;
  const coreController = buildCoreResultsPerPage(engine, props);
  const { dispatch } = engine;
  return {
    ...coreController,
    get state() {
      return {
        ...coreController.state
      };
    },
    set(num) {
      coreController.set(num);
      dispatch(fetchPage({ legacy: logPagerResize(), next: browseResults() }));
    }
  };
}
function loadResultsPerPageReducers(engine) {
  engine.addReducers({ pagination: paginationReducer$1, configuration });
  return true;
}
const logSearchboxSubmit = () => makeAnalyticsAction("analytics/searchbox/submit", (client) => client.makeSearchboxSubmit());
const searchboxSubmit = () => ({
  actionCause: SearchPageEvents.searchboxSubmit
});
const querySetDefinition = {
  id: requiredNonEmptyString,
  query: requiredEmptyAllowedString
};
const registerQuerySetQuery$1 = createAction("querySet/register", (payload) => validatePayload(payload, querySetDefinition));
const updateQuerySetQuery$1 = createAction("querySet/update", (payload) => validatePayload(payload, querySetDefinition));
const registerQuerySetQuery = createAction("commerce/querySet/register", (payload) => validatePayload(payload, querySetDefinition));
const updateQuerySetQuery = createAction("commerce/querySet/update", (payload) => validatePayload(payload, querySetDefinition));
const querySetReducer = createReducer(getQuerySetInitialState(), (builder) => {
  builder.addCase(registerQuerySetQuery$1, (state, action) => registerQuery(state, action.payload)).addCase(registerQuerySetQuery, (state, action) => registerQuery(state, action.payload)).addCase(updateQuerySetQuery$1, (state, action) => {
    const { id: id2, query: query2 } = action.payload;
    updateQuery(state, id2, query2);
  }).addCase(updateQuerySetQuery, (state, action) => {
    const { id: id2, query: query2 } = action.payload;
    updateQuery(state, id2, query2);
  }).addCase(selectQuerySuggestion, (state, action) => {
    const { id: id2, expression } = action.payload;
    updateQuery(state, id2, expression);
  }).addCase(selectQuerySuggestion$1, (state, action) => {
    const { id: id2, expression } = action.payload;
    updateQuery(state, id2, expression);
  }).addCase(executeSearch.fulfilled, (state, action) => {
    const { queryExecuted } = action.payload;
    updateAllQuerySetQuery(state, queryExecuted);
  }).addCase(executeSearch$1.fulfilled, (state, action) => {
    const { queryExecuted } = action.payload;
    updateAllQuerySetQuery(state, queryExecuted);
  }).addCase(restoreSearchParameters$1, handleRestoreSearchParameters).addCase(restoreSearchParameters, handleRestoreSearchParameters).addCase(change.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    for (const [id2, query2] of Object.entries(action.payload.querySet)) {
      updateQuery(state, id2, query2);
    }
  });
});
function handleRestoreSearchParameters(state, action) {
  if (!isNullOrUndefined(action.payload.q)) {
    updateAllQuerySetQuery(state, action.payload.q);
  }
}
function updateAllQuerySetQuery(state, query2) {
  Object.keys(state).forEach((id2) => {
    state[id2] = query2;
  });
}
const updateQuery = (state, id2, query2) => {
  if (id2 in state) {
    state[id2] = query2;
  }
};
const registerQuery = (state, actionPayload) => {
  const { id: id2, query: query2 } = actionPayload;
  if (id2 in state) {
    return;
  }
  state[id2] = query2;
};
const logQuerySuggestionClick = (payload) => makeAnalyticsAction("analytics/querySuggest", (client, state) => {
  const metadata = buildOmniboxSuggestionMetadata(state, payload);
  return client.makeOmniboxAnalytics(metadata);
});
const omniboxAnalytics = () => ({
  actionCause: SearchPageEvents.omniboxAnalytics
});
function buildOmniboxSuggestionMetadata(state, payload) {
  const { id: id2, suggestion } = payload;
  const querySuggest = state.querySuggest?.[id2];
  if (!querySuggest) {
    throw new Error(`Unable to determine the query suggest analytics metadata to send because no query suggest with id "${id2}" was found. Please check the sent #id.`);
  }
  const suggestions = querySuggest.completions.map((completion) => completion.expression);
  const lastIndex = querySuggest.partialQueries.length - 1;
  const partialQuery = querySuggest.partialQueries[lastIndex] || "";
  const querySuggestResponseId = querySuggest.responseId;
  return {
    suggestionRanking: suggestions.indexOf(suggestion),
    partialQuery,
    partialQueries: querySuggest.partialQueries,
    suggestions,
    querySuggestResponseId
  };
}
const getQuerySuggestSetInitialState = () => ({});
const querySuggestReducer = createReducer(getQuerySuggestSetInitialState(), (builder) => builder.addCase(registerQuerySuggest, (state, action) => {
  handleRegisterQuerySuggest(state, action.payload);
}).addCase(registerQuerySuggest$1, (state, action) => {
  handleRegisterQuerySuggest(state, action.payload);
}).addCase(unregisterQuerySuggest, (state, action) => {
  delete state[action.payload.id];
}).addCase(fetchQuerySuggestions.pending, handleFetchPending).addCase(fetchQuerySuggestions.fulfilled, (state, action) => {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
    return;
  }
  const { q } = action.payload;
  if (q) {
    querySuggest.partialQueries.push(q.replace(/;/, encodeURIComponent(";")));
  }
  querySuggest.responseId = action.payload.responseId;
  querySuggest.completions = action.payload.completions;
  querySuggest.isLoading = false;
  querySuggest.error = null;
}).addCase(fetchQuerySuggestions.rejected, handleFetchRejected).addCase(fetchQuerySuggestions$1.pending, handleFetchPending).addCase(fetchQuerySuggestions$1.fulfilled, (state, action) => {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest || action.meta.requestId !== querySuggest.currentRequestId) {
    return;
  }
  const { query: query2 } = action.payload;
  if (query2) {
    querySuggest.partialQueries.push(query2.replace(/;/, encodeURIComponent(";")));
  }
  querySuggest.responseId = action.payload.responseId;
  querySuggest.completions = action.payload.completions.map((completion) => ({
    expression: completion.expression,
    highlighted: completion.highlighted,
    score: 0,
    executableConfidence: 0
  }));
  querySuggest.isLoading = false;
  querySuggest.error = null;
}).addCase(fetchQuerySuggestions$1.rejected, handleFetchRejected).addCase(clearQuerySuggest, (state, action) => {
  handleClearQuerySuggest(state, action.payload);
}).addCase(clearQuerySuggest$1, (state, action) => {
  handleClearQuerySuggest(state, action.payload);
}).addCase(setError, (state, action) => {
  Object.keys(state).forEach((slotId) => {
    const slot = state[slotId];
    if (slot) {
      slot.error = action.payload;
      slot.isLoading = false;
    }
  });
}));
function handleRegisterQuerySuggest(state, payload) {
  const id2 = payload.id;
  if (id2 in state) {
    return;
  }
  state[id2] = buildQuerySuggest(payload);
}
function buildQuerySuggest(config) {
  return {
    id: "",
    completions: [],
    responseId: "",
    count: 5,
    currentRequestId: "",
    error: null,
    partialQueries: [],
    isLoading: false,
    ...config
  };
}
function handleFetchPending(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.currentRequestId = action.meta.requestId;
  querySuggest.isLoading = true;
}
function handleFetchRejected(state, action) {
  const querySuggest = state[action.meta.arg.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.error = action.payload || null;
  querySuggest.isLoading = false;
}
function handleClearQuerySuggest(state, payload) {
  const querySuggest = state[payload.id];
  if (!querySuggest) {
    return;
  }
  querySuggest.responseId = "";
  querySuggest.completions = [];
  querySuggest.partialQueries = [];
}
const defaultSearchBoxOptions = {
  enableQuerySyntax: false,
  numberOfSuggestions: 5,
  clearFilters: true
};
const openCloseDelimitersDefinition = {
  open: new StringValue(),
  close: new StringValue()
};
const searchBoxOptionDefinitions$1 = {
  id: requiredNonEmptyString,
  numberOfSuggestions: new NumberValue({ min: 0 }),
  enableQuerySyntax: new BooleanValue(),
  highlightOptions: new RecordValue({
    values: {
      notMatchDelimiters: new RecordValue({
        values: openCloseDelimitersDefinition
      }),
      exactMatchDelimiters: new RecordValue({
        values: openCloseDelimitersDefinition
      }),
      correctionDelimiters: new RecordValue({
        values: openCloseDelimitersDefinition
      })
    }
  }),
  clearFilters: new BooleanValue()
};
const searchBoxOptionsSchema = new Schema(searchBoxOptionDefinitions$1);
function buildCoreSearchBox(engine, props) {
  if (!loadSearchBoxReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const id2 = props.options?.id || randomID("search_box");
  const options2 = {
    id: id2,
    highlightOptions: { ...props.options?.highlightOptions },
    ...defaultSearchBoxOptions,
    ...props.options
  };
  validateOptions(engine, searchBoxOptionsSchema, options2, "buildSearchBox");
  dispatch(registerQuerySetQuery$1({ id: id2, query: engine.state.query.q }));
  if (options2.numberOfSuggestions) {
    dispatch(registerQuerySuggest({
      id: id2,
      count: options2.numberOfSuggestions
    }));
  }
  const getValue = () => engine.state.querySet[options2.id];
  const performSearch = async (analytics) => {
    const { enableQuerySyntax, clearFilters: clearFilters2 } = options2;
    dispatch(prepareForSearchWithQuery({
      q: getValue(),
      enableQuerySyntax,
      clearFilters: clearFilters2
    }));
    if (props.isNextAnalyticsReady) {
      dispatch(props.executeSearchActionCreator(analytics));
    } else {
      dispatch(props.executeSearchActionCreator(analytics.legacy));
    }
  };
  return {
    ...controller,
    updateText(value) {
      dispatch(updateQuerySetQuery$1({ id: id2, query: value }));
      this.showSuggestions();
    },
    clear() {
      dispatch(updateQuerySetQuery$1({ id: id2, query: "" }));
      dispatch(clearQuerySuggest({ id: id2 }));
    },
    showSuggestions() {
      if (options2.numberOfSuggestions) {
        dispatch(props.fetchQuerySuggestionsActionCreator({ id: id2 }));
      }
    },
    selectSuggestion(value) {
      dispatch(selectQuerySuggestion({ id: id2, expression: value }));
      performSearch({
        legacy: logQuerySuggestionClick({ id: id2, suggestion: value }),
        next: omniboxAnalytics()
      }).then(() => {
        dispatch(clearQuerySuggest({ id: id2 }));
      });
    },
    submit(legacyAnalytics = logSearchboxSubmit(), nextAnalytics) {
      performSearch({ legacy: legacyAnalytics, next: nextAnalytics });
      dispatch(clearQuerySuggest({ id: id2 }));
    },
    get state() {
      const state = getState();
      const querySuggest = state.querySuggest[options2.id];
      const suggestions = getSuggestions(querySuggest, options2.highlightOptions);
      const isLoadingSuggestions = querySuggest ? querySuggest.isLoading : false;
      return {
        searchBoxId: id2,
        value: getValue(),
        suggestions,
        isLoading: state.search.isLoading,
        isLoadingSuggestions
      };
    }
  };
}
function getSuggestions(state, highlightOptions2) {
  if (!state) {
    return [];
  }
  return state.completions.map((completion) => ({
    highlightedValue: getHighlightedSuggestion(completion.highlighted, highlightOptions2),
    rawValue: completion.expression
  }));
}
function loadSearchBoxReducers(engine) {
  engine.addReducers({ query: queryReducer$1, querySuggest: querySuggestReducer, configuration, querySet: querySetReducer, search: searchReducer });
  return true;
}
function buildSearchBox(engine, props = {}) {
  const searchBox = buildCoreSearchBox(engine, {
    ...props,
    executeSearchActionCreator: executeSearch$1,
    fetchQuerySuggestionsActionCreator: fetchQuerySuggestions,
    isNextAnalyticsReady: true
  });
  return {
    ...searchBox,
    submit() {
      searchBox.submit(logSearchboxSubmit(), searchboxSubmit());
    },
    get state() {
      return searchBox.state;
    }
  };
}
const logResultsSort = () => makeAnalyticsAction("analytics/sort/results", (client, state) => client.makeResultsSort({
  resultsSortBy: state.sortCriteria || getSortCriteriaInitialState()
}));
const resultsSort = () => ({
  actionCause: SearchPageEvents.resultsSort
});
function legacyLogParametersChange(previousParameters, newParameters) {
  if (previousParameters.q !== newParameters.q) {
    return logSearchboxSubmit();
  }
  if (previousParameters.sortCriteria !== newParameters.sortCriteria) {
    return logResultsSort();
  }
  if (previousParameters.firstResult !== newParameters.firstResult) {
    return logPageNumber();
  }
  if (previousParameters.numberOfResults !== newParameters.numberOfResults) {
    return logPagerResize();
  }
  if (areFacetParamsNotEqual(previousParameters.f, newParameters.f)) {
    return legacyLogFacetAnalyticsAction(previousParameters.f, newParameters.f);
  }
  if (areFacetParamsNotEqual(previousParameters.fExcluded, newParameters.fExcluded)) {
    return legacyLogFacetAnalyticsAction(previousParameters.fExcluded, newParameters.fExcluded, true);
  }
  if (areFacetParamsNotEqual(previousParameters.cf, newParameters.cf)) {
    return legacyLogFacetAnalyticsAction(previousParameters.cf, newParameters.cf);
  }
  if (areFacetParamsNotEqual(previousParameters.af, newParameters.af)) {
    return legacyLogFacetAnalyticsAction(previousParameters.af, newParameters.af);
  }
  if (areFacetParamsNotEqual(previousParameters.nf, newParameters.nf)) {
    return legacyLogRangeFacetAnalyticsAction(previousParameters.nf, newParameters.nf);
  }
  if (areFacetParamsNotEqual(previousParameters.df, newParameters.df)) {
    return legacyLogRangeFacetAnalyticsAction(previousParameters.df, newParameters.df);
  }
  return logInterfaceChange();
}
function legacyLogFacetAnalyticsAction(previousFacets = {}, newFacets = {}, excluded = false) {
  const previousIds = Object.keys(previousFacets);
  const newIds = Object.keys(newFacets);
  const removedIds = previousIds.filter((id2) => !newIds.includes(id2));
  if (removedIds.length) {
    const facetId2 = removedIds[0];
    switch (true) {
      case previousFacets[facetId2].length > 1:
        return logFacetClearAll(facetId2);
      case excluded:
        return logFacetUnexclude({
          facetId: facetId2,
          facetValue: previousFacets[facetId2][0]
        });
      default:
        return logFacetDeselect({
          facetId: facetId2,
          facetValue: previousFacets[facetId2][0]
        });
    }
  }
  const addedIds = newIds.filter((id2) => !previousIds.includes(id2));
  if (addedIds.length) {
    const facetId2 = addedIds[0];
    return excluded ? logFacetExclude({
      facetId: facetId2,
      facetValue: newFacets[facetId2][0]
    }) : logFacetSelect({
      facetId: facetId2,
      facetValue: newFacets[facetId2][0]
    });
  }
  const facetIdWithDifferentValues = newIds.find((key) => newFacets[key].filter((facetValue) => previousFacets[key].includes(facetValue)));
  if (!facetIdWithDifferentValues) {
    return logInterfaceChange();
  }
  const previousValues = previousFacets[facetIdWithDifferentValues];
  const newValues = newFacets[facetIdWithDifferentValues];
  const addedValues = newValues.filter((value) => !previousValues.includes(value));
  if (addedValues.length) {
    return excluded ? logFacetExclude({
      facetId: facetIdWithDifferentValues,
      facetValue: addedValues[0]
    }) : logFacetSelect({
      facetId: facetIdWithDifferentValues,
      facetValue: addedValues[0]
    });
  }
  const removedValues = previousValues.filter((value) => !newValues.includes(value));
  if (removedValues.length) {
    return excluded ? logFacetUnexclude({
      facetId: facetIdWithDifferentValues,
      facetValue: removedValues[0]
    }) : logFacetDeselect({
      facetId: facetIdWithDifferentValues,
      facetValue: removedValues[0]
    });
  }
  return logInterfaceChange();
}
function legacyLogRangeFacetAnalyticsAction(previousFacets = {}, newFacets = {}) {
  return legacyLogFacetAnalyticsAction(parseRangeFacetParams(previousFacets), parseRangeFacetParams(newFacets));
}
function parametersChange(previousParameters, newParameters) {
  if (previousParameters.q !== newParameters.q) {
    return searchboxSubmit();
  }
  if (previousParameters.sortCriteria !== newParameters.sortCriteria) {
    return resultsSort();
  }
  if (areFacetParamsNotEqual(previousParameters.f, newParameters.f)) {
    return facetAction(previousParameters.f, newParameters.f);
  }
  if (areFacetParamsNotEqual(previousParameters.fExcluded, newParameters.fExcluded)) {
    return facetAction(previousParameters.fExcluded, newParameters.fExcluded, true);
  }
  if (areFacetParamsNotEqual(previousParameters.cf, newParameters.cf)) {
    return facetAction(previousParameters.cf, newParameters.cf);
  }
  if (areFacetParamsNotEqual(previousParameters.af, newParameters.af)) {
    return facetAction(previousParameters.af, newParameters.af);
  }
  if (areFacetParamsNotEqual(previousParameters.nf, newParameters.nf)) {
    return facetAction(parseRangeFacetParams(previousParameters.nf), parseRangeFacetParams(newParameters.nf));
  }
  if (areFacetParamsNotEqual(previousParameters.df, newParameters.df)) {
    return facetAction(parseRangeFacetParams(previousParameters.df), parseRangeFacetParams(newParameters.df));
  }
  return interfaceChange();
}
function areFacetParamsNotEqual(previousFacetParams = {}, newFacetParams = {}) {
  return JSON.stringify(previousFacetParams) !== JSON.stringify(newFacetParams);
}
function facetAction(previousFacets = {}, newFacets = {}, excluded = false) {
  const previousIds = Object.keys(previousFacets);
  const newIds = Object.keys(newFacets);
  const removedIds = previousIds.filter((id2) => !newIds.includes(id2));
  if (removedIds.length) {
    const facetId2 = removedIds[0];
    return previousFacets[facetId2].length > 1 ? facetClearAll() : facetDeselect();
  }
  const addedIds = newIds.filter((id2) => !previousIds.includes(id2));
  if (addedIds.length) {
    return excluded ? facetExclude() : facetSelect();
  }
  const facetIdWithDifferentValues = newIds.find((key) => newFacets[key].filter((facetValue) => previousFacets[key].includes(facetValue)));
  if (!facetIdWithDifferentValues) {
    return interfaceChange();
  }
  const previousValues = previousFacets[facetIdWithDifferentValues];
  const newValues = newFacets[facetIdWithDifferentValues];
  const addedValues = newValues.filter((value) => !previousValues.includes(value));
  if (addedValues.length) {
    return excluded ? facetExclude() : facetSelect();
  }
  const removedValues = previousValues.filter((value) => !newValues.includes(value));
  if (removedValues.length) {
    return facetDeselect();
  }
  return interfaceChange();
}
function parseRangeFacetParams(facetsParams = {}) {
  const formattedParams = {};
  Object.keys(facetsParams).forEach((key) => {
    formattedParams[key] = facetsParams[key].map((facetValue) => `${facetValue.start}..${facetValue.end}`);
  });
  return formattedParams;
}
function initialSearchParameterSelector(state) {
  return {
    q: getQueryInitialState().q,
    enableQuerySyntax: getQueryInitialState().enableQuerySyntax,
    aq: state.advancedSearchQueries?.defaultFilters.aq ?? getAdvancedSearchQueriesInitialState().defaultFilters.aq,
    cq: state.advancedSearchQueries?.defaultFilters.cq ?? getAdvancedSearchQueriesInitialState().defaultFilters.cq,
    firstResult: getPaginationInitialState().firstResult,
    numberOfResults: state.pagination?.defaultNumberOfResults ?? getPaginationInitialState().defaultNumberOfResults,
    sortCriteria: getSortCriteriaInitialState(),
    f: {},
    fExcluded: {},
    cf: {},
    nf: {},
    df: {},
    debug: getDebugInitialState(),
    sf: {},
    tab: "",
    af: {},
    mnf: {}
  };
}
const initialStateSchema$3 = new Schema({
  parameters: new RecordValue({
    options: { required: true },
    values: searchParametersDefinition$1
  })
});
function buildCoreSearchParameterManager(engine, props) {
  const { dispatch } = engine;
  const controller = buildController(engine);
  validateInitialState(engine, initialStateSchema$3, props.initialState, "buildSearchParameterManager");
  const parametersWithValidTab = ensureTabIsValid(engine.state.tabSet, props.initialState.parameters);
  dispatch(restoreSearchParameters$1(parametersWithValidTab));
  return {
    ...controller,
    synchronize(parameters) {
      const enrichedParametersWithValidTab = ensureTabIsValid(engine.state.tabSet, enrichParameters(engine, parameters));
      dispatch(restoreSearchParameters$1(enrichedParametersWithValidTab));
    },
    get state() {
      const parameters = getCoreActiveSearchParameters(engine);
      return { parameters };
    }
  };
}
function enrichParameters(engine, parameters) {
  return {
    ...initialSearchParameterSelector(engine.state),
    ...parameters
  };
}
function ensureTabIsValid(tabSet, parameters) {
  if (parameters.tab && tabSet) {
    const tabExists = Object.values(tabSet).some((tab) => tab.id === parameters.tab);
    const currentActiveTab = Object.values(tabSet).find((tab) => tab.isActive);
    if (!tabExists && currentActiveTab) {
      return { ...parameters, tab: currentActiveTab.id };
    } else if (!tabExists) {
      return { ...parameters, tab: "" };
    }
  }
  return parameters;
}
function getCoreActiveSearchParameters(engine) {
  const state = engine.state;
  return {
    ...getQ(state.query, (s) => s.q, getQueryInitialState().q),
    ...getTab(state.tabSet, (tabSet) => {
      const activeTab = Object.values(tabSet ?? {}).find((tab) => tab.isActive);
      return activeTab ? activeTab.id : Object.keys(tabSet ?? {})[0];
    }, state.tabSet ? Object.keys(state.tabSet)[0] : ""),
    ...getSortCriteria(state.sortCriteria, (sortCriteria) => sortCriteria, getSortCriteriaInitialState()),
    ...getFacets(state.facetSet, facetIsEnabled(state), getSelectedValues, "f"),
    ...getFacets(state.facetSet, facetIsEnabled(state), getExcludedValues, "fExcluded"),
    ...getCategoryFacets(state),
    ...getNumericFacets(state),
    ...getDateFacets(state),
    ...getAutomaticFacets(state)
  };
}
function facetIsEnabled(state) {
  return (facetId2) => {
    return state.facetOptions?.facets[facetId2]?.enabled ?? true;
  };
}
function getSelectedValues(request) {
  return request.currentValues.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function getSelectedRangeValues(request) {
  return request.currentValues.filter((fv) => fv.state === "selected");
}
function getExcludedValues(request) {
  return request.currentValues.filter((fv) => fv.state === "excluded").map((fv) => fv.value);
}
function getCategoryFacets(state) {
  return getFacets(state.categoryFacetSet, facetIsEnabled(state), (request) => findActiveValueAncestry(request.currentValues).map((v) => v.value), "cf");
}
function getNumericFacets(state) {
  return getFacets(state.numericFacetSet, facetIsEnabled(state), getSelectedRangeValues, "nf");
}
function getDateFacets(state) {
  return getFacets(state.dateFacetSet, facetIsEnabled(state), getSelectedRangeValues, "df");
}
function getAutomaticFacets(state) {
  const set2 = state.automaticFacetSet?.set;
  if (set2 === void 0) {
    return {};
  }
  const af = Object.entries(set2).map(([facetId2, { response }]) => {
    const selectedValues = getSelectedResponseValues(response);
    return selectedValues.length ? { [facetId2]: selectedValues } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(af).length ? { af } : {};
}
function getSelectedResponseValues(response) {
  return response.values.filter((fv) => fv.state === "selected").map((fv) => fv.value);
}
function buildSearchParameterManager(engine, props) {
  const { dispatch } = engine;
  const controller = buildCoreSearchParameterManager(engine, props);
  return {
    ...controller,
    synchronize(parameters) {
      const activeParams = getActiveSearchParameters(engine);
      const oldParams = enrichParameters(engine, activeParams);
      const newParams = enrichParameters(engine, parameters);
      if (deepEqualAnyOrder(oldParams, newParams)) {
        return;
      }
      controller.synchronize(parameters);
      dispatch(executeSearch$1({
        legacy: legacyLogParametersChange(oldParams, newParams),
        next: parametersChange(oldParams, newParams)
      }));
    },
    get state() {
      const parameters = getActiveSearchParameters(engine);
      return { parameters };
    }
  };
}
function getActiveSearchParameters(engine) {
  const state = engine.state;
  return {
    ...getCoreActiveSearchParameters(engine),
    ...getEnableQuerySyntax(state),
    ...getAq(state),
    ...getCq(state),
    ...getFirstResult(state),
    ...getNumberOfResults(state),
    ...getDebug(state),
    ...getStaticFilters(state)
  };
}
function getEnableQuerySyntax(state) {
  if (state.query === void 0) {
    return {};
  }
  const enableQuerySyntax = state.query.enableQuerySyntax;
  const shouldInclude = enableQuerySyntax !== void 0 && enableQuerySyntax !== getQueryInitialState().enableQuerySyntax;
  return shouldInclude ? { enableQuerySyntax } : {};
}
function getAq(state) {
  if (state.advancedSearchQueries === void 0) {
    return {};
  }
  const { aq, defaultFilters } = state.advancedSearchQueries;
  const shouldInclude = aq !== defaultFilters.aq;
  return shouldInclude ? { aq } : {};
}
function getCq(state) {
  if (state.advancedSearchQueries === void 0) {
    return {};
  }
  const { cq, defaultFilters } = state.advancedSearchQueries;
  const shouldInclude = cq !== defaultFilters.cq;
  return shouldInclude ? { cq } : {};
}
function getFirstResult(state) {
  if (state.pagination === void 0) {
    return {};
  }
  const firstResult = state.pagination.firstResult;
  const shouldInclude = firstResult !== getPaginationInitialState().firstResult;
  return shouldInclude ? { firstResult } : {};
}
function getNumberOfResults(state) {
  if (state.pagination === void 0) {
    return {};
  }
  const { numberOfResults, defaultNumberOfResults } = state.pagination;
  const shouldInclude = numberOfResults !== defaultNumberOfResults;
  return shouldInclude ? { numberOfResults } : {};
}
function getStaticFilters(state) {
  if (state.staticFilterSet === void 0) {
    return {};
  }
  const sf = Object.entries(state.staticFilterSet).map(([id2, filter]) => {
    const selectedCaptions = getSelectedStaticFilterCaptions(filter.values);
    return selectedCaptions.length ? { [id2]: selectedCaptions } : {};
  }).reduce((acc, obj) => ({ ...acc, ...obj }), {});
  return Object.keys(sf).length ? { sf } : {};
}
function getSelectedStaticFilterCaptions(values) {
  return values.filter((v) => v.state === "selected").map((v) => v.caption);
}
function getDebug(state) {
  if (state.debug === void 0) {
    return {};
  }
  const debug = state.debug;
  const shouldInclude = debug !== getDebugInitialState();
  return shouldInclude ? { debug } : {};
}
function buildSearchStatus(engine) {
  return buildCoreStatus(engine);
}
const uniqueIdentifierPayloadDefinition = () => new RecordValue({
  values: {
    questionAnswerId: requiredNonEmptyString
  },
  options: { required: true }
});
const inlineLinkPayloadDefinition = () => new RecordValue({
  values: {
    linkText: requiredEmptyAllowedString,
    linkURL: requiredEmptyAllowedString
  },
  options: { required: true }
});
function validateQuestionAnsweringActionCreatorPayload(payload) {
  return validatePayload(payload, uniqueIdentifierPayloadDefinition());
}
function answerSourceSelector(state, documentIdentifier2) {
  const documentId = documentIdentifier2 ?? state.search?.questionAnswer?.documentId;
  return documentId && state.search && resultFromFieldSelector(state, documentId.contentIdKey, documentId.contentIdValue);
}
function relatedQuestionSelector(state, questionAnswerId) {
  const index = state.questionAnswering?.relatedQuestions.findIndex((relatedQuestion) => relatedQuestion.questionAnswerId === questionAnswerId) ?? -1;
  if (index === -1) {
    return null;
  }
  const searchQuestionState = state.search?.questionAnswer?.relatedQuestions?.[index];
  return searchQuestionState ?? null;
}
const logExpandSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/expand",
  __legacy__getBuilder: (client) => {
    return client.makeExpandSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "expand",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
const logCollapseSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/collapse",
  __legacy__getBuilder: (client) => {
    return client.makeCollapseSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "collapse",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
const logLikeSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/like",
  __legacy__getBuilder: (client) => {
    return client.makeLikeSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "like",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
const logDislikeSmartSnippet = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/dislike",
  __legacy__getBuilder: (client) => {
    return client.makeDislikeSmartSnippet();
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        action: "dislike",
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
const logOpenSmartSnippetSource = () => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/source/open",
  __legacy__getBuilder: (client, state) => {
    const result = answerSourceSelector(state);
    return client.makeOpenSmartSnippetSource(partialDocumentInformation(result, state), documentIdentifier(result));
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
const logOpenSmartSnippetInlineLink = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(payload, inlineLinkPayloadDefinition());
    const result = answerSourceSelector(state);
    if (!result) {
      return null;
    }
    return client.makeOpenSmartSnippetInlineLink(partialDocumentInformation(result, state), {
      ...documentIdentifier(result),
      ...payload
    });
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        snippetType: "SmartSnippet",
        responseId: searchUid,
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        }
      };
    }
  }
});
const logOpenSmartSnippetFeedbackModal = () => makeAnalyticsAction("analytics/smartSnippet/feedbackModal/open", (client) => client.makeOpenSmartSnippetFeedbackModal());
const logCloseSmartSnippetFeedbackModal = () => makeAnalyticsAction("analytics/smartSnippet/feedbackModal/close", (client) => client.makeCloseSmartSnippetFeedbackModal());
const smartSnippetFeedbackMap = {
  does_not_answer: "doesNotAnswer",
  partially_answers: "partiallyAnswers",
  was_not_a_question: "wasNotAQuestion"
};
const logSmartSnippetFeedback = (feedback) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/sendFeedback",
  __legacy__getBuilder: (client) => {
    return client.makeSmartSnippetFeedbackReason(feedback);
  },
  analyticsType: "SmartSnippets.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        responseId: searchUid,
        snippetType: "SmartSnippet",
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        },
        reason: smartSnippetFeedbackMap[feedback]
      };
    }
  }
});
const logSmartSnippetDetailedFeedback = (details) => makeAnalyticsAction({
  prefix: "analytics/smartSnippet/sendFeedback",
  __legacy__getBuilder: (client) => {
    return client.makeSmartSnippetFeedbackReason("other", details);
  },
  analyticsType: "SmartSnippets.SubmitFeedback",
  analyticsPayloadBuilder: (state) => {
    const result = answerSourceSelector(state);
    const identifier = documentIdentifier(result);
    const searchUid = state.search?.response.searchUid;
    if (searchUid) {
      return {
        responseId: searchUid,
        snippetType: "SmartSnippet",
        itemMetadata: {
          uniqueFieldName: identifier.contentIDKey,
          uniqueFieldValue: identifier.contentIDValue,
          title: result.title,
          url: result.clickUri
        },
        reason: "other",
        additionalNotes: details
      };
    }
  }
});
const logExpandSmartSnippetSuggestion = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/expand",
  __legacy__getBuilder: (client, state) => {
    validateQuestionAnsweringActionCreatorPayload(payload);
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    return client.makeExpandSmartSnippetSuggestion({
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        action: "expand",
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
const logCollapseSmartSnippetSuggestion = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/collapse",
  __legacy__getBuilder: (client, state) => {
    validateQuestionAnsweringActionCreatorPayload(payload);
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    return client.makeCollapseSmartSnippetSuggestion({
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.AnswerAction",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        action: "collapse",
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
const logOpenSmartSnippetSuggestionSource = (payload) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(payload, uniqueIdentifierPayloadDefinition());
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    const source = answerSourceSelector(state, relatedQuestion.documentId);
    if (!source) {
      return null;
    }
    return client.makeOpenSmartSnippetSuggestionSource(partialDocumentInformation(source, state), {
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId
    });
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(state, payload.questionAnswerId);
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
const logOpenSmartSnippetSuggestionInlineLink = (identifier, link) => makeAnalyticsAction({
  prefix: "analytics/smartSnippetSuggestion/source/open",
  __legacy__getBuilder: (client, state) => {
    validatePayload(identifier, uniqueIdentifierPayloadDefinition());
    validatePayload(link, inlineLinkPayloadDefinition());
    const relatedQuestion = relatedQuestionSelector(state, identifier.questionAnswerId);
    if (!relatedQuestion) {
      return null;
    }
    const source = answerSourceSelector(state, relatedQuestion.documentId);
    if (!source) {
      return null;
    }
    return client.makeOpenSmartSnippetSuggestionInlineLink(partialDocumentInformation(source, state), {
      question: relatedQuestion.question,
      answerSnippet: relatedQuestion.answerSnippet,
      documentId: relatedQuestion.documentId,
      linkText: link.linkText,
      linkURL: link.linkURL
    });
  },
  analyticsType: "SmartSnippets.SourceClick",
  analyticsPayloadBuilder: (state) => {
    const relatedQuestion = relatedQuestionSelector(state, identifier.questionAnswerId);
    const searchUid = state.search?.response.searchUid;
    if (searchUid && relatedQuestion) {
      const source = answerSourceSelector(state, relatedQuestion.documentId);
      return {
        responseId: searchUid,
        snippetType: "SmartSnippetSuggestion",
        itemMetadata: {
          uniqueFieldName: relatedQuestion.documentId.contentIdKey,
          uniqueFieldValue: relatedQuestion.documentId.contentIdValue,
          title: source?.title,
          url: source?.clickUri
        }
      };
    }
  }
});
const smartSnippetAnalyticsClient = {
  logExpandSmartSnippet,
  logCollapseSmartSnippet,
  logLikeSmartSnippet,
  logDislikeSmartSnippet,
  logOpenSmartSnippetSource,
  logOpenSmartSnippetInlineLink,
  logOpenSmartSnippetFeedbackModal,
  logCloseSmartSnippetFeedbackModal,
  logSmartSnippetFeedback,
  logSmartSnippetDetailedFeedback,
  logExpandSmartSnippetSuggestion,
  logCollapseSmartSnippetSuggestion,
  logOpenSmartSnippetSuggestionSource
};
const expandSmartSnippet = createAction("smartSnippet/expand");
const collapseSmartSnippet = createAction("smartSnippet/collapse");
const likeSmartSnippet = createAction("smartSnippet/like");
const dislikeSmartSnippet = createAction("smartSnippet/dislike");
const openFeedbackModal = createAction("smartSnippet/feedbackModal/open");
const closeFeedbackModal = createAction("smartSnippet/feedbackModal/close");
const expandSmartSnippetRelatedQuestion = createAction("smartSnippet/related/expand", (payload) => validateQuestionAnsweringActionCreatorPayload(payload));
const collapseSmartSnippetRelatedQuestion = createAction("smartSnippet/related/collapse", (payload) => validateQuestionAnsweringActionCreatorPayload(payload));
const getQuestionAnsweringInitialState = () => ({
  liked: false,
  disliked: false,
  expanded: false,
  feedbackModalOpen: false,
  relatedQuestions: []
});
const findRelatedQuestionIdx = (relatedQuestions, identifier) => relatedQuestions.findIndex((relatedQuestion) => relatedQuestion.questionAnswerId === identifier.questionAnswerId);
function hashQuestionAnswer({ question, answerSnippet, documentId: { contentIdKey, contentIdValue } }) {
  return getObjectHash({
    question,
    answerSnippet,
    contentIdKey,
    contentIdValue
  });
}
function buildQuestionAnsweringRelatedQuestionState(responseQuestionAnswer, currentState) {
  const id2 = hashQuestionAnswer(responseQuestionAnswer);
  if (currentState && id2 === currentState.questionAnswerId) {
    return currentState;
  }
  return {
    contentIdKey: responseQuestionAnswer.documentId.contentIdKey,
    contentIdValue: responseQuestionAnswer.documentId.contentIdValue,
    expanded: false,
    questionAnswerId: id2
  };
}
const questionAnsweringReducer = createReducer(getQuestionAnsweringInitialState(), (builder) => builder.addCase(expandSmartSnippet, (state) => {
  state.expanded = true;
}).addCase(collapseSmartSnippet, (state) => {
  state.expanded = false;
}).addCase(likeSmartSnippet, (state) => {
  state.liked = true;
  state.disliked = false;
  state.feedbackModalOpen = false;
}).addCase(dislikeSmartSnippet, (state) => {
  state.liked = false;
  state.disliked = true;
}).addCase(openFeedbackModal, (state) => {
  state.feedbackModalOpen = true;
}).addCase(closeFeedbackModal, (state) => {
  state.feedbackModalOpen = false;
}).addCase(executeSearch$1.fulfilled, (state, action) => {
  const relatedQuestions = action.payload.response.questionAnswer.relatedQuestions.map((relatedQuestion, i) => buildQuestionAnsweringRelatedQuestionState(relatedQuestion, state.relatedQuestions[i]));
  const questionAnswerId = hashQuestionAnswer(action.payload.response.questionAnswer);
  if (state.questionAnswerId === questionAnswerId) {
    return {
      ...state,
      relatedQuestions
    };
  }
  return {
    ...getQuestionAnsweringInitialState(),
    relatedQuestions,
    questionAnswerId
  };
}).addCase(expandSmartSnippetRelatedQuestion, (state, action) => {
  const idx = findRelatedQuestionIdx(state.relatedQuestions, action.payload);
  if (idx === -1) {
    return;
  }
  state.relatedQuestions[idx].expanded = true;
}).addCase(collapseSmartSnippetRelatedQuestion, (state, action) => {
  const idx = findRelatedQuestionIdx(state.relatedQuestions, action.payload);
  if (idx === -1) {
    return;
  }
  state.relatedQuestions[idx].expanded = false;
}));
function buildCoreSmartSnippet(engine, analyticsClient, props) {
  if (!loadSmartSnippetReducers(engine)) ;
  const controller = buildController(engine);
  const getState = () => engine.state;
  const getResult = () => answerSourceSelector(getState());
  let lastSearchResponseId = null;
  const interactiveResult = buildInteractiveResultCore(engine, { options: { selectionDelay: props?.options?.selectionDelay } }, () => {
    const result = getResult();
    if (!result) {
      lastSearchResponseId = null;
      return;
    }
    const { searchResponseId } = getState().search;
    if (lastSearchResponseId === searchResponseId) {
      return;
    }
    lastSearchResponseId = searchResponseId;
    engine.dispatch(analyticsClient.logOpenSmartSnippetSource());
    engine.dispatch(pushRecentResult(result));
  });
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        question: state.search.questionAnswer.question,
        answer: state.search.questionAnswer.answerSnippet,
        documentId: state.search.questionAnswer.documentId,
        expanded: state.questionAnswering.expanded,
        answerFound: state.search.questionAnswer.answerSnippet !== "",
        liked: state.questionAnswering.liked,
        disliked: state.questionAnswering.disliked,
        feedbackModalOpen: state.questionAnswering.feedbackModalOpen,
        source: getResult()
      };
    },
    expand() {
      engine.dispatch(analyticsClient.logExpandSmartSnippet());
      engine.dispatch(expandSmartSnippet());
    },
    collapse() {
      engine.dispatch(analyticsClient.logCollapseSmartSnippet());
      engine.dispatch(collapseSmartSnippet());
    },
    like() {
      engine.dispatch(analyticsClient.logLikeSmartSnippet());
      engine.dispatch(likeSmartSnippet());
    },
    dislike() {
      engine.dispatch(analyticsClient.logDislikeSmartSnippet());
      engine.dispatch(dislikeSmartSnippet());
    },
    openFeedbackModal() {
      engine.dispatch(analyticsClient.logOpenSmartSnippetFeedbackModal());
      engine.dispatch(openFeedbackModal());
    },
    closeFeedbackModal() {
      engine.dispatch(analyticsClient.logCloseSmartSnippetFeedbackModal());
      engine.dispatch(closeFeedbackModal());
    },
    sendFeedback(feedback) {
      engine.dispatch(analyticsClient.logSmartSnippetFeedback(feedback));
      engine.dispatch(closeFeedbackModal());
    },
    sendDetailedFeedback(details) {
      engine.dispatch(analyticsClient.logSmartSnippetDetailedFeedback(details));
      engine.dispatch(closeFeedbackModal());
    },
    selectSource() {
      interactiveResult.select();
    },
    beginDelayedSelectSource() {
      interactiveResult.beginDelayedSelect();
    },
    cancelPendingSelectSource() {
      interactiveResult.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetReducers(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}
function buildSmartSnippetInteractiveInlineLinks(engine, props) {
  if (!loadSmartSnippetInteractiveInlineLinksReducer(engine)) ;
  const getState = () => engine.state;
  const clickedRelatedQuestions = /* @__PURE__ */ new Set();
  const inlineLinkWasClicked = (linkId) => {
    if (clickedRelatedQuestions.has(linkId)) {
      return true;
    }
    clickedRelatedQuestions.add(linkId);
    return false;
  };
  let lastSearchResponseId = null;
  const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
    if (lastSearchResponseId !== currentSearchResponseId) {
      lastSearchResponseId = currentSearchResponseId;
      interactiveResultsPerInlineLink = {};
      clickedRelatedQuestions.clear();
    }
  };
  const buildInlineLinkInteractiveResult = (link, linkId, questionAnswerId) => buildInteractiveResultCore(engine, { options: { selectionDelay: props?.options?.selectionDelay } }, () => {
    if (inlineLinkWasClicked(linkId)) {
      return;
    }
    engine.dispatch(questionAnswerId ? logOpenSmartSnippetSuggestionInlineLink({ questionAnswerId }, link) : logOpenSmartSnippetInlineLink(link));
  });
  let interactiveResultsPerInlineLink = {};
  const getInteractiveResult = (link, questionAnswerId) => {
    const { searchResponseId } = getState().search;
    resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
    const linkId = getObjectHash({ ...link, questionAnswerId });
    if (linkId in interactiveResultsPerInlineLink) {
      return interactiveResultsPerInlineLink[linkId];
    }
    interactiveResultsPerInlineLink[linkId] = buildInlineLinkInteractiveResult(link, linkId, questionAnswerId);
    return interactiveResultsPerInlineLink[linkId];
  };
  return {
    selectInlineLink(link, questionAnswerId) {
      getInteractiveResult(link, questionAnswerId)?.select();
    },
    beginDelayedSelectInlineLink(link, questionAnswerId) {
      getInteractiveResult(link, questionAnswerId)?.beginDelayedSelect();
    },
    cancelPendingSelectInlineLink(link, questionAnswerId) {
      getInteractiveResult(link, questionAnswerId)?.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetInteractiveInlineLinksReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}
function buildSmartSnippet(engine, props) {
  warnIfUsingNextAnalyticsModeForServiceFeature(engine.state.configuration.analytics.analyticsMode);
  const smartSnippet = buildCoreSmartSnippet(engine, smartSnippetAnalyticsClient, props);
  const interactiveInlineLinks = buildSmartSnippetInteractiveInlineLinks(engine, { options: { selectionDelay: props?.options?.selectionDelay } });
  return {
    ...smartSnippet,
    get state() {
      return smartSnippet.state;
    },
    selectInlineLink(link) {
      interactiveInlineLinks.selectInlineLink(link);
    },
    beginDelayedSelectInlineLink(link) {
      interactiveInlineLinks.beginDelayedSelectInlineLink(link);
    },
    cancelPendingSelectInlineLink(link) {
      interactiveInlineLinks.cancelPendingSelectInlineLink(link);
    }
  };
}
function buildCoreSmartSnippetQuestionsList(engine, analyticsClient) {
  if (!loadSmartSnippetQuestionsListReducer(engine)) ;
  const controller = buildController(engine);
  const getState = () => engine.state;
  const getResult = (identifier) => {
    const { contentIdKey, contentIdValue } = identifier;
    return engine.state.search.results.find((result) => getResultProperty(result, contentIdKey) === contentIdValue);
  };
  return {
    ...controller,
    get state() {
      const state = getState();
      return {
        questions: state.search.questionAnswer.relatedQuestions.map((relatedQuestion, i) => ({
          question: relatedQuestion.question,
          answer: relatedQuestion.answerSnippet,
          documentId: relatedQuestion.documentId,
          questionAnswerId: state.questionAnswering.relatedQuestions[i].questionAnswerId,
          expanded: state.questionAnswering.relatedQuestions[i].expanded,
          source: getResult(relatedQuestion.documentId)
        }))
      };
    },
    expand(identifier) {
      const payload = { questionAnswerId: identifier };
      engine.dispatch(analyticsClient.logExpandSmartSnippetSuggestion(payload));
      engine.dispatch(expandSmartSnippetRelatedQuestion(payload));
    },
    collapse(identifier) {
      const payload = { questionAnswerId: identifier };
      engine.dispatch(analyticsClient.logCollapseSmartSnippetSuggestion(payload));
      engine.dispatch(collapseSmartSnippetRelatedQuestion(payload));
    }
  };
}
function loadSmartSnippetQuestionsListReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}
function buildSmartSnippetInteractiveQuestions(engine, props) {
  if (!loadSmartSnippetInteractiveQuestionsReducer(engine)) ;
  const getState = () => engine.state;
  const getSource2 = (questionAnswerId) => {
    const state = getState();
    const questionAnswer = relatedQuestionSelector(state, questionAnswerId);
    if (!questionAnswer) {
      return null;
    }
    return answerSourceSelector(state, questionAnswer.documentId);
  };
  const clickedRelatedQuestions = /* @__PURE__ */ new Set();
  const relatedQuestionWasClicked = (questionAnswerId) => {
    if (clickedRelatedQuestions.has(questionAnswerId)) {
      return true;
    }
    clickedRelatedQuestions.add(questionAnswerId);
    return false;
  };
  let lastSearchResponseId = null;
  const resetInteractiveResultsIfSearchResponseChanged = (currentSearchResponseId) => {
    if (lastSearchResponseId !== currentSearchResponseId) {
      lastSearchResponseId = currentSearchResponseId;
      interactiveResultsPerRelatedQuestion = {};
      clickedRelatedQuestions.clear();
    }
  };
  const buildRelatedQuestionInteractiveResult = (source, questionAnswerId) => buildInteractiveResultCore(engine, { options: { selectionDelay: props?.options?.selectionDelay } }, () => {
    if (relatedQuestionWasClicked(questionAnswerId)) {
      return;
    }
    engine.dispatch(logOpenSmartSnippetSuggestionSource({
      questionAnswerId
    }));
    engine.dispatch(pushRecentResult(source));
  });
  let interactiveResultsPerRelatedQuestion = {};
  const getInteractiveResult = (questionAnswerId) => {
    const { searchResponseId } = getState().search;
    resetInteractiveResultsIfSearchResponseChanged(searchResponseId);
    const source = getSource2(questionAnswerId);
    if (!source) {
      return null;
    }
    if (questionAnswerId in interactiveResultsPerRelatedQuestion) {
      return interactiveResultsPerRelatedQuestion[questionAnswerId];
    }
    interactiveResultsPerRelatedQuestion[questionAnswerId] = buildRelatedQuestionInteractiveResult(source, questionAnswerId);
    return interactiveResultsPerRelatedQuestion[questionAnswerId];
  };
  return {
    selectSource(questionAnswerId) {
      getInteractiveResult(questionAnswerId)?.select();
    },
    beginDelayedSelectSource(questionAnswerId) {
      getInteractiveResult(questionAnswerId)?.beginDelayedSelect();
    },
    cancelPendingSelectSource(questionAnswerId) {
      getInteractiveResult(questionAnswerId)?.cancelPendingSelect();
    }
  };
}
function loadSmartSnippetInteractiveQuestionsReducer(engine) {
  engine.addReducers({ search: searchReducer, questionAnswering: questionAnsweringReducer });
  return true;
}
function buildSmartSnippetQuestionsList(engine, props) {
  warnIfUsingNextAnalyticsModeForServiceFeature(engine.state.configuration.analytics.analyticsMode);
  const smartSnippetQuestionList = buildCoreSmartSnippetQuestionsList(engine, smartSnippetAnalyticsClient);
  const interactiveInlineLinks = buildSmartSnippetInteractiveInlineLinks(engine, {
    options: { selectionDelay: props?.options?.selectionDelay }
  });
  const interactiveQuestions = buildSmartSnippetInteractiveQuestions(engine, {
    options: { selectionDelay: props?.options?.selectionDelay }
  });
  return {
    ...smartSnippetQuestionList,
    get state() {
      return smartSnippetQuestionList.state;
    },
    selectSource(identifier) {
      interactiveQuestions.selectSource(identifier);
    },
    beginDelayedSelectSource(identifier) {
      interactiveQuestions.beginDelayedSelectSource(identifier);
    },
    cancelPendingSelectSource(identifier) {
      interactiveQuestions.cancelPendingSelectSource(identifier);
    },
    selectInlineLink(identifier, link) {
      interactiveInlineLinks.selectInlineLink(link, identifier);
    },
    beginDelayedSelectInlineLink(identifier, link) {
      interactiveInlineLinks.beginDelayedSelectInlineLink(link, identifier);
    },
    cancelPendingSelectInlineLink(identifier, link) {
      interactiveInlineLinks.cancelPendingSelectInlineLink(link, identifier);
    }
  };
}
const criterionDefinition = {
  by: new EnumValue({ enum: SortBy$1, required: true })
};
const registerSortCriterion = createAction("sortCriteria/register", (payload) => validate(payload));
const updateSortCriterion = createAction("sortCriteria/update", (payload) => validate(payload));
const validate = (payload) => {
  if (isArray$2(payload)) {
    payload.forEach((p) => validatePayload(p, criterionDefinition));
    return { payload };
  }
  return validatePayload(payload, criterionDefinition);
};
const sortCriteriaReducer = createReducer(getSortCriteriaInitialState(), (builder) => {
  builder.addCase(registerSortCriterion, (_, action) => buildCriterionExpression$1(action.payload)).addCase(updateSortCriterion, (_, action) => buildCriterionExpression$1(action.payload)).addCase(change.fulfilled, (state, action) => {
    return action.payload?.sortCriteria ?? state;
  }).addCase(restoreSearchParameters$1, (state, action) => {
    return action.payload.sortCriteria ?? state;
  });
});
function validateSortInitialState$1(engine, state) {
  if (!state) {
    return;
  }
  const schema = new Schema({
    criterion: new ArrayValue({ each: criterionDefinition$1 })
  });
  const criterion = getCriterionAsArray(state);
  const initialState2 = { ...state, criterion };
  validateInitialState(engine, schema, initialState2, "buildSort");
}
function getCriterionAsArray(state) {
  if (!state.criterion) {
    return [];
  }
  return isArray$2(state.criterion) ? state.criterion : [state.criterion];
}
function buildCoreSort$1(engine, props) {
  if (!loadSortReducers$1(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  validateSortInitialState$1(engine, props.initialState);
  const criterion = props.initialState?.criterion;
  if (criterion) {
    dispatch(registerSortCriterion(criterion));
  }
  return {
    ...controller,
    sortBy(criterion2) {
      dispatch(updateSortCriterion(criterion2));
      dispatch(updatePage(1));
    },
    isSortedBy(criterion2) {
      return this.state.sortCriteria === buildCriterionExpression$1(criterion2);
    },
    get state() {
      return {
        sortCriteria: getState().sortCriteria
      };
    }
  };
}
function loadSortReducers$1(engine) {
  engine.addReducers({ configuration, sortCriteria: sortCriteriaReducer });
  return true;
}
function buildSort(engine, props = {}) {
  const { dispatch } = engine;
  const sort = buildCoreSort$1(engine, props);
  const search = () => dispatch(executeSearch$1({
    legacy: logResultsSort(),
    next: resultsSort()
  }));
  return {
    ...sort,
    get state() {
      return sort.state;
    },
    sortBy(criterion) {
      sort.sortBy(criterion);
      search();
    }
  };
}
function isRedirectTrigger(trigger) {
  return trigger.type === "redirect";
}
class ExecutionPlan {
  response;
  constructor(response) {
    this.response = response;
  }
  /**
   * Gets the final value of the basic expression (`q`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get basicExpression() {
    return this.response.parsedInput.basicExpression;
  }
  /**
   * Gets the final value of the large expression (`lq`) after the search request has been processed in the query pipeline, but before it is sent to the index.
   */
  get largeExpression() {
    return this.response.parsedInput.largeExpression;
  }
  /**
   * Gets the URL to redirect the browser to, if the search request satisfies the condition of a `redirect` trigger rule in the query pipeline.
   *
   * Returns `null` otherwise.
   */
  get redirectionUrl() {
    const redirects = this.response.preprocessingOutput.triggers.filter(isRedirectTrigger);
    return redirects.length ? redirects[0].content : null;
  }
}
const registerStandaloneSearchBox$1 = createAction("standaloneSearchBox/register", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  redirectionUrl: requiredNonEmptyString,
  overwrite: new BooleanValue({ required: false })
}));
const updateStandaloneSearchBoxRedirectionUrl$1 = createAction("standaloneSearchBox/updateRedirectionUrl", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  redirectionUrl: requiredNonEmptyString
}));
const resetStandaloneSearchBox$1 = createAction("standaloneSearchBox/reset", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString
}));
const updateAnalyticsToSearchFromLink = createAction("standaloneSearchBox/updateAnalyticsToSearchFromLink", (payload) => validatePayload(payload, { id: requiredNonEmptyString }));
const updateAnalyticsToOmniboxFromLink = createAction("standaloneSearchBox/updateAnalyticsToOmniboxFromLink");
const fetchRedirectUrl$1 = createAsyncThunk("standaloneSearchBox/fetchRedirect", async (payload, { dispatch, getState, rejectWithValue, extra: { apiClient, validatePayload: validatePayload2, navigatorContext } }) => {
  validatePayload2(payload, { id: new StringValue({ emptyAllowed: false }) });
  const request = await buildPlanRequest$1(getState(), navigatorContext);
  const response = await apiClient.plan(request);
  if (isErrorResponse$1(response)) {
    return rejectWithValue(response.error);
  }
  const { redirectionUrl } = new ExecutionPlan(response.success);
  if (redirectionUrl) {
    dispatch(logRedirect(redirectionUrl));
  }
  return redirectionUrl || "";
});
const logRedirect = (url) => makeAnalyticsAction("analytics/standaloneSearchBox/redirect", (client) => client.makeTriggerRedirect({ redirectedTo: url }));
const buildPlanRequest$1 = async (state, navigatorContext) => {
  return {
    accessToken: state.configuration.accessToken,
    organizationId: state.configuration.organizationId,
    url: state.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(state.configuration.organizationId, state.configuration.environment),
    locale: state.configuration.search.locale,
    timezone: state.configuration.search.timezone,
    q: state.query.q,
    ...state.context && { context: state.context.contextValues },
    ...state.pipeline && { pipeline: state.pipeline },
    ...state.searchHub && { searchHub: state.searchHub },
    ...state.configuration.analytics.enabled && state.configuration.analytics.analyticsMode === "legacy" ? await fromAnalyticsStateToAnalyticsParams(state.configuration.analytics) : fromAnalyticsStateToAnalyticsParams$1(state.configuration.analytics, navigatorContext),
    ...state.configuration.search.authenticationProviders.length && {
      authentication: state.configuration.search.authenticationProviders.join(",")
    }
  };
};
function getStandaloneSearchBoxSetInitialState() {
  return {};
}
const standaloneSearchBoxSetReducer = createReducer(getStandaloneSearchBoxSetInitialState(), (builder) => builder.addCase(registerStandaloneSearchBox$1, (state, action) => {
  const { id: id2, redirectionUrl, overwrite } = action.payload;
  if (!overwrite && id2 in state) {
    return;
  }
  state[id2] = buildStandaloneSearchBoxEntry$1(redirectionUrl);
}).addCase(resetStandaloneSearchBox$1, (state, action) => {
  const { id: id2 } = action.payload;
  const searchBox = state[id2];
  if (searchBox) {
    state[id2] = buildStandaloneSearchBoxEntry$1(searchBox.defaultRedirectionUrl);
    return;
  }
}).addCase(updateStandaloneSearchBoxRedirectionUrl$1, (state, action) => {
  const { id: id2, redirectionUrl } = action.payload;
  if (!(id2 in state)) {
    return;
  }
  state[id2] = buildStandaloneSearchBoxEntry$1(redirectionUrl);
}).addCase(fetchRedirectUrl$1.pending, (state, action) => {
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.isLoading = true;
}).addCase(fetchRedirectUrl$1.fulfilled, (state, action) => {
  const url = action.payload;
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.redirectTo = url ? url : searchBox.defaultRedirectionUrl;
  searchBox.isLoading = false;
}).addCase(fetchRedirectUrl$1.rejected, (state, action) => {
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.isLoading = false;
}).addCase(updateAnalyticsToSearchFromLink, (state, action) => {
  const searchBox = state[action.payload.id];
  if (!searchBox) {
    return;
  }
  searchBox.analytics.cause = "searchFromLink";
}).addCase(updateAnalyticsToOmniboxFromLink, (state, action) => {
  const searchBox = state[action.payload.id];
  if (!searchBox) {
    return;
  }
  searchBox.analytics.cause = "omniboxFromLink";
  searchBox.analytics.metadata = action.payload.metadata;
}));
function buildStandaloneSearchBoxEntry$1(defaultRedirectionUrl) {
  return {
    defaultRedirectionUrl,
    redirectTo: "",
    isLoading: false,
    analytics: {
      cause: "",
      metadata: null
    }
  };
}
const standaloneSearchBoxSchema = new Schema({
  ...searchBoxOptionDefinitions$1,
  redirectionUrl: new StringValue({
    required: true,
    emptyAllowed: false
  }),
  overwrite: new BooleanValue({
    required: false
  })
});
function buildStandaloneSearchBox(engine, props) {
  if (!loadStandaloneSearchBoxReducers(engine)) ;
  const { dispatch } = engine;
  const getState = () => engine.state;
  const id2 = props.options.id || randomID("standalone_search_box");
  const options2 = {
    id: id2,
    highlightOptions: { ...props.options.highlightOptions },
    ...defaultSearchBoxOptions,
    ...{ overwrite: false },
    ...props.options
  };
  validateOptions(engine, standaloneSearchBoxSchema, options2, "buildStandaloneSearchBox");
  const searchBox = buildSearchBox(engine, { options: options2 });
  dispatch(registerStandaloneSearchBox$1({
    id: id2,
    redirectionUrl: options2.redirectionUrl,
    overwrite: options2.overwrite
  }));
  return {
    ...searchBox,
    updateText(value) {
      searchBox.updateText(value);
      dispatch(updateAnalyticsToSearchFromLink({ id: id2 }));
    },
    selectSuggestion(value) {
      const metadata = buildOmniboxSuggestionMetadata(getState(), {
        id: id2,
        suggestion: value
      });
      dispatch(selectQuerySuggestion({ id: id2, expression: value }));
      dispatch(updateAnalyticsToOmniboxFromLink({ id: id2, metadata }));
      this.submit();
    },
    afterRedirection() {
      dispatch(resetStandaloneSearchBox$1({ id: id2 }));
    },
    updateRedirectUrl(url) {
      dispatch(updateStandaloneSearchBoxRedirectionUrl$1({ id: id2, redirectionUrl: url }));
    },
    submit() {
      dispatch(updateQuery$2({
        q: this.state.value,
        enableQuerySyntax: options2.enableQuerySyntax
      }));
      dispatch(fetchRedirectUrl$1({ id: id2 }));
    },
    get state() {
      const state = getState();
      const standaloneSearchBoxState = state.standaloneSearchBoxSet[id2];
      return {
        ...searchBox.state,
        isLoading: standaloneSearchBoxState.isLoading,
        redirectTo: standaloneSearchBoxState.redirectTo,
        analytics: standaloneSearchBoxState.analytics
      };
    }
  };
}
function loadStandaloneSearchBoxReducers(engine) {
  engine.addReducers({
    standaloneSearchBoxSet: standaloneSearchBoxSetReducer,
    configuration,
    query: queryReducer$1,
    querySuggest: querySuggestReducer
  });
  return true;
}
const staticFilterSetReducer = createReducer(getStaticFilterSetInitialState(), (builder) => builder.addCase(registerStaticFilter, (state, action) => {
  const filter = action.payload;
  const { id: id2 } = filter;
  if (id2 in state) {
    return;
  }
  state[id2] = filter;
}).addCase(toggleSelectStaticFilterValue, (state, action) => {
  const { id: id2, value } = action.payload;
  const filter = state[id2];
  if (!filter) {
    return;
  }
  const target = filter.values.find((v) => v.caption === value.caption);
  if (!target) {
    return;
  }
  const isSelected = target.state === "selected";
  target.state = isSelected ? "idle" : "selected";
}).addCase(toggleExcludeStaticFilterValue, (state, action) => {
  const { id: id2, value } = action.payload;
  const filter = state[id2];
  if (!filter) {
    return;
  }
  const target = filter.values.find((v) => v.caption === value.caption);
  if (!target) {
    return;
  }
  const isExcluded = target.state === "excluded";
  target.state = isExcluded ? "idle" : "excluded";
}).addCase(deselectAllStaticFilterValues, (state, action) => {
  const id2 = action.payload;
  const filter = state[id2];
  if (!filter) {
    return;
  }
  filter.values.forEach((v) => {
    v.state = "idle";
  });
}).addCase(deselectAllBreadcrumbs, (state) => {
  Object.values(state).forEach((filter) => {
    filter.values.forEach((v) => {
      v.state = "idle";
    });
  });
}).addCase(restoreSearchParameters$1, (state, action) => {
  const sf = action.payload.sf || {};
  Object.entries(state).forEach(([id2, filter]) => {
    const selected = sf[id2] || [];
    filter.values.forEach((value) => {
      value.state = selected.includes(value.caption) ? "selected" : "idle";
    });
  });
}));
function buildStaticFilterValue(config) {
  return {
    state: "idle",
    ...config
  };
}
const optionsSchema$3 = new Schema({
  id: staticFilterIdSchema,
  values: staticFilterValuesSchema
});
function buildStaticFilter(engine, props) {
  if (!loadReducers(engine)) ;
  validateOptions(engine, optionsSchema$3, props.options, "buildStaticFilter");
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const { id: id2 } = props.options;
  dispatch(registerStaticFilter(props.options));
  return {
    ...controller,
    toggleSelect(value) {
      dispatch(toggleSelectStaticFilterValue({ id: id2, value }));
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggledValue(id2, value)
      }));
    },
    toggleSingleSelect(value) {
      if (value.state === "idle") {
        dispatch(deselectAllStaticFilterValues(id2));
      }
      dispatch(toggleSelectStaticFilterValue({ id: id2, value }));
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggledValue(id2, value)
      }));
    },
    toggleExclude(value) {
      dispatch(toggleExcludeStaticFilterValue({ id: id2, value }));
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggledValue(id2, value)
      }));
    },
    toggleSingleExclude(value) {
      if (value.state === "idle") {
        dispatch(deselectAllStaticFilterValues(id2));
      }
      dispatch(toggleExcludeStaticFilterValue({ id: id2, value }));
      dispatch(executeSearch$1({
        legacy: getLegacyAnalyticsActionForToggledValue(id2, value)
      }));
    },
    deselectAll() {
      dispatch(deselectAllStaticFilterValues(id2));
      dispatch(executeSearch$1({
        legacy: logStaticFilterClearAll({ staticFilterId: id2 })
      }));
    },
    isValueSelected(value) {
      return value.state === "selected";
    },
    isValueExcluded(value) {
      return value.state === "excluded";
    },
    get state() {
      const values = getState().staticFilterSet[id2]?.values || [];
      const hasActiveValues = values.some((value) => value.state !== "idle");
      return {
        id: id2,
        values,
        hasActiveValues
      };
    }
  };
}
function loadReducers(engine) {
  engine.addReducers({ staticFilterSet: staticFilterSetReducer });
  return true;
}
function getLegacyAnalyticsActionForToggledValue(id2, value) {
  const { caption, expression, state } = value;
  const analytics = state === "idle" ? logStaticFilterSelect : logStaticFilterDeselect;
  return analytics({
    staticFilterId: id2,
    staticFilterValue: { caption, expression }
  });
}
const optionsSchema$2 = new Schema({
  expression: requiredEmptyAllowedString,
  id: requiredNonEmptyString,
  clearFiltersOnTabChange: new BooleanValue()
});
const initialStateSchema$2 = new Schema({
  isActive: new BooleanValue()
});
function buildCoreTab(engine, props) {
  assertIdNotEqualToDefaultOriginLevel2(props.options.id);
  if (!loadTabReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  validateOptions(engine, optionsSchema$2, props.options, "buildTab");
  const initialState2 = validateInitialState(engine, initialStateSchema$2, props.initialState, "buildTab");
  const { id: id2, expression } = props.options;
  dispatch(registerTab({ id: id2, expression }));
  const isFirstTab = Object.keys(engine.state.tabSet).length === 1;
  if (isFirstTab) {
    initialState2.isActive = true;
  }
  if (initialState2.isActive) {
    dispatch(updateActiveTab(id2));
  }
  return {
    ...controller,
    select() {
      if (props.options.clearFiltersOnTabChange) {
        dispatch(prepareForSearchWithQuery({
          q: "",
          clearFilters: true
        }));
      }
      dispatch(updateActiveTab(id2));
    },
    get state() {
      const isActive = engine.state.tabSet[id2]?.isActive;
      return {
        isActive
      };
    }
  };
}
function loadTabReducers(engine) {
  engine.addReducers({ configuration, tabSet: tabSetReducer });
  return true;
}
function assertIdNotEqualToDefaultOriginLevel2(id2) {
  const defaultOriginLevel2 = getConfigurationInitialState$1().analytics.originLevel2;
  if (id2 === defaultOriginLevel2) {
    throw new Error(`The #id option on the Tab controller cannot use the reserved value "${defaultOriginLevel2}". Please specify a different value.`);
  }
}
function buildTab(engine, props) {
  const { dispatch } = engine;
  const tab = buildCoreTab(engine, props);
  const search = () => dispatch(executeSearch$1({
    legacy: logInterfaceChange(),
    next: interfaceChange()
  }));
  return {
    ...tab,
    get state() {
      return tab.state;
    },
    select() {
      tab.select();
      search();
    }
  };
}
function handleFetchItemsPending(state) {
  state.query = "";
  state.queryModification = {
    originalQuery: "",
    newQuery: "",
    queryToIgnore: state.queryModification.queryToIgnore
  };
  return state;
}
function handleFetchItemsFulfilled(state, triggers) {
  const redirectTriggers = [];
  const queryTriggers = [];
  const executeTriggers = [];
  const notifyTriggers = [];
  triggers.forEach((trigger) => {
    switch (trigger.type) {
      case "redirect":
        redirectTriggers.push(trigger.content);
        break;
      case "query":
        queryTriggers.push(trigger.content);
        break;
      case "execute":
        executeTriggers.push({
          functionName: trigger.content.name,
          params: trigger.content.params
        });
        break;
      case "notify":
        notifyTriggers.push(trigger.content);
        break;
    }
  });
  state.redirectTo = redirectTriggers[0] ?? "";
  state.query = state.queryModification.newQuery;
  state.executions = executeTriggers;
  state.notifications = notifyTriggers;
  return state;
}
function handleApplyQueryTriggerModification(state, payload) {
  state.queryModification = { ...payload, queryToIgnore: "" };
  return state;
}
function handleUpdateIgnoreQueryTrigger(state, payload) {
  state.queryModification.queryToIgnore = payload;
  return state;
}
const getTriggerInitialState = () => ({
  redirectTo: "",
  query: "",
  executions: [],
  notifications: [],
  queryModification: { originalQuery: "", newQuery: "", queryToIgnore: "" }
});
const triggerReducer = createReducer(getTriggerInitialState(), (builder) => builder.addCase(executeSearch$1.pending, handleFetchItemsPending).addCase(executeSearch$1.fulfilled, (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)).addCase(applyQueryTriggerModification$1, (state, action) => handleApplyQueryTriggerModification(state, action.payload)).addCase(updateIgnoreQueryTrigger$1, (state, action) => handleUpdateIgnoreQueryTrigger(state, action.payload)));
function buildExecuteTrigger(engine) {
  if (!loadExecuteTriggerReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousExecutions = getState().triggers.executions;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(this.state.executions, previousExecutions, (first, second) => first.functionName === second.functionName && arrayEqual(first.params, second.params));
        previousExecutions = this.state.executions;
        if (hasChanged && this.state.executions.length) {
          listener();
          dispatch(logTriggerExecute());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        executions: getState().triggers.executions
      };
    }
  };
}
function loadExecuteTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}
function buildCoreNotifyTrigger(engine, props) {
  const logNotifyTrigger2 = props.options.logNotifyTriggerActionCreator;
  if (!loadNotifyTriggerReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousNotifications = getState().triggers.notifications;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = !arrayEqual(previousNotifications, this.state.notifications);
        previousNotifications = this.state.notifications;
        if (hasChanged) {
          listener();
          dispatch(logNotifyTrigger2());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        notifications: getState().triggers.notifications
      };
    }
  };
}
function loadNotifyTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}
function buildNotifyTrigger(engine) {
  return buildCoreNotifyTrigger(engine, {
    options: {
      logNotifyTriggerActionCreator: logNotifyTrigger
    }
  });
}
function buildQueryTrigger(engine) {
  if (!loadQueryTriggerReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const modification = () => getState().triggers.queryModification.newQuery;
  const originalQuery = () => getState().triggers.queryModification.originalQuery;
  return {
    ...controller,
    get state() {
      return {
        newQuery: modification(),
        originalQuery: originalQuery(),
        wasQueryModified: modification() !== ""
      };
    },
    undo() {
      dispatch(updateIgnoreQueryTrigger$1(modification()));
      dispatch(updateQuery$2({ q: originalQuery() }));
      dispatch(executeSearch$1({
        legacy: logUndoTriggerQuery({
          undoneQuery: modification()
        })
      }));
    }
  };
}
function loadQueryTriggerReducers(engine) {
  engine.addReducers({ triggers: triggerReducer, query: queryReducer$1 });
  return true;
}
function buildRedirectionTrigger(engine) {
  if (!loadRedirectionReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  let previousRedirectTo = getState().triggers.redirectTo;
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const hasChanged = previousRedirectTo !== this.state.redirectTo;
        previousRedirectTo = this.state.redirectTo;
        if (hasChanged && this.state.redirectTo) {
          listener();
          dispatch(logTriggerRedirect());
        }
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        redirectTo: getState().triggers.redirectTo
      };
    }
  };
}
function loadRedirectionReducers(engine) {
  engine.addReducers({ triggers: triggerReducer });
  return true;
}
const rangeDelimiterExclusive = "..";
const rangeDelimiterInclusive = "...";
const facetSearchParamRegex = /^(f|fExcluded|cf|nf|df|sf|af|mnf)-(.+)$/;
const supportedFacetParameters$1 = {
  f: true,
  fExcluded: true,
  cf: true,
  sf: true,
  af: true,
  nf: true,
  df: true,
  mnf: true
};
const delimiter = "&";
const equal = "=";
function buildSearchParameterSerializer() {
  return { serialize: serialize$1(serializePair$1), deserialize: deserialize$1 };
}
function keyHasObjectValue$1(key) {
  return key in supportedFacetParameters$1;
}
function isValidBasicKey$1(key) {
  const supportedBasicParameters = {
    q: true,
    aq: true,
    cq: true,
    enableQuerySyntax: true,
    firstResult: true,
    numberOfResults: true,
    sortCriteria: true,
    debug: true,
    tab: true
  };
  return key in supportedBasicParameters;
}
function isRangeFacetKey(key) {
  const supportedRangeFacetParameters = {
    nf: true,
    df: true,
    mnf: true
  };
  const isRangeFacet = key in supportedRangeFacetParameters;
  return keyHasObjectValue$1(key) && isRangeFacet;
}
function isValidKey$1(key) {
  return isValidBasicKey$1(key) || keyHasObjectValue$1(key);
}
const serialize$1 = (pairSerializer) => (obj) => {
  return Object.entries(obj).map(pairSerializer).filter((str) => str).join(delimiter);
};
function serializePair$1(pair) {
  const [key, val] = pair;
  if (!isValidKey$1(key)) {
    return "";
  }
  if (keyHasObjectValue$1(key) && !isRangeFacetKey(key)) {
    return isFacetObject(val) ? serializeFacets(key, val) : "";
  }
  if (key === "nf" || key === "df") {
    return isRangeFacetObject(val) ? serializeRangeFacets(key, val) : "";
  }
  return serializeSpecialCharacters(key, val);
}
function serializeSpecialCharacters(key, val) {
  return `${key}${equal}${encodeURIComponent(val)}`;
}
function isFacetObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const isValidValue = (v) => typeof v === "string";
  return allEntriesAreValid(obj, isValidValue);
}
function isRangeFacetObject(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const isRangeValue = (v) => isObject(v) && "start" in v && "end" in v;
  return allEntriesAreValid(obj, isRangeValue);
}
function isObject(obj) {
  return !!(obj && typeof obj === "object");
}
function allEntriesAreValid(obj, isValidValue) {
  const invalidEntries = Object.entries(obj).filter((entry) => {
    const values = entry[1];
    return !Array.isArray(values) || !values.every(isValidValue);
  });
  return invalidEntries.length === 0;
}
function serializeFacets(key, facets) {
  return Object.entries(facets).map(([facetId2, values]) => `${key}-${facetId2}${equal}${values.map((value) => encodeURIComponent(value)).join(",")}`).join(delimiter);
}
function serializeRangeFacets(key, facets) {
  return Object.entries(facets).map(([facetId2, ranges]) => {
    const value = ranges.map(({ start, end, endInclusive }) => `${start}${endInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive}${end}`).join(",");
    return `${key}-${facetId2}${equal}${value}`;
  }).join(delimiter);
}
function deserialize$1(fragment) {
  const parts = fragment.split(delimiter);
  const keyValuePairs = parts.map((part) => splitOnFirstEqual(part)).map((parts2) => preprocessObjectPairs(parts2)).filter(isValidPair$1).map((pair) => cast$1(pair));
  return keyValuePairs.reduce((acc, pair) => {
    const [key, val] = pair;
    if (keyHasObjectValue$1(key)) {
      const mergedValues = { ...acc[key], ...val };
      return { ...acc, [key]: mergedValues };
    }
    return { ...acc, [key]: val };
  }, {});
}
function splitOnFirstEqual(str) {
  const [first, ...rest] = str.split(equal);
  const second = rest.join(equal);
  return [first, second];
}
function preprocessObjectPairs(pair, regex = facetSearchParamRegex) {
  const [key, val] = pair;
  const result = regex.exec(key);
  if (!result) {
    return pair;
  }
  const paramKey = result[1];
  const id2 = result[2];
  const values = val.split(",");
  const processedValues = processObjectValues(paramKey, values);
  const obj = { [id2]: processedValues };
  return [paramKey, JSON.stringify(obj)];
}
function processObjectValues(key, values) {
  if (key === "nf" || key === "mnf") {
    return buildNumericRanges(values, "selected");
  }
  if (key === "df") {
    return buildDateRanges(values, "selected");
  }
  return values;
}
function buildNumericRanges(ranges, state) {
  const numericRanges = [];
  for (const range of ranges) {
    const { startAsString, endAsString, isEndInclusive } = splitRangeValueAsStringByDelimiter(range);
    const start = parseFloat(startAsString);
    const end = parseFloat(endAsString);
    if (!Number.isFinite(start) || !Number.isFinite(end)) {
      continue;
    }
    numericRanges.push(buildNumericRange({ start, end, state, endInclusive: isEndInclusive }));
  }
  return numericRanges;
}
function isValidDateRangeValue(date) {
  try {
    if (isSearchApiDate(date)) {
      validateAbsoluteDate(date, API_DATE_FORMAT);
      return true;
    }
    if (isRelativeDateFormat(date)) {
      validateRelativeDate(date);
      return true;
    }
    return false;
  } catch (_) {
    return false;
  }
}
function buildDateRanges(ranges, state) {
  const dateRanges2 = [];
  for (const range of ranges) {
    const { isEndInclusive, startAsString, endAsString } = splitRangeValueAsStringByDelimiter(range);
    if (!isValidDateRangeValue(startAsString) || !isValidDateRangeValue(endAsString)) {
      continue;
    }
    dateRanges2.push(buildDateRange({
      start: startAsString,
      end: endAsString,
      state,
      endInclusive: isEndInclusive
    }));
  }
  return dateRanges2;
}
function isValidPair$1(pair) {
  const validKey = isValidKey$1(pair[0]);
  const lengthOfTwo = pair.length === 2;
  return validKey && lengthOfTwo;
}
function cast$1(pair, decode = true) {
  const [key, value] = pair;
  if (key === "enableQuerySyntax") {
    return [key, value === "true"];
  }
  if (key === "debug") {
    return [key, value === "true"];
  }
  if (key === "firstResult") {
    return [key, parseInt(value)];
  }
  if (key === "numberOfResults") {
    return [key, parseInt(value)];
  }
  if (keyHasObjectValue$1(key)) {
    return [key, castUnknownObject(value)];
  }
  return [key, decode ? decodeURIComponent(value) : value];
}
function castUnknownObject(value) {
  const jsonParsed = JSON.parse(value);
  const ret = {};
  Object.entries(jsonParsed).forEach((entry) => {
    const [id2, values] = entry;
    ret[id2] = values.map((v) => isString(v) ? decodeURIComponent(v) : v);
  });
  return ret;
}
function splitRangeValueAsStringByDelimiter(str) {
  const isEndInclusive = str.indexOf(rangeDelimiterInclusive) !== -1;
  const [startAsString, endAsString] = str.split(isEndInclusive ? rangeDelimiterInclusive : rangeDelimiterExclusive);
  return {
    isEndInclusive,
    startAsString,
    endAsString
  };
}
const initialStateSchema$1 = new Schema({
  fragment: new StringValue()
});
function buildUrlManager(engine, props) {
  let lastRequestId;
  function updateLastRequestId() {
    lastRequestId = engine.state.search.requestId;
  }
  function hasRequestIdChanged() {
    return lastRequestId !== engine.state.search.requestId;
  }
  if (!loadUrlManagerReducers(engine)) ;
  validateInitialState(engine, initialStateSchema$1, props.initialState, "buildUrlManager");
  const controller = buildController(engine);
  let previousFragment = props.initialState.fragment;
  updateLastRequestId();
  const searchParameterManager = buildSearchParameterManager(engine, {
    initialState: {
      parameters: deserializeFragment(previousFragment)
    }
  });
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const newFragment = this.state.fragment;
        if (!areFragmentsEquivalent$1(previousFragment, newFragment) && hasRequestIdChanged()) {
          previousFragment = newFragment;
          listener();
        }
        updateLastRequestId();
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        fragment: buildSearchParameterSerializer().serialize(searchParameterManager.state.parameters)
      };
    },
    synchronize(fragment) {
      previousFragment = fragment;
      const parameters = deserializeFragment(fragment);
      searchParameterManager.synchronize(parameters);
    }
  };
}
function areFragmentsEquivalent$1(fragment1, fragment2) {
  if (fragment1 === fragment2) {
    return true;
  }
  const params1 = deserializeFragment(fragment1);
  const params2 = deserializeFragment(fragment2);
  return deepEqualAnyOrder(params1, params2);
}
function deserializeFragment(fragment) {
  return buildSearchParameterSerializer().deserialize(fragment);
}
function loadUrlManagerReducers(engine) {
  engine.addReducers({ configuration });
  return true;
}
createAsyncThunk("analytics/addPageViewEntry", async (itemPermanentId, { getState }) => {
  const state = getState();
  if (state.configuration.analytics.enabled) {
    HistoryStore2.getInstance().addElement({
      name: "PageView",
      value: itemPermanentId,
      time: JSON.stringify(/* @__PURE__ */ new Date())
    });
  }
});
const optionalAndPossiblyEmpty = () => new StringValue({ required: false, emptyAllowed: true });
const updateAdvancedSearchQueries = createAction("advancedSearchQueries/update", (payload) => validatePayload(payload, {
  aq: optionalAndPossiblyEmpty(),
  cq: optionalAndPossiblyEmpty(),
  lq: optionalAndPossiblyEmpty(),
  dq: optionalAndPossiblyEmpty()
}));
const registerAdvancedSearchQueries = createAction("advancedSearchQueries/register", (payload) => validatePayload(payload, {
  aq: optionalAndPossiblyEmpty(),
  cq: optionalAndPossiblyEmpty(),
  lq: optionalAndPossiblyEmpty(),
  dq: optionalAndPossiblyEmpty()
}));
createReducer(getAdvancedSearchQueriesInitialState(), (builder) => {
  builder.addCase(updateAdvancedSearchQueries, (state, action) => {
    const { aq, cq, lq, dq } = action.payload;
    if (!isUndefined(aq)) {
      state.aq = aq;
      state.aqWasSet = true;
    }
    if (!isUndefined(cq)) {
      state.cq = cq;
      state.cqWasSet = true;
    }
    if (!isUndefined(lq)) {
      state.lq = lq;
      state.lqWasSet = true;
    }
    if (!isUndefined(dq)) {
      state.dq = dq;
      state.dqWasSet = true;
    }
  }).addCase(registerAdvancedSearchQueries, (state, action) => {
    const { aq, cq, lq, dq } = action.payload;
    if (!isUndefined(aq)) {
      state.defaultFilters.aq = aq;
      if (!state.aqWasSet) {
        state.aq = aq;
      }
    }
    if (!isUndefined(cq)) {
      state.defaultFilters.cq = cq;
      if (!state.cqWasSet) {
        state.cq = cq;
      }
    }
    if (!isUndefined(lq)) {
      state.defaultFilters.lq = lq;
      if (!state.lqWasSet) {
        state.lq = lq;
      }
    }
    if (!isUndefined(dq)) {
      state.defaultFilters.dq = dq;
      if (!state.dqWasSet) {
        state.dq = dq;
      }
    }
  }).addCase(change.fulfilled, (state, action) => action.payload?.advancedSearchQueries ?? state).addCase(restoreSearchParameters$1, (state, action) => {
    const { aq, cq } = action.payload;
    if (!isUndefined(aq)) {
      state.aq = aq;
      state.aqWasSet = true;
    }
    if (!isUndefined(cq)) {
      state.cq = cq;
      state.cqWasSet = true;
    }
  });
});
function loadSearchAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logClearBreadcrumbs,
    logInterfaceLoad,
    logSearchFromLink,
    logOmniboxFromLink,
    logInterfaceChange,
    logDidYouMeanClick,
    logCategoryFacetBreadcrumb,
    logFacetBreadcrumb,
    logFacetClearAll,
    logFacetUnexclude,
    logFacetExclude,
    logFacetDeselect,
    logFacetSelect,
    logFacetShowLess,
    logFacetShowMore,
    logFacetUpdateSort,
    logDateFacetBreadcrumb,
    logNumericFacetBreadcrumb,
    logNavigateBackward,
    logNavigateForward,
    logPageNext,
    logPageNumber,
    logPagePrevious,
    logPagerResize,
    logSearchboxSubmit,
    logQuerySuggestionClick,
    logResultsSort,
    logDislikeSmartSnippet,
    logLikeSmartSnippet,
    logOpenSmartSnippetFeedbackModal,
    logCloseSmartSnippetFeedbackModal,
    logSmartSnippetFeedback,
    logSmartSnippetDetailedFeedback,
    logExpandSmartSnippet,
    logCollapseSmartSnippet,
    logExpandSmartSnippetSuggestion,
    logCollapseSmartSnippetSuggestion,
    logNoResultsBack,
    logStaticFilterSelect,
    logStaticFilterDeselect,
    logStaticFilterClearAll,
    logTriggerQuery,
    logUndoTriggerQuery,
    logNotifyTrigger,
    logTriggerRedirect,
    logTriggerExecute
  };
}
const setExcerptLength = createAction("excerptLength/set", (length) => validatePayload(length, new NumberValue({ min: 0, required: true })));
function getExcerptLengthInitialState() {
  return {
    length: void 0
  };
}
createReducer(getExcerptLengthInitialState(), (builder) => {
  builder.addCase(setExcerptLength, (state, action) => {
    state.length = action.payload;
  });
});
function loadPaginationActions(engine) {
  engine.addReducers({ pagination: paginationReducer$1 });
  return {
    nextPage: nextPage$1,
    previousPage: previousPage$1,
    registerNumberOfResults,
    registerPage,
    updateNumberOfResults,
    updatePage
  };
}
function loadQueryActions(engine) {
  engine.addReducers({ query: queryReducer$1 });
  return {
    updateQuery: updateQuery$2
  };
}
function getNegationPrefix(config) {
  return config.negate ? "NOT " : "";
}
function getOperatorSymbol(operator) {
  const dictionary = {
    contains: "=",
    differentThan: "<>",
    fuzzyMatch: "~=",
    greaterThan: ">",
    greaterThanOrEqual: ">=",
    isExactly: "==",
    lowerThan: "<",
    lowerThanOrEqual: "<=",
    phoneticMatch: "%=",
    regexMatch: "/=",
    wildcardMatch: "*="
  };
  return dictionary[operator];
}
function buildDateField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const operator = getOperatorSymbol(config.operator);
      const prefix = getNegationPrefix(config);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}
function buildDateRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}
function buildExactMatch(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { expression } = config;
      return `${prefix}"${expression}"`;
    }
  };
}
function buildFieldExists(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2 } = config;
      return `${prefix}@${field2}`;
    }
  };
}
function buildKeyword(config) {
  return {
    toQuerySyntax() {
      const { expression, negate } = config;
      return negate ? `NOT (${expression})` : expression;
    }
  };
}
function buildNear(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { startTerm, otherTerms } = config;
      const otherTermsExpression = buildOtherTerms(otherTerms);
      const expression = `${startTerm} ${otherTermsExpression}`;
      return config.negate ? `${prefix}(${expression})` : expression;
    }
  };
}
function buildOtherTerms(terms) {
  return terms.map((term) => {
    const { endTerm, maxKeywordsBetween } = term;
    return `near:${maxKeywordsBetween} ${endTerm}`;
  }).join(" ");
}
function buildNumericField(config) {
  return {
    toQuerySyntax() {
      const { field: field2, value } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      return `${prefix}@${field2}${operator}${value}`;
    }
  };
}
function buildNumericRangeField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, from, to } = config;
      const operator = getOperatorSymbol("isExactly");
      return `${prefix}@${field2}${operator}${from}..${to}`;
    }
  };
}
function buildQueryExtension(config) {
  return {
    toQuerySyntax() {
      const { name, parameters } = config;
      const argumentExpression = buildParameters(parameters);
      return `$${name}(${argumentExpression})`;
    }
  };
}
function buildParameters(params) {
  return Object.entries(params).map((entry) => {
    const [name, value] = entry;
    const formatted = typeof value === "string" ? value : value.toQuerySyntax();
    return `${name}: ${formatted}`;
  }).join(", ");
}
function buildStringFacetField(config) {
  return {
    toQuerySyntax() {
      const prefix = getNegationPrefix(config);
      const { field: field2, operator, value } = config;
      const symbol = getOperatorSymbol(operator);
      const formattedValue = operator === "fuzzyMatch" ? ` $quoteVar(value: ${value})` : `("${value}")`;
      return `${prefix}@${field2}${symbol}${formattedValue}`;
    }
  };
}
function buildStringField(config) {
  return {
    toQuerySyntax() {
      const { field: field2 } = config;
      const prefix = getNegationPrefix(config);
      const operator = getOperatorSymbol(config.operator);
      const processed = config.values.map((value) => `"${value}"`);
      const values = processed.length === 1 ? processed[0] : `(${processed.join(",")})`;
      return `${prefix}@${field2}${operator}${values}`;
    }
  };
}
function buildQueryExpression() {
  const parts = [];
  let booleanOperator = "and";
  return {
    addExpression(expression) {
      parts.push(expression);
      return this;
    },
    addKeyword(expression) {
      parts.push(buildKeyword(expression));
      return this;
    },
    addNear(expression) {
      parts.push(buildNear(expression));
      return this;
    },
    addExactMatch(expression) {
      parts.push(buildExactMatch(expression));
      return this;
    },
    addFieldExists(expression) {
      parts.push(buildFieldExists(expression));
      return this;
    },
    addStringField(expression) {
      parts.push(buildStringField(expression));
      return this;
    },
    addStringFacetField(expression) {
      parts.push(buildStringFacetField(expression));
      return this;
    },
    addNumericField(expression) {
      parts.push(buildNumericField(expression));
      return this;
    },
    addNumericRangeField(expression) {
      parts.push(buildNumericRangeField(expression));
      return this;
    },
    addDateField(expression) {
      parts.push(buildDateField(expression));
      return this;
    },
    addDateRangeField(expression) {
      parts.push(buildDateRangeField(expression));
      return this;
    },
    addQueryExtension(expression) {
      parts.push(buildQueryExtension(expression));
      return this;
    },
    joinUsing(operator) {
      booleanOperator = operator;
      return this;
    },
    toQuerySyntax() {
      const symbol = getBooleanOperatorSymbol(booleanOperator);
      const expression = parts.map((part) => part.toQuerySyntax()).join(`) ${symbol} (`);
      return parts.length <= 1 ? expression : `(${expression})`;
    }
  };
}
function getBooleanOperatorSymbol(operator) {
  return operator === "and" ? "AND" : "OR";
}
function AboutPage() {
  return /* @__PURE__ */ jsx("h1", { children: "About page" });
}
const SearchBox$1 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  const isEnterKey = (e) => e.key === "Enter";
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        value: state.value,
        onChange: (e) => controller.updateText(e.target.value),
        onKeyDown: (e) => isEnterKey(e) && controller.submit()
      }
    ),
    /* @__PURE__ */ jsx("ul", { children: state.suggestions.map((suggestion) => {
      const value = suggestion.rawValue;
      return /* @__PURE__ */ jsx(
        "li",
        {
          onClick: () => controller.selectSuggestion(value),
          onKeyDown: (e) => {
            if (e.key === "Enter" || e.key === " ") {
              controller.selectSuggestion(value);
            }
          },
          children: value
        },
        value
      );
    }) })
  ] });
};
const fakeDataLayer = {
  push: () => {
  }
};
window.dataLayer = fakeDataLayer;
const pushToGoogleDataLayer = (payload) => {
  window.dataLayer.push(payload);
};
class AnalyticsHook extends Component {
  engine;
  searchBox;
  constructor(props) {
    super(props);
    this.state = { analyticsPayload: {} };
    const sampleConfig = getSampleSearchEngineConfiguration();
    this.engine = buildSearchEngine({
      configuration: {
        ...sampleConfig,
        analytics: {
          /**
           * The analytics client middleware lets you access all the standard search page analytics events data.
           *
           * This allows you to modify or augment the standard payload and return the modified object.
           *
           * You can also use this hook to simply push data to an external system, such as Google Tag Manager.
           *
           */
          analyticsClientMiddleware: (_eventType, payload) => {
            this.setState({ analyticsPayload: payload });
            pushToGoogleDataLayer(payload);
            return payload;
          }
        }
      }
    });
    this.searchBox = buildSearchBox(this.engine);
  }
  render() {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(SearchBox$1, { controller: this.searchBox }),
      /* @__PURE__ */ jsx("p", { children: "Use the searchbox to input queries and print to the analytics payload below" }),
      /* @__PURE__ */ jsx("code", { children: JSON.stringify(this.state.analyticsPayload, null, 4) })
    ] });
  }
}
const Section = (props) => {
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("p", { children: props.title }),
    props.children
  ] });
};
function CommerceApp() {
  const activeNavLink = { color: "red" };
  return /* @__PURE__ */ jsxs(Section, { title: "commerce", children: [
    /* @__PURE__ */ jsxs("nav", { children: [
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          end: true,
          to: "/commerce/search",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Search"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          end: true,
          to: "/commerce/product-listing",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Product Listing"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          end: true,
          to: "/commerce/recommendations",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Recommendations"
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx(Outlet, {})
  ] });
}
var Search$1;
(function(Search2) {
  Search2.responseIdSelector = wrapWithAccessFromEngine(responseIdSelector);
})(Search$1 || (Search$1 = {}));
var ProductListing$1;
(function(ProductListing2) {
  ProductListing2.responseIdSelector = wrapWithAccessFromEngine(responseIdSelector$1);
})(ProductListing$1 || (ProductListing$1 = {}));
function wrapWithAccessFromEngine(selector) {
  return (engine) => selector(engine[stateKey]);
}
const updateBasicConfiguration = createAction("commerce/configuration/updateBasicConfiguration", (payload) => validatePayload(payload, {
  accessToken: nonEmptyString,
  environment: new StringValue({
    required: false,
    constrainTo: ["prod", "hipaa", "stg", "dev"]
  }),
  organizationId: nonEmptyString
}));
const updateProxyBaseUrl = createAction("commerce/configuration/updateProxyBaseUrl", (payload) => validatePayload(payload, {
  proxyBaseUrl: new StringValue({ required: false, url: true })
}));
const updateAnalyticsConfiguration = createAction("commerce/configuration/updateAnalyticsConfiguration", (payload) => {
  return validatePayload(payload, {
    enabled: analyticsConfigurationSchema.enabled,
    proxyBaseUrl: analyticsConfigurationSchema.proxyBaseUrl,
    source: analyticsConfigurationSchema.source,
    trackingId: requiredTrackingId
  });
});
const disableAnalytics = createAction("commerce/configuration/analytics/disable");
const enableAnalytics = createAction("commerce/configuration/analytics/enable");
const getConfigurationInitialState = () => ({
  accessToken: "",
  environment: "prod",
  organizationId: "",
  analytics: {
    enabled: true,
    trackingId: "",
    source: {}
  },
  commerce: {}
});
const configurationReducer = createReducer(getConfigurationInitialState(), (builder) => builder.addCase(updateBasicConfiguration, (state, action) => {
  handleUpdateBasicConfiguration(state, action.payload);
}).addCase(updateBasicConfiguration$1, (state, action) => {
  handleUpdateBasicConfiguration(state, action.payload);
}).addCase(updateProxyBaseUrl, (state, action) => {
  handleUpdateCommerceProxyBaseUrl(state, action.payload);
}).addCase(updateAnalyticsConfiguration, (state, action) => {
  handleupdateAnalyticsConfiguration(state, action.payload);
}).addCase(disableAnalytics, (state) => {
  state.analytics.enabled = false;
}).addCase(enableAnalytics, (state) => {
  state.analytics.enabled = true;
}));
function handleUpdateBasicConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.accessToken)) {
    state.accessToken = payload.accessToken;
  }
  state.environment = payload.environment ?? "prod";
  if (!isNullOrUndefined(payload.organizationId)) {
    state.organizationId = payload.organizationId;
  }
}
function handleUpdateCommerceProxyBaseUrl(state, payload) {
  if (!isNullOrUndefined(payload.proxyBaseUrl)) {
    state.commerce.apiBaseUrl = payload.proxyBaseUrl;
  }
}
function handleupdateAnalyticsConfiguration(state, payload) {
  if (!isNullOrUndefined(payload.enabled)) {
    state.analytics.enabled = payload.enabled;
  }
  if (!isNullOrUndefined(payload.proxyBaseUrl)) {
    state.analytics.apiBaseUrl = payload.proxyBaseUrl;
  }
  if (!isNullOrUndefined(payload.source)) {
    state.analytics.source = payload.source;
  }
  if (!isNullOrUndefined(payload.trackingId)) {
    state.analytics.trackingId = payload.trackingId;
  }
}
function getCurrency(state) {
  return state.currency;
}
const getECPurchasePayload = (transaction, state) => ({
  currency: getCurrency(state.commerceContext),
  products: productQuantitySelector(state.cart),
  transaction
});
const getECCartActionPayload = (cartActionDetails, state) => ({
  currency: getCurrency(state.commerceContext),
  ...cartActionDetails
});
const itemsSelector = createSelector((cartState) => cartState.cart, (cartState) => cartState.cartItems, (cart, cartItems) => cartItems.map((key) => cart[key]));
const productQuantitySelector = createSelector(itemsSelector, (items) => items.map(({ quantity, ...product }) => ({
  quantity,
  product
})));
const itemPayloadDefinition = {
  productId: requiredNonEmptyString,
  quantity: new NumberValue({
    required: true,
    min: 0
  }),
  name: new StringValue({ required: false }),
  price: new NumberValue({ required: false, min: 0 })
};
const setItemsPayloadDefinition = new ArrayValue({
  each: new RecordValue({
    values: {
      ...itemPayloadDefinition
    }
  })
});
const cartDefinition = {
  items: setItemsPayloadDefinition
};
const setItems = createAction("commerce/cart/setItems", (payload) => validatePayload(payload, setItemsPayloadDefinition));
const updateItemQuantity = createAction("commerce/cart/updateItemQuantity", (payload) => validatePayload(payload, itemPayloadDefinition));
const purchase = createAction("commerce/cart/purchase");
createAsyncThunk("commerce/cart/emit/purchaseEvent", async (payload, { extra, getState }) => {
  const relayPayload = getECPurchasePayload(payload, getState());
  const { relay } = extra;
  relay.emit("ec.purchase", relayPayload);
});
createAsyncThunk("commerce/cart/emit/cartActionEvent", async (payload, { extra, getState }) => {
  const relayPayload = getECCartActionPayload(payload, getState());
  const { relay } = extra;
  relay.emit("ec.cartAction", relayPayload);
});
createSelector(itemsSelector, (items) => items.reduce((prev, cur) => prev + cur.quantity, 0));
createSelector(itemsSelector, (items) => items.reduce((prev, cur) => prev + cur.price * cur.quantity, 0));
function createCartKey(item) {
  return `${item.productId},${item.name},${item.price}`;
}
const cartReducer = createReducer(getCartInitialState(), (builder) => {
  builder.addCase(setItems, (state, { payload }) => {
    const { cart, cartItems } = payload.reduce((acc, item) => {
      const key = createCartKey(item);
      return {
        cartItems: [...acc.cartItems, key],
        cart: {
          ...acc.cart,
          [key]: item
        },
        purchasedItems: [],
        purchased: {}
      };
    }, getCartInitialState());
    setItemsInState(state, cartItems, cart);
  }).addCase(updateItemQuantity, (state, { payload }) => {
    const key = createCartKey(payload);
    if (!(key in state.cart)) {
      createItemInCart(payload, state);
      return;
    }
    if (payload.quantity <= 0) {
      deleteProductFromCart(payload, state);
      return;
    }
    state.cart[key] = payload;
    return;
  }).addCase(purchase, (state) => {
    setItemsAsPurchased(state);
    const { cart, cartItems } = getCartInitialState();
    setItemsInState(state, cartItems, cart);
  });
});
function setItemsInState(state, cartItems, cart) {
  state.cartItems = cartItems;
  state.cart = cart;
}
function createItemInCart(item, state) {
  if (item.quantity <= 0) {
    return;
  }
  const key = createCartKey(item);
  state.cartItems = [...state.cartItems, key];
  state.cart[key] = item;
}
function deleteProductFromCart(item, state) {
  const key = createCartKey(item);
  state.cartItems = state.cartItems.filter((cartKey) => cartKey !== key);
  delete state.cart[key];
}
function setItemsAsPurchased(state) {
  for (const key of state.cartItems) {
    if (key in state.purchased) {
      state.purchased[key].quantity += state.cart[key].quantity;
      continue;
    }
    state.purchasedItems = [...state.purchasedItems, key];
    state.purchased[key] = state.cart[key];
  }
}
const getContextInitialState = () => ({
  language: "",
  country: "",
  currency: "",
  view: {
    url: ""
  }
});
const contextReducer = createReducer(getContextInitialState(), (builder) => {
  builder.addCase(setContext, (_, { payload }) => {
    return payload;
  }).addCase(setView, (state, { payload }) => {
    state.view = payload;
  }).addCase(setLocation, (state, { payload }) => {
    state.location = payload;
  });
});
function getDidYouMeanInitialState() {
  return {
    wasCorrectedTo: "",
    queryCorrection: emptyNextCorrection(),
    originalQuery: ""
  };
}
const didYouMeanReducer = createReducer(getDidYouMeanInitialState(), (builder) => {
  builder.addCase(executeSearch.pending, (state) => {
    state.queryCorrection = emptyNextCorrection();
    state.wasCorrectedTo = "";
  }).addCase(executeSearch.fulfilled, (state, action) => {
    const { queryCorrection } = action.payload.response;
    state.originalQuery = action.payload.originalQuery;
    state.wasCorrectedTo = queryCorrection?.correctedQuery ?? "";
    state.queryCorrection = {
      correctedQuery: queryCorrection?.correctedQuery ?? queryCorrection?.corrections[0]?.correctedQuery ?? "",
      wordCorrections: queryCorrection?.corrections[0]?.wordCorrections ?? []
    };
  });
});
const updateCategoryFacetNumberOfValues = createAction("commerce/facets/categoryFacet/updateNumberOfValues", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  numberOfValues: new NumberValue({ required: false, min: 1 })
}));
const toggleSelectCategoryFacetValue = createAction("commerce/facets/categoryFacet/toggleSelectValue", (payload) => {
  try {
    validatePayloadAndThrow(payload.facetId, requiredNonEmptyString);
    validateCategoryFacetValue(payload.selection);
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const toggleSelectDateFacetValue = createAction("commerce/facets/dateFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({ values: dateFacetValueDefinition })
}));
const toggleExcludeDateFacetValue = createAction("commerce/facets/dateFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({ values: dateFacetValueDefinition })
}));
const updateDateFacetValues = createAction("commerce/facets/dateFacet/updateValues", (payload) => {
  try {
    validatePayloadAndThrow(payload, {
      facetId: requiredNonEmptyString,
      values: new ArrayValue({
        each: new RecordValue({ values: dateFacetValueDefinition })
      })
    });
    validateManualDateRanges({ currentValues: payload.values });
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const toggleSelectLocationFacetValue = createAction("commerce/facets/locationFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({ values: facetValueDefinition })
}));
const toggleSelectNumericFacetValue = createAction("commerce/facets/numericFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({
    values: numericFacetValueDefinition
  })
}));
const toggleExcludeNumericFacetValue = createAction("commerce/facets/numericFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({
    values: numericFacetValueDefinition
  })
}));
const updateNumericFacetValues = createAction("commerce/facets/numericFacet/updateValues", (payload) => {
  try {
    validatePayloadAndThrow(payload, {
      facetId: requiredNonEmptyString,
      values: new ArrayValue({
        each: new RecordValue({ values: numericFacetValueDefinition })
      })
    });
    validateManualNumericRanges({ currentValues: payload.values });
    return { payload, error: null };
  } catch (error) {
    return { payload, error: serializeSchemaValidationError(error) };
  }
});
const updateManualNumericFacetRange = createAction("commerce/facets/numericFacet/updateManualRange", (payload) => validatePayloadAndThrow(payload, {
  facetId: requiredNonEmptyString,
  ...numericFacetValueDefinition
}));
const numericFacetValueDefinition = {
  state: new StringValue({
    required: true,
    constrainTo: ["idle", "selected", "excluded"]
  }),
  start: new NumberValue({ required: true }),
  end: new NumberValue({ required: true }),
  endInclusive: new BooleanValue({ required: true })
};
const toggleExcludeFacetValue = createAction("commerce/facets/regularFacet/toggleExcludeValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({ values: facetValueDefinition })
}));
const toggleSelectFacetValue = createAction("commerce/facets/regularFacet/toggleSelectValue", (payload) => validatePayload(payload, {
  facetId: requiredNonEmptyString,
  selection: new RecordValue({ values: facetValueDefinition })
}));
function restoreFromParameters(state, action) {
  for (const facetId2 of Object.keys(state)) {
    delete state[facetId2];
  }
  if (action.payload.f) {
    restoreFacets(state, action.payload.f, "regular");
  }
  if (action.payload.lf) {
    restoreFacets(state, action.payload.lf, "location");
  }
  if (action.payload.nf) {
    restoreRangeFacets(state, action.payload.nf, "numericalRange");
  }
  if (action.payload.mnf) {
    restoreManualRangeFacets(state, action.payload.mnf);
  }
  if (action.payload.df) {
    restoreRangeFacets(state, action.payload.df, "dateRange");
  }
  if (action.payload.cf) {
    restoreCategoryFacets(state, action.payload.cf);
  }
}
function restoreFacets(state, parameterFacets, type) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, values] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type,
        values: values.map((value) => {
          const facetValue = {
            ...restoreFacetValue(),
            value
          };
          switch (type) {
            case "regular":
              return facetValue;
            case "location":
              return facetValue;
          }
        })
      }
    };
  }
}
function restoreRangeFacets(state, parameterFacets, type) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, values] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type,
        values: values.map((value) => {
          const rangeValue = {
            start: value.start,
            end: value.end,
            endInclusive: value.endInclusive,
            ...restoreFacetValue()
          };
          switch (type) {
            case "dateRange":
              return rangeValue;
            case "numericalRange":
              return rangeValue;
          }
        })
      }
    };
  }
}
function restoreManualRangeFacets(state, parameterFacets) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, values] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type: "numericalRange",
        interval: "continuous",
        values: values.map((value) => ({
          start: value.start,
          end: value.end,
          endInclusive: value.endInclusive,
          ...restoreFacetValue()
        }))
      }
    };
  }
}
function restoreCategoryFacets(state, parameterFacets) {
  const entries = Object.entries(parameterFacets);
  for (const [facetId2, path] of entries) {
    state[facetId2] = {
      request: {
        ...restoreFacet(facetId2),
        type: "hierarchical",
        values: [],
        // eslint-disable-next-line @cspell/spellchecker
        // TODO CAPI-966: Remove delimitingCharacter
        delimitingCharacter: "|",
        // In the CAPI, the default retrieveCount is 5, while the default
        // numberOfValues is 8. We explicitly set retrieveCount to 8 when
        // restoring category facets to ensure a consistent show more / show
        // less behavior, given that the retrieveCount is not returned in the
        // API response.
        retrieveCount: 8
      }
    };
    selectPath(state[facetId2].request, path);
  }
}
function restoreFacet(facetId2) {
  return {
    facetId: facetId2,
    field: facetId2,
    isFieldExpanded: false,
    preventAutoSelect: false
  };
}
function restoreFacetValue() {
  return {
    state: "selected",
    isAutoSelected: false,
    isSuggested: false,
    moreValuesAvailable: true
  };
}
function buildSelectedFacetValueRequest(rawValue) {
  return { state: "selected", value: rawValue };
}
function selectPath(request, path, initialNumberOfValues) {
  request.values = buildCurrentValuesFromPath(path);
  request.numberOfValues = initialNumberOfValues;
  request.preventAutoSelect = true;
}
function buildCurrentValuesFromPath(path) {
  if (!path.length) {
    return [];
  }
  const root = buildCategoryFacetValueRequest(path[0]);
  let curr = root;
  const [_first, ...rest] = path;
  for (const segment of rest) {
    const next = buildCategoryFacetValueRequest(segment);
    curr.children.push(next);
    curr = next;
  }
  curr.state = "selected";
  return [root];
}
function buildCategoryFacetValueRequest(value) {
  return {
    children: [],
    state: "idle",
    value
  };
}
function getCommerceFacetSetInitialState() {
  return {};
}
const commerceFacetSetReducer = createReducer(getCommerceFacetSetInitialState(), (builder) => {
  builder.addCase(fetchProductListing.fulfilled, handleQueryFulfilled).addCase(executeSearch.fulfilled, handleQueryFulfilled).addCase(executeCommerceFieldSuggest.fulfilled, (state, action) => handleFieldSuggestionsFulfilled(state, getFacetIdWithCommerceFieldSuggestionNamespace(action.payload.facetId))).addCase(fetchQuerySuggestions$1.fulfilled, (state, action) => {
    if (!action.payload.fieldSuggestionsFacets) {
      return;
    }
    for (const { facetId: facetId2 } of action.payload.fieldSuggestionsFacets) {
      handleFieldSuggestionsFulfilled(state, getFacetIdWithCommerceFieldSuggestionNamespace(facetId2));
    }
  }).addCase(toggleSelectFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.values.find((req2) => req2.value === selection.value);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "select");
    facetRequest.freezeCurrentValues = true;
  }).addCase(toggleSelectLocationFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureLocationFacetRequest(facetRequest)) {
      return;
    }
    const existingValue = facetRequest.values.find((req2) => req2.value === selection.value);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "select");
  }).addCase(toggleSelectNumericFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureNumericFacetRequest(facetRequest)) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = findExactRangeValue(facetRequest.values, selection);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "select");
    facetRequest.numberOfValues = facetRequest.initialNumberOfValues;
    if (facetRequest.interval === "continuous" && existingValue.state === "idle") {
      facetRequest.values = [];
      return;
    }
  }).addCase(toggleSelectDateFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureDateFacetRequest(facetRequest)) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = findExactRangeValue(facetRequest.values, selection);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "select");
  }).addCase(toggleSelectCategoryFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const request = state[facetId2]?.request;
    if (!ensureCategoryFacetRequest(request)) {
      return;
    }
    const { path } = selection;
    const pathToSelection = path.slice(0, path.length - 1);
    const children = ensurePathAndReturnChildren(request, pathToSelection);
    let selectedValue = children.find((value) => value.value === selection.value);
    if (!selectedValue) {
      selectedValue = buildCategoryFacetValueRequest(selection.value);
      children.push(selectedValue);
    }
    selectedValue.state = selectedValue.state === "idle" ? "selected" : "idle";
    if (selectedValue.state === "selected") {
      request.numberOfValues = request.initialNumberOfValues;
      request.retrieveCount = request.initialNumberOfValues;
    }
  }).addCase(toggleExcludeFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.values.find((req2) => req2.value === selection.value);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "exclude");
    facetRequest.freezeCurrentValues = true;
  }).addCase(toggleExcludeNumericFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureNumericFacetRequest(facetRequest)) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = findExactRangeValue(facetRequest.values, selection);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "exclude");
    facetRequest.numberOfValues = facetRequest.initialNumberOfValues;
    if (facetRequest.interval === "continuous" && existingValue.state === "idle") {
      facetRequest.values = [];
      return;
    }
  }).addCase(toggleExcludeDateFacetValue, (state, action) => {
    const { facetId: facetId2, selection } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureDateFacetRequest(facetRequest)) {
      return;
    }
    facetRequest.preventAutoSelect = true;
    const existingValue = findExactRangeValue(facetRequest.values, selection);
    if (!existingValue) {
      insertNewValue(facetRequest, selection);
      return;
    }
    updateExistingFacetValueState(existingValue, "exclude");
    facetRequest.numberOfValues = facetRequest.initialNumberOfValues;
  }).addCase(updateCategoryFacetNumberOfValues, (state, action) => {
    const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
    const request = state[facetId2]?.request;
    if (!ensureCategoryFacetRequest(request)) {
      return;
    }
    handleCategoryFacetUpdateNumberOfValues(request, numberOfValues2);
  }).addCase(selectFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
      return;
    }
    const { rawValue } = value;
    facetRequest.freezeCurrentValues = true;
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.values.find((v) => v.value === rawValue);
    if (!existingValue) {
      insertNewValue(facetRequest, buildSelectedFacetValueRequest(rawValue));
      return;
    }
    updateExistingFacetValueState(existingValue, "select");
  }).addCase(excludeFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest || !ensureRegularFacetRequest(facetRequest)) {
      return;
    }
    const { rawValue } = value;
    facetRequest.freezeCurrentValues = true;
    facetRequest.preventAutoSelect = true;
    const existingValue = facetRequest.values.find((v) => v.value === rawValue);
    if (!existingValue) {
      insertNewValue(facetRequest, { state: "excluded", value: rawValue });
      return;
    }
    updateExistingFacetValueState(existingValue, "exclude");
  }).addCase(selectCategoryFacetSearchResult, (state, action) => {
    const { facetId: facetId2, value } = action.payload;
    const request = state[facetId2]?.request;
    if (!ensureCategoryFacetRequest(request)) {
      return;
    }
    const path = [...value.path, value.rawValue];
    selectPath(request, path, request.initialNumberOfValues);
  }).addCase(updateNumericFacetValues, (state, action) => {
    const { facetId: facetId2, values } = action.payload;
    const request = state[facetId2]?.request;
    if (!request || !ensureNumericFacetRequest(request)) {
      return;
    }
    request.values = values;
    request.numberOfValues = values.length;
  }).addCase(updateDateFacetValues, (state, action) => {
    const { facetId: facetId2, values } = action.payload;
    const request = state[facetId2]?.request;
    if (!request || !ensureDateFacetRequest(request)) {
      return;
    }
    request.values = convertToDateRangeRequests(values);
    request.numberOfValues = values.length;
  }).addCase(updateCoreFacetNumberOfValues, (state, action) => {
    const { facetId: facetId2, numberOfValues: numberOfValues2 } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.numberOfValues = numberOfValues2;
  }).addCase(updateCoreFacetIsFieldExpanded, (state, action) => {
    const { facetId: facetId2, isFieldExpanded } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.isFieldExpanded = isFieldExpanded;
  }).addCase(updateAutoSelectionForAllCoreFacets, (state, action) => Object.values(state).forEach((slice) => {
    slice.request.preventAutoSelect = !action.payload.allow;
  })).addCase(updateCoreFacetFreezeCurrentValues, (state, action) => {
    const { facetId: facetId2, freezeCurrentValues } = action.payload;
    const facetRequest = state[facetId2]?.request;
    if (!facetRequest) {
      return;
    }
    facetRequest.freezeCurrentValues = freezeCurrentValues;
  }).addCase(deselectAllValuesInCoreFacet, (state, action) => {
    const { facetId: facetId2 } = action.payload;
    const request = state[facetId2]?.request;
    if (!request) {
      return;
    }
    handleDeselectAllFacetValues(request);
  }).addCase(updateManualNumericFacetRange, (state, action) => {
    const { facetId: facetId2 } = action.payload;
    const request = state[facetId2]?.request;
    if (!request) {
      return;
    }
    handleDeselectAllFacetValues(request);
  }).addCase(clearAllCoreFacets, setAllFacetValuesToIdle).addCase(deleteAllCoreFacets, clearAllFacetValues).addCase(setContext, clearAllFacetValues).addCase(setView, clearAllFacetValues).addCase(restoreSearchParameters, restoreFromParameters).addCase(restoreProductListingParameters, restoreFromParameters);
});
function ensureRegularFacetRequest(facetRequest) {
  return facetRequest.type === "regular";
}
function ensureLocationFacetRequest(facetRequest) {
  return facetRequest.type === "location";
}
function ensureNumericFacetRequest(facetRequest) {
  return facetRequest.type === "numericalRange";
}
function ensureDateFacetRequest(facetRequest) {
  return facetRequest.type === "dateRange";
}
function ensureCategoryFacetRequest(facetRequest) {
  return facetRequest?.type === "hierarchical";
}
function handleQueryFulfilled(state, action) {
  const existingFacets = new Set(Object.keys(state));
  const facets = action.payload.response.facets;
  for (const facetResponse of facets) {
    updateStateFromFacetResponse(state, facetResponse, existingFacets);
  }
  for (const facetId2 of existingFacets) {
    delete state[facetId2];
  }
}
function handleFieldSuggestionsFulfilled(state, facetId2) {
  let facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    state[facetId2] = { request: {} };
    facetRequest = state[facetId2].request;
    facetRequest.initialNumberOfValues = 10;
    facetRequest.values = [];
  }
}
function handleDeselectAllFacetValues(request) {
  const resetValues = () => {
    request.values.forEach((value) => {
      value.state = "idle";
    });
  };
  switch (request.type) {
    case "hierarchical":
      request.initialNumberOfValues = void 0;
      request.numberOfValues = void 0;
      request.values = [];
      request.preventAutoSelect = true;
      break;
    case "numericalRange":
      request.numberOfValues = request.initialNumberOfValues;
      resetValues();
      break;
    default:
      resetValues();
      break;
  }
}
function ensurePathAndReturnChildren(request, path) {
  let children = request.values;
  for (const segment of path) {
    let parent = children[0];
    const missingParent = !parent;
    if (missingParent || segment !== parent.value) {
      parent = buildCategoryFacetValueRequest(segment);
      children.length = 0;
      children.push(parent);
    }
    parent.state = "idle";
    children = parent.children;
  }
  return children;
}
function updateExistingFacetValueState(existingFacetValue, toggleAction) {
  switch (existingFacetValue.state) {
    case "idle":
      existingFacetValue.state = toggleAction === "exclude" ? "excluded" : "selected";
      break;
    case "excluded":
      existingFacetValue.state = toggleAction === "exclude" ? "idle" : "selected";
      break;
    case "selected":
      existingFacetValue.state = toggleAction === "exclude" ? "excluded" : "idle";
      break;
  }
}
function updateStateFromFacetResponse(state, facetResponse, facetsToRemove) {
  const facetId2 = facetResponse.facetId ?? facetResponse.field;
  let facetRequest = state[facetId2]?.request;
  if (!facetRequest) {
    state[facetId2] = { request: {} };
    facetRequest = state[facetId2].request;
  } else {
    facetsToRemove.delete(facetId2);
  }
  if (facetRequest.initialNumberOfValues === void 0) {
    facetRequest.initialNumberOfValues = facetResponse.numberOfValues;
  }
  facetRequest.facetId = facetId2;
  facetRequest.displayName = facetResponse.displayName;
  facetRequest.numberOfValues = facetResponse.numberOfValues;
  facetRequest.field = facetResponse.field;
  facetRequest.type = facetResponse.type;
  facetRequest.values = getFacetRequestValuesFromFacetResponse(facetResponse) ?? [];
  facetRequest.freezeCurrentValues = false;
  facetRequest.preventAutoSelect = false;
  if (facetResponse.type === "hierarchical" && ensureCategoryFacetRequest(facetRequest)) {
    facetRequest.delimitingCharacter = facetResponse.delimitingCharacter;
  } else if (facetResponse.type === "numericalRange") {
    facetRequest.interval = facetResponse.interval;
    if (facetResponse.domain) {
      facetRequest.domain = {
        min: facetResponse.domain.min,
        max: facetResponse.domain.max,
        increment: facetResponse.domain.increment
      };
    }
  }
}
function getFacetRequestValuesFromFacetResponse(facetResponse) {
  switch (facetResponse.type) {
    case "numericalRange":
      return convertToNumericRangeRequests(facetResponse.values);
    case "dateRange":
      return convertToDateRangeRequests(facetResponse.values);
    case "hierarchical":
      return facetResponse.values.map(convertCategoryFacetValueToRequest);
    case "regular":
      return facetResponse.values.map(convertFacetValueToRequest);
    case "location":
      return facetResponse.values.map(convertLocationFacetValueToRequest);
    default:
      return;
  }
}
function convertCategoryFacetValueToRequest(responseValue) {
  const children = responseValue.children.map(convertCategoryFacetValueToRequest);
  const { state, value } = responseValue;
  return {
    children,
    state,
    value
  };
}
function convertLocationFacetValueToRequest(facetValue) {
  const { value, state } = facetValue;
  return { value, state };
}
function insertNewValue(facetRequest, facetValue) {
  const { values } = facetRequest;
  const firstIdleIndex = values.findIndex((v) => v.state === "idle");
  const indexToInsertAt = firstIdleIndex === -1 ? values.length : firstIdleIndex;
  facetRequest.values.splice(indexToInsertAt, 0, facetValue);
  if (firstIdleIndex > -1) {
    facetRequest.values.pop();
  }
  facetRequest.numberOfValues = facetRequest.values.length;
}
function setAllFacetValuesToIdle(state) {
  Object.values(state).forEach((facet) => handleDeselectAllFacetValues(facet.request));
}
function clearAllFacetValues(state) {
  Object.values(state).forEach((facet) => {
    facet.request.values = [];
  });
}
function handleCategoryFacetUpdateNumberOfValues(facetRequest, numberOfValues2) {
  facetRequest.numberOfValues = numberOfValues2;
  facetRequest.retrieveCount = numberOfValues2;
}
function getFieldSuggestionsOrderInitialState() {
  return [];
}
const fieldSuggestionsOrderReducer = createReducer(getFieldSuggestionsOrderInitialState(), (builder) => {
  builder.addCase(fetchQuerySuggestions$1.fulfilled, (_, action) => {
    return action.payload.fieldSuggestionsFacets ?? [];
  });
});
function getManualNumericFacetInitialState() {
  return {};
}
const manualNumericFacetReducer = createReducer(getManualNumericFacetInitialState(), (builder) => builder.addCase(updateManualNumericFacetRange, (state, action) => {
  const { facetId: facetId2, ...manualRange } = action.payload;
  state[facetId2] = { manualRange };
}).addCase(toggleExcludeNumericFacetValue, (state, action) => {
  clearManualRange(state, action.payload.facetId);
}).addCase(toggleSelectNumericFacetValue, (state, action) => {
  clearManualRange(state, action.payload.facetId);
}).addCase(deselectAllValuesInCoreFacet, (state, action) => {
  clearManualRange(state, action.payload.facetId);
}).addCase(restoreSearchParameters, (state, action) => {
  restoreParameters(state, action.payload.mnf);
}).addCase(restoreProductListingParameters, (state, action) => {
  restoreParameters(state, action.payload.mnf);
}).addCase(clearAllCoreFacets, (state) => {
  for (const facetId2 of Object.keys(state)) {
    clearManualRange(state, facetId2);
  }
}));
const clearManualRange = (state, facetId2) => {
  if (state[facetId2]) {
    state[facetId2] = { manualRange: void 0 };
  }
};
const restoreParameters = (state, payload) => {
  for (const facetId2 of Object.keys(state)) {
    delete state[facetId2];
  }
  if (payload) {
    Object.entries(payload).forEach(([facetId2, manualRange]) => {
      const range = manualRange[0];
      state[facetId2] = { manualRange: range };
    });
  }
};
const recommendationsSlotDefinition = {
  slotId: requiredNonEmptyString,
  productId: new StringValue({ required: false, emptyAllowed: false })
};
const recommendationsOptionsSchema = new Schema(recommendationsSlotDefinition);
const numberOfRecommendationsSelector = createSelector((state, slotId) => state.recommendations ? state.recommendations[slotId]?.products.length || 0 : 0, (len) => len);
const moreRecommendationsAvailableSelector = createSelector((state, slotId) => ({
  total: totalEntriesRecommendationSelector(state, slotId),
  current: numberOfRecommendationsSelector(state, slotId)
}), ({ current: current2, total }) => current2 < total);
const isLoadingSelector = createSelector((state, slotId) => state.recommendations ? state.recommendations[slotId]?.isLoading : false, (isLoading) => isNullOrUndefined(isLoading) ? false : isLoading);
const buildRecommendationCommerceAPIRequest = (slotId, state, navigatorContext, productId) => {
  const commerceAPIRequest = buildPaginatedCommerceAPIRequest(state, navigatorContext, slotId);
  return {
    ...commerceAPIRequest,
    context: {
      ...commerceAPIRequest.context,
      ...productId ? { product: { productId } } : {},
      purchased: getProductsFromCartPurchasedState(state.cart)
    },
    slotId
  };
};
const fetchRecommendations = createAsyncThunk("commerce/recommendations/fetch", async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const { slotId, productId } = payload;
  const request = buildRecommendationCommerceAPIRequest(slotId, getState(), navigatorContext, productId);
  const fetched = await apiClient.getRecommendations(request);
  if (isErrorResponse(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: fetched.success
  };
});
const fetchMoreRecommendations = createAsyncThunk("commerce/recommendations/fetchMore", async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  const slotId = payload.slotId;
  const state = getState();
  const moreRecommendationsAvailable = moreRecommendationsAvailableSelector(state, slotId);
  if (!moreRecommendationsAvailable === false) {
    return null;
  }
  const perPage = perPageRecommendationSelector(state, slotId);
  const numberOfProducts = numberOfRecommendationsSelector(state, slotId);
  const nextPageToRequest = numberOfProducts / perPage;
  const request = {
    ...buildRecommendationCommerceAPIRequest(slotId, state, navigatorContext),
    page: nextPageToRequest
  };
  const fetched = await apiClient.getRecommendations(request);
  if (isErrorResponse(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    response: fetched.success
  };
});
const registerRecommendationsSlot = createAction("commerce/recommendations/registerSlot", (payload) => validatePayload(payload, recommendationsSlotDefinition));
const promoteChildToParentDefinition$1 = {
  child: new RecordValue({
    options: { required: true },
    values: {
      permanentid: new StringValue({ required: true })
    }
  }),
  ...recommendationsSlotDefinition
};
const promoteChildToParent$1 = createAction("commerce/recommendations/promoteChildToParent", (payload) => validatePayload(payload, promoteChildToParentDefinition$1));
const applySort = createAction("commerce/sort/apply", (payload) => validatePayload(payload, {
  by: new EnumValue({
    enum: SortBy,
    required: true
  })
}));
const paginationReducer = createReducer(getCommercePaginationInitialState(), (builder) => {
  builder.addCase(nextPage, (state, action) => {
    const slice = getEffectiveSlice(state, action.payload?.slotId);
    if (!slice) {
      return;
    }
    if (slice.page < slice.totalPages - 1) {
      ++slice.page;
    }
  }).addCase(previousPage, (state, action) => {
    const slice = getEffectiveSlice(state, action.payload?.slotId);
    if (!slice) {
      return;
    }
    if (slice.page > 0) {
      --slice.page;
    }
  }).addCase(selectPage, (state, action) => {
    const slice = getEffectiveSlice(state, action.payload.slotId);
    if (!slice) {
      return;
    }
    if (action.payload.page >= 0 && action.payload.page < slice.totalPages) {
      slice.page = action.payload.page;
    }
  }).addCase(setPageSize, (state, action) => {
    const slice = getEffectiveSlice(state, action.payload.slotId);
    if (!slice) {
      return;
    }
    slice.page = 0;
    slice.perPage = action.payload.pageSize;
  }).addCase(fetchProductListing.fulfilled, (state, action) => {
    state.principal = action.payload.response.pagination;
  }).addCase(executeSearch.fulfilled, (state, action) => {
    state.principal = action.payload.response.pagination;
  }).addCase(fetchRecommendations.fulfilled, (state, action) => {
    state.recommendations[action.meta.arg.slotId] = action.payload.response.pagination;
  }).addCase(registerRecommendationsSlotPagination, (state, action) => {
    const slotId = action.payload.slotId;
    if (slotId in state.recommendations) {
      return;
    }
    state.recommendations[slotId] = getCommercePaginationInitialSlice();
  }).addCase(clearAllCoreFacets, handlePaginationReset).addCase(deselectAllValuesInCoreFacet, handlePaginationReset).addCase(toggleSelectFacetValue, handlePaginationReset).addCase(toggleExcludeFacetValue, handlePaginationReset).addCase(toggleSelectLocationFacetValue, handlePaginationReset).addCase(toggleSelectNumericFacetValue, handlePaginationReset).addCase(toggleExcludeNumericFacetValue, handlePaginationReset).addCase(toggleSelectDateFacetValue, handlePaginationReset).addCase(toggleExcludeDateFacetValue, handlePaginationReset).addCase(toggleSelectCategoryFacetValue, handlePaginationReset).addCase(applySort, handlePaginationReset).addCase(setContext, handlePaginationReset).addCase(setView, handlePaginationReset).addCase(restoreSearchParameters, handleRestoreParameters$1).addCase(restoreProductListingParameters, handleRestoreParameters$1);
});
function getEffectiveSlice(state, solutionTypeId) {
  return solutionTypeId ? state.recommendations[solutionTypeId] : state.principal;
}
function handlePaginationReset(state) {
  state.principal.page = getCommercePaginationInitialSlice().page;
}
function handleRestoreParameters$1(state, action) {
  if (action.payload.page) {
    state.principal.page = action.payload.page;
  } else {
    state.principal.page = getCommercePaginationInitialSlice().page;
  }
  if (action.payload.perPage) {
    state.principal.perPage = action.payload.perPage;
  }
}
const getProductListingInitialState = () => ({
  error: null,
  isLoading: false,
  requestId: "",
  responseId: "",
  facets: [],
  products: []
});
const productListingReducer = createReducer(getProductListingInitialState(), (builder) => {
  builder.addCase(fetchProductListing.rejected, (state, action) => {
    handleError$2(state, action.payload);
  }).addCase(fetchMoreProducts$1.rejected, (state, action) => {
    handleError$2(state, action.payload);
  }).addCase(fetchProductListing.fulfilled, (state, action) => {
    const paginationOffset = getPaginationOffset$2(action.payload);
    handleFullfilled(state, action.payload.response);
    state.products = action.payload.response.products.map((product, index) => preprocessProduct$3(product, paginationOffset + index + 1, action.payload.response.responseId));
  }).addCase(fetchMoreProducts$1.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    const paginationOffset = getPaginationOffset$2(action.payload);
    handleFullfilled(state, action.payload.response);
    state.products = state.products.concat(action.payload.response.products.map((product, index) => preprocessProduct$3(product, paginationOffset + index + 1, action.payload?.response.responseId)));
  }).addCase(fetchProductListing.pending, (state, action) => {
    handlePending$2(state, action.meta.requestId);
  }).addCase(fetchMoreProducts$1.pending, (state, action) => {
    handlePending$2(state, action.meta.requestId);
  }).addCase(promoteChildToParent$3, (state, action) => {
    const { products } = state;
    let childToPromote;
    const currentParentIndex = products.findIndex((product) => {
      childToPromote = product.children.find((child) => child.permanentid === action.payload.child.permanentid);
      return !!childToPromote;
    });
    if (currentParentIndex === -1 || childToPromote === void 0) {
      return;
    }
    const responseId = products[currentParentIndex].responseId;
    const position = products[currentParentIndex].position;
    const { children, totalNumberOfChildren } = products[currentParentIndex];
    const newParent = {
      ...childToPromote,
      children,
      totalNumberOfChildren,
      position,
      responseId
    };
    products.splice(currentParentIndex, 1, newParent);
  }).addCase(setView, () => getProductListingInitialState()).addCase(setContext, () => getProductListingInitialState()).addCase(setError, (state, action) => {
    handleError$2(state, action.payload);
  });
});
function handleError$2(state, error) {
  state.error = error || null;
  state.isLoading = false;
}
function handleFullfilled(state, response) {
  state.error = null;
  state.facets = response.facets;
  state.responseId = response.responseId;
  state.isLoading = false;
}
function handlePending$2(state, requestId) {
  state.isLoading = true;
  state.requestId = requestId;
}
function getPaginationOffset$2(payload) {
  const pagination = payload.response.pagination;
  return pagination.page * pagination.perPage;
}
function preprocessProduct$3(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some((child) => child.permanentid === product.permanentid);
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const { children, totalNumberOfChildren: _totalNumberOfChildren, ...restOfProduct } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}
const queryReducer = createReducer(getCommerceQueryInitialState(), (builder) => {
  builder.addCase(updateQuery$1, (state, action) => ({
    ...state,
    ...action.payload
  })).addCase(restoreSearchParameters, (state, action) => {
    state.query = action.payload.q ?? "";
  }).addCase(selectQuerySuggestion$1, (state, action) => {
    state.query = action.payload.expression;
  });
});
const getRecommendationsInitialState = () => ({});
const getRecommendationsSliceInitialState = () => ({
  headline: "",
  error: null,
  isLoading: false,
  responseId: "",
  products: [],
  productId: void 0
});
const recommendationsReducer = createReducer(getRecommendationsInitialState(), (builder) => {
  builder.addCase(registerRecommendationsSlot, (state, action) => {
    const slotId = action.payload.slotId;
    const productId = action.payload.productId;
    if (slotId in state) {
      return;
    }
    if (!productId) {
      state[slotId] = buildRecommendationsSlice();
      return;
    }
    state[slotId] = buildRecommendationsSlice({ productId });
  }).addCase(fetchRecommendations.rejected, (state, action) => {
    handleError$1(state, action.meta.arg.slotId, action.payload);
  }).addCase(fetchMoreRecommendations.rejected, (state, action) => {
    handleError$1(state, action.meta.arg.slotId, action.payload);
  }).addCase(fetchRecommendations.fulfilled, (state, action) => {
    const slotId = action.meta.arg.slotId;
    const response = action.payload.response;
    handleFulfilled$1(state, slotId, response);
    const recommendations = state[slotId];
    if (!recommendations) {
      return;
    }
    const paginationOffset = getPaginationOffset$1(action.payload);
    recommendations.products = response.products.map((product, index) => preprocessProduct$2(product, paginationOffset + index + 1, response.responseId));
  }).addCase(fetchMoreRecommendations.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    const slotId = action.meta.arg.slotId;
    const response = action.payload.response;
    handleFulfilled$1(state, slotId, response);
    const recommendations = state[slotId];
    if (!recommendations) {
      return;
    }
    const paginationOffset = getPaginationOffset$1(action.payload);
    recommendations.products = recommendations.products.concat(response.products.map((product, index) => preprocessProduct$2(product, paginationOffset + index + 1, response.responseId)));
  }).addCase(fetchRecommendations.pending, (state, action) => {
    handlePending$1(state, action.meta.arg.slotId);
  }).addCase(fetchMoreRecommendations.pending, (state, action) => {
    handlePending$1(state, action.meta.arg.slotId);
  }).addCase(promoteChildToParent$1, (state, action) => {
    const recommendations = state[action.payload.slotId];
    if (!recommendations) {
      return;
    }
    const { products } = recommendations;
    let childToPromote;
    const currentParentIndex = products.findIndex((product) => {
      childToPromote = product.children.find((child) => child.permanentid === action.payload.child.permanentid);
      return !!childToPromote;
    });
    if (currentParentIndex === -1 || childToPromote === void 0) {
      return;
    }
    const responseId = products[currentParentIndex].responseId;
    const position = products[currentParentIndex].position;
    const { children, totalNumberOfChildren } = products[currentParentIndex];
    const newParent = {
      ...childToPromote,
      children,
      totalNumberOfChildren,
      position,
      responseId
    };
    products.splice(currentParentIndex, 1, newParent);
  }).addCase(setError, (state, action) => {
    Object.keys(state).forEach((slotId) => {
      handleError$1(state, slotId, action.payload);
    });
  });
});
function buildRecommendationsSlice(config) {
  return {
    ...getRecommendationsSliceInitialState(),
    ...config
  };
}
function handleError$1(state, slotId, error) {
  const recommendations = state[slotId];
  if (!recommendations) {
    return;
  }
  recommendations.error = error ?? null;
  recommendations.isLoading = false;
}
function handleFulfilled$1(state, slotId, response) {
  const recommendations = state[slotId];
  if (!recommendations) {
    return;
  }
  recommendations.error = null;
  recommendations.headline = response.headline;
  recommendations.responseId = response.responseId;
  recommendations.isLoading = false;
}
function handlePending$1(state, slotId) {
  const recommendations = state[slotId];
  if (!recommendations) {
    return;
  }
  recommendations.isLoading = true;
}
function getPaginationOffset$1(actionPayload) {
  const pagination = actionPayload.response.pagination;
  return pagination.page * pagination.perPage;
}
function preprocessProduct$2(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some((child) => child.permanentid === product.permanentid);
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const { children, totalNumberOfChildren: _totalNumberOfChildren, ...restOfProduct } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}
const getCommerceSearchInitialState = () => ({
  error: null,
  isLoading: false,
  requestId: "",
  responseId: "",
  products: [],
  facets: [],
  queryExecuted: ""
});
const commerceSearchReducer = createReducer(getCommerceSearchInitialState(), (builder) => {
  builder.addCase(executeSearch.rejected, (state, action) => {
    handleError(state, action.payload);
  }).addCase(fetchMoreProducts.rejected, (state, action) => {
    handleError(state, action.payload);
  }).addCase(executeSearch.fulfilled, (state, action) => {
    const paginationOffset = getPaginationOffset(action.payload);
    handleFulfilled(state, action.payload.response, action.payload.queryExecuted);
    state.products = action.payload.response.products.map((product, index) => preprocessProduct$1(product, paginationOffset + index + 1, action.payload.response.responseId));
  }).addCase(fetchMoreProducts.fulfilled, (state, action) => {
    if (!action.payload) {
      return;
    }
    const paginationOffset = getPaginationOffset(action.payload);
    handleFulfilled(state, action.payload.response, action.payload.queryExecuted);
    state.products = state.products.concat(action.payload.response.products.map((product, index) => preprocessProduct$1(product, paginationOffset + index + 1, action.payload?.response.responseId)));
  }).addCase(executeSearch.pending, (state, action) => {
    handlePending(state, action.meta.requestId);
  }).addCase(fetchMoreProducts.pending, (state, action) => {
    handlePending(state, action.meta.requestId);
  }).addCase(promoteChildToParent$2, (state, action) => {
    const { products } = state;
    let childToPromote;
    const currentParentIndex = products.findIndex((product) => {
      childToPromote = product.children.find((child) => child.permanentid === action.payload.child.permanentid);
      return !!childToPromote;
    });
    if (currentParentIndex === -1 || childToPromote === void 0) {
      return;
    }
    const responseId = products[currentParentIndex].responseId;
    const position = products[currentParentIndex].position;
    const { children, totalNumberOfChildren } = products[currentParentIndex];
    const newParent = {
      ...childToPromote,
      children,
      totalNumberOfChildren,
      position,
      responseId
    };
    products.splice(currentParentIndex, 1, newParent);
  }).addCase(setView, () => getCommerceSearchInitialState()).addCase(setContext, () => getCommerceSearchInitialState()).addCase(setError, (state, action) => {
    state.error = action.payload;
    state.isLoading = false;
  });
});
function handleError(state, error) {
  state.error = error || null;
  state.isLoading = false;
}
function handlePending(state, requestId) {
  state.isLoading = true;
  state.requestId = requestId;
}
function handleFulfilled(state, response, query2) {
  state.error = null;
  state.facets = response.facets;
  state.responseId = response.responseId;
  state.isLoading = false;
  state.queryExecuted = query2 ?? "";
}
function getPaginationOffset(payload) {
  const pagination = payload.response.pagination;
  return pagination.page * pagination.perPage;
}
function preprocessProduct$1(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some((child) => child.permanentid === product.permanentid);
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const { children, totalNumberOfChildren: _totalNumberOfChildren, ...restOfProduct } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}
const sortReducer = createReducer(getCommerceSortInitialState(), (builder) => {
  builder.addCase(applySort, (state, action) => {
    state.appliedSort = action.payload;
  }).addCase(fetchProductListing.fulfilled, handleFetchFulfilled).addCase(executeSearch.fulfilled, handleFetchFulfilled).addCase(setContext, getCommerceSortInitialState).addCase(setView, getCommerceSortInitialState).addCase(restoreSearchParameters, handleRestoreParameters).addCase(restoreProductListingParameters, handleRestoreParameters);
});
function handleFetchFulfilled(state, action) {
  const response = action.payload.response;
  state.appliedSort = mapResponseSortToStateSort(response.sort.appliedSort);
  state.availableSorts = response.sort.availableSorts.map(mapResponseSortToStateSort);
}
const mapResponseSortToStateSort = (sort) => {
  if (sort.sortCriteria === SortBy.Relevance) {
    return buildRelevanceSortCriterion();
  }
  return {
    by: SortBy.Fields,
    fields: (sort.fields || []).map(({ field: field2, direction, displayName }) => ({
      name: field2,
      direction,
      displayName
    }))
  };
};
function handleRestoreParameters(state, action) {
  if (action.payload.sortCriteria) {
    state.appliedSort = action.payload.sortCriteria;
    return;
  }
  state.appliedSort = getCommerceSortInitialState().appliedSort;
}
const commerceTriggersReducer = createReducer(getTriggerInitialState(), (builder) => builder.addCase(executeSearch.pending, handleFetchItemsPending).addCase(executeSearch.fulfilled, (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)).addCase(fetchProductListing.pending, handleFetchItemsPending).addCase(fetchProductListing.fulfilled, (state, action) => handleFetchItemsFulfilled(state, action.payload.response.triggers)).addCase(applyQueryTriggerModification, (state, action) => handleApplyQueryTriggerModification(state, action.payload)).addCase(updateIgnoreQueryTrigger, (state, action) => handleUpdateIgnoreQueryTrigger(state, action.payload.q)));
const commerceEngineConfigurationSchema = new Schema({
  ...engineConfigurationDefinitions,
  analytics: new RecordValue({
    options: { required: true },
    values: {
      enabled: new BooleanValue({ required: false, default: true }),
      proxyBaseUrl: new StringValue({ required: false, url: true }),
      source: new RecordValue({
        options: { required: false },
        values: {
          "@coveo/atomic": nonEmptyString,
          "@coveo/quantic": nonEmptyString
        }
      }),
      trackingId: new StringValue({
        required: true,
        emptyAllowed: false,
        regex: /^[a-zA-Z0-9_\-.]{1,100}$/
      })
    }
  }),
  context: new RecordValue({
    options: { required: true },
    values: contextDefinition
  }),
  cart: new RecordValue({
    values: cartDefinition
  }),
  proxyBaseUrl: new StringValue({ required: false, url: true })
});
function getSampleCommerceEngineConfiguration() {
  return {
    accessToken: "xx564559b1-0045-48e1-953c-3addd1ee4457",
    analytics: {
      trackingId: "sports-ui-samples"
    },
    context: {
      language: "en",
      country: "US",
      currency: "USD",
      view: {
        url: "https://sports.barca.group"
      }
    },
    cart: {
      items: [
        {
          productId: "SP01057_00001",
          quantity: 1,
          name: "Kayaker Canoe",
          price: 800
        },
        {
          productId: "SP00081_00001",
          quantity: 1,
          name: "Bamboo Canoe Paddle",
          price: 120
        },
        {
          productId: "SP04236_00005",
          quantity: 1,
          name: "Eco-Brave Rashguard",
          price: 33
        },
        {
          productId: "SP04236_00005",
          quantity: 1,
          name: "Eco-Brave Rashguard",
          price: 33
        }
      ]
    },
    organizationId: "searchuisamples"
  };
}
const commerceEngineReducers = {
  productListing: productListingReducer,
  recommendations: recommendationsReducer,
  commerceSearch: commerceSearchReducer,
  commercePagination: paginationReducer,
  commerceSort: sortReducer,
  facetOrder: facetOrderReducer,
  fieldSuggestionsOrder: fieldSuggestionsOrderReducer,
  facetSearchSet: specificFacetSearchSetReducer,
  categoryFacetSearchSet: categoryFacetSearchSetReducer,
  commerceFacetSet: commerceFacetSetReducer,
  manualNumericFacetSet: manualNumericFacetReducer,
  commerceContext: contextReducer,
  commerceQuery: queryReducer,
  cart: cartReducer,
  didYouMean: didYouMeanReducer,
  triggers: commerceTriggersReducer
};
function buildCommerceEngine(options2) {
  const logger = buildLogger(options2.loggerOptions);
  const { configuration: configuration2 } = options2;
  validateConfiguration$1(configuration2, logger);
  const commerceClient = createCommerceAPIClient(configuration2, logger);
  const thunkArguments = {
    ...buildThunkExtraArguments(configuration2, logger),
    apiClient: commerceClient
  };
  const reducers = {
    ...commerceEngineReducers,
    configuration: configurationReducer,
    version: versionReducer
  };
  const augmentedOptions = {
    ...options2,
    reducers
  };
  const internalEngine = buildCoreEngine(augmentedOptions, thunkArguments, configurationReducer);
  const { state: _, ...engine } = internalEngine;
  const { accessToken, environment, organizationId, analytics, proxyBaseUrl, context, cart } = configuration2;
  engine.dispatch(updateBasicConfiguration({
    accessToken,
    environment,
    organizationId
  }));
  engine.dispatch(updateAnalyticsConfiguration(analytics));
  if (proxyBaseUrl !== void 0) {
    engine.dispatch(updateProxyBaseUrl({
      proxyBaseUrl
    }));
  }
  engine.dispatch(setContext(context));
  if (cart?.items !== void 0) {
    engine.dispatch(setItems(cart.items));
  }
  return redactEngine({
    ...engine,
    get relay() {
      return internalEngine.relay;
    },
    get [stateKey]() {
      return internalEngine.state;
    },
    get configuration() {
      return {
        ...internalEngine.state.configuration
      };
    }
  });
}
function validateConfiguration$1(configuration2, logger) {
  try {
    commerceEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error("Commerce engine configuration error", error);
    throw error;
  }
}
function createCommerceAPIClient(configuration2, logger) {
  return new CommerceAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest
  });
}
const instantProductsIdDefinition = {
  id: requiredNonEmptyString
};
const instantProductsQueryDefinition = {
  ...instantProductsIdDefinition,
  query: requiredEmptyAllowedString
};
const clearExpiredProducts = createAction("commerce/instantProducts/clearExpired", (payload) => validatePayload(payload, instantProductsIdDefinition));
const promoteChildToParentDefinition = {
  child: new RecordValue({
    options: { required: true },
    values: {
      permanentid: new StringValue({ required: true })
    }
  }),
  ...instantProductsQueryDefinition
};
const promoteChildToParent = createAction("commerce/instantProducts/promoteChildToParent", (payload) => validatePayload(payload, promoteChildToParentDefinition));
const registerInstantProducts = createAction("commerce/instantProducts/register", (payload) => validatePayload(payload, instantProductsIdDefinition));
const updateInstantProductsQuery = createAction("commerce/instantProducts/updateQuery", (payload) => validatePayload(payload, instantProductsQueryDefinition));
function getInstantProductsInitialState() {
  return {};
}
createReducer(getInstantProductsInitialState(), (builder) => {
  builder.addCase(registerInstantProducts, (state, action) => {
    registerInstantItem(action.payload, state);
  }).addCase(updateInstantProductsQuery, (state, action) => {
    updateInstantItemQuery({ ...action.payload, q: action.payload.query }, state);
  }).addCase(clearExpiredProducts, (state, action) => {
    clearExpiredItems(action.payload, state);
  }).addCase(fetchInstantProducts.pending, (state, action) => {
    fetchItemsPending(action.meta.arg, state, { products: [] });
  }).addCase(fetchInstantProducts.fulfilled, (state, action) => {
    const { response: { products, responseId, pagination: { totalEntries } } } = action.payload;
    fetchItemsFulfilled({
      duration: 0,
      searchUid: responseId,
      totalCountFiltered: totalEntries,
      ...action.meta.arg
    }, state, {
      products: products.map((product, index) => preprocessProduct(product, index + 1, responseId))
    });
  }).addCase(fetchInstantProducts.rejected, (state, action) => {
    fetchItemsRejected(action.meta.arg, state);
  }).addCase(promoteChildToParent, (state, action) => {
    const cache2 = state[action.payload.id].cache[action.payload.query];
    if (!cache2) {
      return;
    }
    const products = cache2.products;
    let childToPromote;
    const currentParentIndex = products.findIndex((product) => {
      childToPromote = product.children.find((child) => child.permanentid === action.payload.child.permanentid);
      return !!childToPromote;
    });
    if (currentParentIndex === -1 || childToPromote === void 0) {
      return;
    }
    const responseId = products[currentParentIndex].responseId;
    const position = products[currentParentIndex].position;
    const { children, totalNumberOfChildren } = products[currentParentIndex];
    const newParent = {
      ...childToPromote,
      children,
      totalNumberOfChildren,
      position,
      responseId
    };
    const newProducts = [...products];
    newProducts.splice(currentParentIndex, 1, newParent);
    cache2.products = newProducts;
  });
});
function preprocessProduct(product, position, responseId) {
  const isParentAlreadyInChildren = product.children.some((child) => child.permanentid === product.permanentid);
  if (product.children.length === 0 || isParentAlreadyInChildren) {
    return { ...product, position, responseId };
  }
  const { children, totalNumberOfChildren: _totalNumberOfChildren, ...restOfProduct } = product;
  return {
    ...product,
    children: [restOfProduct, ...children],
    position,
    responseId
  };
}
createAsyncThunk("commerce/product/view", async (payload, { extra, getState }) => {
  const { relay } = extra;
  const currency = getCurrency(getState().commerceContext);
  const relayPayload = { currency, product: payload };
  relay.emit("ec.productView", relayPayload);
});
const productClick = createAsyncThunk("commerce/product/click", async (payload, { extra, getState }) => {
  const { relay } = extra;
  const currency = getCurrency(getState().commerceContext);
  const relayPayload = { currency, ...payload };
  relay.emit("ec.productClick", relayPayload);
});
const clearRecentQueries = createAction("commerce/recentQueries/clear");
const registerRecentQueries = createAction("commerce/recentQueries/register", (payload) => validatePayload(payload, registerRecentQueriesPayloadDefinition));
createReducer(getRecentQueriesInitialState(), (builder) => {
  builder.addCase(registerRecentQueries, handleRegisterQueries).addCase(clearRecentQueries, handleClearRecentQueries).addCase(executeSearch.fulfilled, (state, action) => {
    const query2 = action.payload.queryExecuted;
    const products = action.payload.response.products;
    if (!query2.length || !products.length) {
      return;
    }
    handleExecuteSearchFulfilled(query2, state);
  });
});
const buildPlanRequest = (state, navigatorContext) => {
  const baseRequest2 = buildBaseCommerceAPIRequest(state, navigatorContext);
  return {
    ...baseRequest2,
    context: {
      ...baseRequest2.context,
      capture: false
    },
    page: 0,
    perPage: 1,
    query: state.commerceQuery.query
  };
};
const fetchRedirectUrl = createAsyncThunk("commerce/standaloneSearchBox/fetchRedirect", async (payload, { getState, rejectWithValue, extra: { apiClient, navigatorContext } }) => {
  validatePayload(payload, { id: new StringValue({ emptyAllowed: false }) });
  const state = getState();
  const request = buildPlanRequest(state, navigatorContext);
  const response = await apiClient.plan(request);
  if (isErrorResponse(response)) {
    return rejectWithValue(response.error);
  }
  const redirectTriggers = response.success.triggers.filter(isRedirectTrigger);
  return redirectTriggers.length ? redirectTriggers[0].content : "";
});
const registerStandaloneSearchBox = createAction("commerce/standaloneSearchBox/register", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  redirectionUrl: requiredNonEmptyString,
  overwrite: new BooleanValue({ required: false })
}));
const updateStandaloneSearchBoxRedirectionUrl = createAction("commerce/standaloneSearchBox/updateRedirectionUrl", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString,
  redirectionUrl: requiredNonEmptyString
}));
const resetStandaloneSearchBox = createAction("commerce/standaloneSearchBox/reset", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString
}));
const facetRequestSelector = createSelector((state, facetId2) => ({
  facetRequestSelector: state.commerceFacetSet[facetId2]
}), ({ facetRequestSelector: facetRequestSelector2 }) => {
  return facetRequestSelector2?.request;
});
function buildCoreCommerceFacet(engine, props) {
  if (!loadCommerceFacetReducers(engine)) ;
  const { dispatch } = engine;
  const controller = buildController(engine);
  const facetId2 = props.options.facetId;
  const getEngineState = () => engine[stateKey];
  const getRequest = () => facetRequestSelector(getEngineState(), facetId2);
  const getResponse = () => props.options.facetResponseSelector(getEngineState(), facetId2);
  const getIsLoading = () => props.options.isFacetLoadingResponseSelector(getEngineState());
  const getNumberOfActiveValues = () => {
    return getRequest()?.values?.filter((v) => v.state !== "idle").length ?? 0;
  };
  return {
    ...controller,
    toggleSelect: (selection) => {
      dispatch(props.options.toggleSelectActionCreator({
        selection,
        facetId: facetId2
      }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    toggleExclude: (selection) => {
      if (!props.options.toggleExcludeActionCreator) {
        engine.logger.warn("No toggle exclude action creator provided; calling #toggleExclude had no effect.");
        return;
      }
      dispatch(props.options.toggleExcludeActionCreator({ selection, facetId: facetId2 }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleSelect: function(selection) {
      if (selection.state === "idle") {
        dispatch(deselectAllValuesInCoreFacet({ facetId: facetId2 }));
      }
      this.toggleSelect(selection);
    },
    // Must use a function here to properly support inheritance with `this`.
    toggleSingleExclude: function(selection) {
      if (!props.options.toggleExcludeActionCreator) {
        engine.logger.warn("No toggle exclude action creator provided; calling #toggleSingleExclude had no effect.");
        return;
      }
      if (selection.state === "idle") {
        dispatch(deselectAllValuesInCoreFacet({ facetId: facetId2 }));
      }
      this.toggleExclude(selection);
    },
    isValueSelected: (value) => {
      return value.state === "selected";
    },
    isValueExcluded: (value) => {
      return value.state === "excluded";
    },
    deselectAll() {
      dispatch(deselectAllValuesInCoreFacet({ facetId: facetId2 }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    showMoreValues() {
      const numberInState = getRequest()?.numberOfValues ?? 0;
      const initialNumberOfValues = getRequest()?.initialNumberOfValues ?? 1;
      const numberToNextMultipleOfConfigured = initialNumberOfValues - numberInState % initialNumberOfValues;
      const numberOfValues2 = numberInState + numberToNextMultipleOfConfigured;
      dispatch(updateCoreFacetNumberOfValues({ facetId: facetId2, numberOfValues: numberOfValues2 }));
      dispatch(updateCoreFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: true }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    showLessValues() {
      const initialNumberOfValues = getRequest()?.initialNumberOfValues ?? 1;
      const newNumberOfValues = Math.max(initialNumberOfValues, getNumberOfActiveValues());
      dispatch(updateCoreFacetNumberOfValues({
        facetId: facetId2,
        numberOfValues: newNumberOfValues
      }));
      dispatch(updateCoreFacetIsFieldExpanded({ facetId: facetId2, isFieldExpanded: false }));
      dispatch(props.options.fetchProductsActionCreator());
    },
    get state() {
      return getCoreFacetState(facetId2, getRequest(), getResponse(), getIsLoading());
    }
  };
}
function loadCommerceFacetReducers(engine) {
  engine.addReducers({ commerceFacetSet: commerceFacetSetReducer });
  return true;
}
const canShowLessValues = (request) => {
  return !!request && request.values.length > (request.initialNumberOfValues ?? 1) && request.values.some((v) => v.state === "idle");
};
const getCoreFacetState = (facetId2, request, response, isLoading) => {
  return {
    canShowLessValues: canShowLessValues(request),
    canShowMoreValues: response?.moreValuesAvailable ?? false,
    displayName: response?.displayName ?? "",
    facetId: facetId2,
    field: response?.field ?? "",
    hasActiveValues: !response || response.type === "hierarchical" ? false : response.values.some((v) => v.state !== "idle"),
    isLoading,
    type: response?.type ?? "regular",
    values: response?.values ? response.values : []
  };
};
function buildCommerceDateFacet(engine, options2) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options2,
      toggleSelectActionCreator: toggleSelectDateFacetValue,
      toggleExcludeActionCreator: toggleExcludeDateFacetValue
    }
  });
  const { dispatch } = engine;
  const { facetId: facetId2, fetchProductsActionCreator } = options2;
  return {
    ...coreController,
    setRanges(ranges) {
      dispatch(updateDateFacetValues({
        facetId: facetId2,
        values: ranges.map((range) => ({ ...range, numberOfResults: 0 }))
      }));
      dispatch(fetchProductsActionCreator());
    },
    get state() {
      return getDateFacetState(coreController.state);
    },
    type: "dateRange"
  };
}
const getDateFacetState = (coreState) => {
  return {
    ...coreState,
    type: "dateRange"
  };
};
function validateSortInitialState(engine, state) {
  if (!state) {
    return;
  }
  const schema = new Schema({
    criterion: sortCriterionDefinition
  });
  validateInitialState(engine, schema, state, "buildSort");
}
function buildCoreSort(engine, props) {
  if (!loadSortReducers(engine)) ;
  const { dispatch } = engine;
  const controller = buildController(engine);
  validateSortInitialState(engine, props.initialState);
  const criterion = props.initialState?.criterion;
  if (criterion) {
    dispatch(applySort(criterion));
  }
  return {
    ...controller,
    get state() {
      return engine[stateKey].commerceSort;
    },
    sortBy(criterion2) {
      dispatch(applySort(criterion2));
      dispatch(props.fetchProductsActionCreator());
    },
    isSortedBy(criterion2) {
      return JSON.stringify(this.state.appliedSort) === JSON.stringify(criterion2);
    },
    isAvailable(criterion2) {
      return this.state.availableSorts.some((availableCriterion) => JSON.stringify(availableCriterion) === JSON.stringify(criterion2));
    }
  };
}
function loadSortReducers(engine) {
  engine.addReducers({ commerceSort: sortReducer });
  return true;
}
const facetResponseSelector$1 = createSelector((state, facetId2) => ({ state, facetId: facetId2 }), ({ state, facetId: facetId2 }) => {
  const facetResponse = state.commerceSearch.facets.find((facetResponse2) => facetResponse2.facetId === facetId2);
  if (facetResponse && facetResponse.facetId in state.commerceFacetSet) {
    return facetResponse;
  }
  return void 0;
});
const isFacetLoadingResponseSelector$1 = createSelector((state) => ({ state }), ({ state }) => state.commerceSearch.isLoading);
function buildCategoryFacetSearch(engine, props) {
  if (!loadCategoryFacetSearchReducers(engine)) ;
  const { state: _state, updateCaptions: _updateCaptions, ...restOfFacetSearch } = buildCoreCategoryFacetSearch(engine, {
    ...props,
    executeFacetSearchActionCreator: (facetId2) => executeCommerceFacetSearch({
      facetId: facetId2,
      facetSearchType: props.options.type
    }),
    executeFieldSuggestActionCreator: (facetId2) => executeCommerceFieldSuggest({
      facetId: facetId2,
      facetSearchType: props.options.type
    })
  });
  return restOfFacetSearch;
}
function loadCategoryFacetSearchReducers(engine) {
  engine.addReducers({ categoryFacetSearchSet: categoryFacetSearchSetReducer });
  return true;
}
const sortFieldAndDirectionSeparator = " ";
const sortFieldsJoiner = ",";
const commerceFacetsRegex = /^(f|fExcluded|cf|nf|nfExcluded|df|dfExcluded|mnf|mnfExcluded|lf)-(.+)$/;
const searchSerializer = {
  serialize,
  deserialize
};
const productListingSerializer = {
  serialize,
  deserialize
};
const supportedFacetParameters = {
  f: true,
  fExcluded: true,
  lf: true,
  cf: true,
  nf: true,
  nfExcluded: true,
  df: true,
  dfExcluded: true,
  mnf: true,
  mnfExcluded: true
};
function serialize(parameters) {
  return sanitizeNumericFacetParams(serialize$1(serializePair)(parameters));
}
function serializePair(pair) {
  const [key, val] = pair;
  if (!isValidKey(key)) {
    return "";
  }
  if (key === "sortCriteria") {
    return isSortCriteriaObject(val) ? serializeSortCriteria(key, val) : "";
  }
  if (keyHasObjectValue(key) && !isRangeFacetKey(key)) {
    return isFacetObject(val) ? serializeFacets(key, val) : "";
  }
  if (key === "nf" || key === "df" || key === "mnf") {
    return isRangeFacetObject(val) ? serializeRangeFacets(key, val) : "";
  }
  if (val !== void 0) {
    return serializeSpecialCharacters(key, val);
  }
  return "";
}
function serializeSortCriteria(key, val) {
  return serializeSpecialCharacters(key, buildCriterionExpression(val));
}
function buildCriterionExpression(criterion) {
  if (!criterion) {
    return "";
  }
  if (criterion.by === SortBy.Relevance) {
    return "relevance";
  }
  return criterion.fields.map((field2) => `${field2.name}${sortFieldAndDirectionSeparator}${field2.direction}`).join(sortFieldsJoiner);
}
function isValidKey(key) {
  return isValidBasicKey(key) || keyHasObjectValue(key);
}
function isSortCriteriaObject(obj) {
  if (!isObject(obj) || !("by" in obj)) {
    return false;
  }
  if (obj.by === "relevance") {
    return true;
  }
  if (obj.by === "fields" && "fields" in obj && isArray$1(obj.fields)) {
    return obj.fields.every((field2) => {
      return isObject(field2) && "name" in field2 && typeof field2.name === "string" && ("direction" in field2 && (field2.direction === SortDirection.Ascending || field2.direction === SortDirection.Descending) || !("direction" in field2));
    });
  }
  return false;
}
function isValidBasicKey(key) {
  const supportedBasicParameters = {
    q: true,
    sortCriteria: true,
    page: true,
    perPage: true
  };
  return key in supportedBasicParameters;
}
function deserialize(fragment) {
  const parts = fragment.split(delimiter);
  const keyValuePairs = parts.map(splitOnFirstEqual).map((parts2) => preprocessObjectPairs(parts2, commerceFacetsRegex)).filter(isValidPair).map(cast);
  return keyValuePairs.reduce((acc, pair) => {
    const [key, val] = pair;
    if (keyHasObjectValue(key)) {
      const mergedValues = { ...acc[key], ...val };
      return { ...acc, [key]: mergedValues };
    }
    if (key === "sortCriteria") {
      const sortCriteria = deserializeSortCriteria(val);
      return { ...acc, [key]: sortCriteria };
    }
    return { ...acc, [key]: val };
  }, {});
}
function keyHasObjectValue(key) {
  return key in supportedFacetParameters;
}
function isValidPair(pair) {
  const validKey = isValidKey(pair[0]);
  const lengthOfTwo = pair.length === 2;
  return validKey && lengthOfTwo;
}
function cast(pair) {
  const [key, value] = pair;
  if (key === "page" || key === "perPage") {
    return [key, parseInt(value)];
  }
  if (keyHasObjectValue(key)) {
    return [key, castUnknownObject(value)];
  }
  return [key, decodeURIComponent(value)];
}
function deserializeSortCriteria(value) {
  if (value === "relevance") {
    return buildRelevanceSortCriterion();
  }
  const criteria2 = value.split(sortFieldsJoiner);
  if (!criteria2.length) {
    return void 0;
  }
  return criteria2.reduce((acc, joinedFieldAndDirection) => {
    const fieldAndDirection = joinedFieldAndDirection.trim().split(sortFieldAndDirectionSeparator);
    if (fieldAndDirection.length !== 2) {
      return acc;
    }
    const field2 = fieldAndDirection[0].toLowerCase();
    const direction = fieldAndDirection[1].toLowerCase();
    acc.fields.push({ name: field2, direction });
    return acc;
  }, buildFieldsSortCriterion([]));
}
const isManualNumericFacet = (param) => param.startsWith("mnf-");
const isNumericFacet = (param) => param.startsWith("nf-") || isManualNumericFacet(param);
function sanitizeNumericFacetParams(params) {
  const seenNumericFacets = /* @__PURE__ */ new Set();
  const dedupedNumericFacets = /* @__PURE__ */ new Set();
  const sanitized = [];
  for (const param of params.split(delimiter)) {
    if (!isNumericFacet(param)) {
      sanitized.push(param);
      continue;
    }
    const normalizedParam = param.replace(/^mnf-/, "nf-");
    if (!seenNumericFacets.has(normalizedParam)) {
      seenNumericFacets.add(normalizedParam);
      dedupedNumericFacets.add(param);
      continue;
    }
    if (isManualNumericFacet(param)) {
      dedupedNumericFacets.delete(normalizedParam);
      dedupedNumericFacets.add(param);
    }
  }
  sanitized.push(...dedupedNumericFacets);
  return sanitized.join(delimiter);
}
function buildRegularFacetSearch(engine, props) {
  if (!loadRegularFacetSearchReducers(engine)) ;
  const { state: _state, updateCaptions: _updateCaptions, ...restOfFacetSearch } = buildFacetSearch(engine, {
    ...props,
    executeFacetSearchActionCreator: (facetId2) => executeCommerceFacetSearch({
      facetId: facetId2,
      facetSearchType: props.options.type
    }),
    executeFieldSuggestActionCreator: (facetId2) => executeCommerceFieldSuggest({
      facetId: facetId2,
      facetSearchType: props.options.type
    })
  });
  return {
    ...restOfFacetSearch
  };
}
function loadRegularFacetSearchReducers(engine) {
  engine.addReducers({ facetSearchSet: specificFacetSearchSetReducer });
  return true;
}
function buildCoreInteractiveProduct(engine, props) {
  let wasOpened = false;
  const getWarningMessage = () => {
    const messageSegment = (property, lookupFields, fallback) => `- Could not retrieve '${property}' analytics property from field${lookupFields.length > 1 ? "s" : ""} '${lookupFields.join("', '")}'; fell back to ${fallback}.`;
    const warnings = [];
    const { ec_name, ec_promo_price, ec_price, ec_product_id } = props.options.product;
    if (!ec_name) {
      warnings.push(messageSegment("name", ["ec_gender"], "permanentid"));
    }
    if (!ec_promo_price && !ec_price) {
      warnings.push(messageSegment("price", ["ec_promo_price", "ec_price"], "NaN"));
    }
    if (!ec_product_id) {
      warnings.push(messageSegment("productId", ["ec_product_id"], "permanentid"));
    }
    if (warnings.length === 0) {
      return;
    }
    return `Some required analytics properties could not be retrieved from the expected fields for product with permanentid '${props.options.product.permanentid}':

${warnings.join("\n")}

Review the configuration of the above 'ec_'-prefixed fields in your index, and make sure they contain the correct metadata.`;
  };
  const logAnalyticsIfNeverOpened = () => {
    if (wasOpened) {
      return;
    }
    wasOpened = true;
    engine.dispatch(productClick({
      product: {
        name: props.options.product.ec_name ?? props.options.product.permanentid,
        price: props.options.product.ec_promo_price ?? props.options.product.ec_price ?? NaN,
        productId: props.options.product.ec_product_id ?? props.options.product.permanentid
      },
      position: props.options.product.position,
      responseId: props.options.product.responseId ?? props.responseIdSelector(engine[stateKey])
    }));
  };
  return {
    ...buildInteractiveResultCore(engine, props, logAnalyticsIfNeverOpened),
    warningMessage: getWarningMessage()
  };
}
function buildDidYouMean(engine) {
  if (!loadDidYouMeanReducers(engine)) ;
  const controller = buildController(engine);
  const getState = () => engine[stateKey].didYouMean;
  return {
    ...controller,
    applyCorrection() {
      engine.dispatch(updateQuery$1({ query: this.state.queryCorrection.correctedQuery }));
      engine.dispatch(executeSearch());
    },
    get state() {
      const state = getState();
      return {
        originalQuery: state.originalQuery,
        wasCorrectedTo: state.wasCorrectedTo,
        queryCorrection: state.queryCorrection,
        hasQueryCorrection: state.queryCorrection.correctedQuery !== "",
        wasAutomaticallyCorrected: state.wasCorrectedTo !== ""
      };
    }
  };
}
function loadDidYouMeanReducers(engine) {
  engine.addReducers({
    didYouMean: didYouMeanReducer
  });
  return true;
}
const actions = {
  regular: {
    toggleSelectActionCreator: toggleSelectFacetValue,
    toggleExcludeActionCreator: toggleExcludeFacetValue
  },
  numericalRange: {
    toggleSelectActionCreator: toggleSelectNumericFacetValue,
    toggleExcludeActionCreator: toggleExcludeNumericFacetValue
  },
  dateRange: {
    toggleSelectActionCreator: toggleSelectDateFacetValue,
    toggleExcludeActionCreator: toggleExcludeDateFacetValue
  },
  location: {
    toggleSelectActionCreator: toggleSelectLocationFacetValue
  },
  hierarchical: {
    toggleSelectActionCreator: deselectAllValuesInCoreFacet
  }
};
function buildCoreBreadcrumbManager(engine, options2) {
  if (!loadCommerceBreadcrumbManagerReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const createBreadcrumb = (facet) => ({
    facetId: facet.facetId,
    facetDisplayName: facet.displayName,
    field: facet.field,
    type: facet.type,
    values: facet.type === "hierarchical" ? getValuesForCategoryFacet(facet) : getValuesForNonCategoryFacet(facet)
  });
  const getValuesForNonCategoryFacet = (facet) => {
    return facet.values.filter((value) => value.state !== "idle").map((selection) => ({
      value: selection,
      deselect: () => {
        if (selection.state === "selected") {
          dispatch(actions[facet.type].toggleSelectActionCreator({
            facetId: facet.facetId,
            selection
          }));
          if (facet.type !== "location") {
            dispatch(updateCoreFacetFreezeCurrentValues({
              facetId: facet.facetId,
              freezeCurrentValues: false
            }));
          }
          dispatch(options2.fetchProductsActionCreator());
        } else if (selection.state === "excluded" && facet.type !== "location") {
          dispatch(actions[facet.type].toggleExcludeActionCreator({
            facetId: facet.facetId,
            selection
          }));
          dispatch(updateCoreFacetFreezeCurrentValues({
            facetId: facet.facetId,
            freezeCurrentValues: false
          }));
          dispatch(options2.fetchProductsActionCreator());
        }
      }
    }));
  };
  const getValuesForCategoryFacet = (facet) => {
    const ancestry = findActiveValueAncestry(facet.values);
    const activeValue = ancestry.length > 0 ? ancestry[ancestry.length - 1] : void 0;
    if (activeValue === void 0) {
      return [];
    }
    return [
      {
        value: activeValue,
        deselect: () => {
          dispatch(actions.hierarchical.toggleSelectActionCreator({
            facetId: facet.facetId
          }));
          dispatch(options2.fetchProductsActionCreator());
        }
      }
    ];
  };
  const hasActiveValue = (facet) => {
    if (!facet) {
      return false;
    }
    if (facet.values.length === 0) {
      return false;
    }
    if (facet.type === "hierarchical") {
      return findActiveValueAncestry(facet.values).length > 0;
    }
    return facet.values.some((value) => value.state !== "idle");
  };
  const commerceFacetSelector = createSelector((state) => state.facetOrder, (facetOrder) => {
    const breadcrumbs = facetOrder.flatMap((facetId2) => {
      const facet = options2.facetResponseSelector(engine[stateKey], facetId2);
      if (hasActiveValue(facet)) {
        return [createBreadcrumb(facet)];
      }
      return [];
    });
    return {
      facetBreadcrumbs: breadcrumbs,
      hasBreadcrumbs: breadcrumbs.length > 0
    };
  });
  return {
    ...controller,
    deselectAll: () => {
      dispatch(clearAllCoreFacets());
      dispatch(options2.fetchProductsActionCreator());
    },
    get state() {
      return commerceFacetSelector(engine[stateKey]);
    }
  };
}
function loadCommerceBreadcrumbManagerReducers(engine) {
  engine.addReducers({ facetOrder: facetOrderReducer, commerceFacetSet: commerceFacetSetReducer });
  return true;
}
const categoryFacetSearchStateSelector = createSelector((state, facetId2) => ({
  facetSearchSelector: state.categoryFacetSearchSet[facetId2]
}), ({ facetSearchSelector }) => {
  return facetSearchSelector;
});
function buildCategoryFacet(engine, options2) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options2,
      toggleSelectActionCreator: toggleSelectCategoryFacetValue
    }
  });
  const { deselectAll, isValueSelected, subscribe, toggleSelect } = coreController;
  const { dispatch } = engine;
  const { facetId: facetId2 } = options2;
  const facetSearch2 = buildCategoryFacetSearch(engine, {
    options: { facetId: facetId2, ...options2.facetSearch },
    select: () => {
      dispatch(options2.fetchProductsActionCreator());
    },
    isForFieldSuggestions: false
  });
  const getRequest = () => facetRequestSelector(engine[stateKey], facetId2);
  const findSelectedValueChildren = (values) => {
    const selectedValue = values.find((value) => value.state === "selected");
    if (selectedValue) {
      return selectedValue.children;
    }
    for (const value of values) {
      if (value.children.length > 0) {
        const result = findSelectedValueChildren(value.children);
        if (result !== value.children) {
          return result;
        }
      }
    }
    return values;
  };
  return {
    deselectAll,
    isValueSelected,
    subscribe,
    toggleSelect,
    showMoreValues() {
      const { initialNumberOfValues, values, numberOfValues: numberOfValues2 } = getRequest();
      const currentLevelValues = findSelectedValueChildren(values);
      if (!initialNumberOfValues && !numberOfValues2) {
        return;
      }
      const newNumberOfValues = currentLevelValues.length + (initialNumberOfValues ?? numberOfValues2);
      dispatch(updateCategoryFacetNumberOfValues({
        facetId: facetId2,
        numberOfValues: newNumberOfValues
      }));
      dispatch(options2.fetchProductsActionCreator());
    },
    showLessValues() {
      const request = getRequest();
      const numberOfValues2 = request.initialNumberOfValues ?? 1;
      dispatch(updateCategoryFacetNumberOfValues({
        facetId: facetId2,
        numberOfValues: numberOfValues2
      }));
      dispatch(options2.fetchProductsActionCreator());
    },
    facetSearch: facetSearch2,
    get state() {
      return getCategoryFacetState(coreController.state, categoryFacetSearchStateSelector(engine[stateKey], facetId2), getRequest());
    },
    type: "hierarchical"
  };
}
const getCategoryFacetState = (coreState, facetSearchSelector, request) => {
  const { values } = coreState;
  const selectedValueAncestry = findActiveValueAncestry(values);
  const activeValue = selectedValueAncestry.length ? selectedValueAncestry[selectedValueAncestry.length - 1] : void 0;
  const initialNumberOfValues = request?.initialNumberOfValues;
  const canShowLessValues2 = !!initialNumberOfValues && (activeValue ? initialNumberOfValues < activeValue.children.length : initialNumberOfValues < (request.numberOfValues ?? coreState.values.length));
  const canShowMoreValues = activeValue ? activeValue.moreValuesAvailable : coreState.canShowMoreValues;
  return {
    ...coreState,
    activeValue,
    canShowLessValues: canShowLessValues2,
    canShowMoreValues,
    facetSearch: {
      isLoading: facetSearchSelector?.isLoading ?? false,
      moreValuesAvailable: facetSearchSelector?.response.moreValuesAvailable ?? false,
      query: facetSearchSelector?.options.query ?? "",
      values: facetSearchSelector?.response.values ?? []
    },
    hasActiveValues: !!activeValue,
    selectedValueAncestry,
    type: "hierarchical",
    values
  };
};
function buildFacetGenerator(engine, options2) {
  if (!loadCommerceFacetGeneratorReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const createFacetControllers = createSelector([
    (state) => state.facetOrder,
    (state) => state.commerceFacetSet
  ], (facetOrder, commerceFacetSet) => facetOrder.map((facetId2) => createFacetController(commerceFacetSet, facetId2)));
  const createFacetController = createSelector((commerceFacetSet, facetId2) => ({
    facetId: facetId2,
    type: commerceFacetSet[facetId2].request.type
  }), ({ type, facetId: facetId2 }) => {
    switch (type) {
      case "dateRange":
        return options2.buildDateFacet(engine, { facetId: facetId2 });
      case "hierarchical":
        return options2.buildCategoryFacet(engine, { facetId: facetId2 });
      case "numericalRange":
        return options2.buildNumericFacet(engine, { facetId: facetId2 });
      case "regular":
        return options2.buildRegularFacet(engine, { facetId: facetId2 });
      case "location":
        return options2.buildLocationFacet(engine, { facetId: facetId2 });
    }
  });
  return {
    ...controller,
    deselectAll: () => {
      dispatch(clearAllCoreFacets());
      dispatch(options2.fetchProductsActionCreator());
    },
    get facets() {
      return createFacetControllers(engine[stateKey]);
    },
    get state() {
      return engine[stateKey].facetOrder;
    }
  };
}
function loadCommerceFacetGeneratorReducers(engine) {
  engine.addReducers({ facetOrder: facetOrderReducer, commerceFacetSet: commerceFacetSetReducer });
  return true;
}
function buildCommerceLocationFacet(engine, options2) {
  const { toggleSingleExclude: _toggleSingleExclude, toggleExclude: _toggleExclude, isValueExcluded: _isValueExcluded, ...coreController } = buildCoreCommerceFacet(engine, {
    options: {
      ...options2,
      toggleSelectActionCreator: toggleSelectLocationFacetValue
    }
  });
  return {
    ...coreController,
    get state() {
      return getLocationFacetState(coreController.state);
    },
    type: "location"
  };
}
const getLocationFacetState = (coreState) => {
  return {
    ...coreState,
    type: "location"
  };
};
const manualNumericFacetSelector = createSelector((state, facetId2) => state.manualNumericFacetSet[facetId2]?.manualRange, (manualRange) => manualRange);
function buildCommerceNumericFacet(engine, options2) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options2,
      toggleSelectActionCreator: toggleSelectNumericFacetValue,
      toggleExcludeActionCreator: toggleExcludeNumericFacetValue
    }
  });
  if (!loadCommerceNumericFacetReducers(engine)) ;
  const { dispatch } = engine;
  const { facetId: facetId2, fetchProductsActionCreator } = options2;
  return {
    ...coreController,
    // Only one range stored, so last will override the previous ones
    setRanges(ranges) {
      ranges.forEach((range) => {
        dispatch(updateManualNumericFacetRange({ facetId: facetId2, ...range }));
      });
      dispatch(fetchProductsActionCreator());
    },
    get state() {
      const response = options2.facetResponseSelector(engine[stateKey], facetId2);
      return getNumericFacetState(coreController.state, response?.type === "numericalRange" ? response : void 0, manualNumericFacetSelector(engine[stateKey], facetId2));
    },
    type: "numericalRange"
  };
}
function loadCommerceNumericFacetReducers(engine) {
  engine.addReducers({ manualNumericFacetSet: manualNumericFacetReducer });
  return true;
}
const getNumericFacetState = (coreState, facetResponseSelector2, manualFacetRangeSelector) => {
  const response = facetResponseSelector2?.type === "numericalRange" ? facetResponseSelector2 : void 0;
  return {
    ...coreState,
    ...response?.domain && {
      domain: {
        min: response.domain.min,
        max: response.domain.max
      }
    },
    ...manualFacetRangeSelector && { manualRange: manualFacetRangeSelector },
    type: "numericalRange"
  };
};
const specificFacetSearchStateSelector = createSelector((state, facetId2) => ({
  facetSearchSelector: state.facetSearchSet[facetId2]
}), ({ facetSearchSelector }) => {
  return facetSearchSelector;
});
function buildCommerceRegularFacet(engine, options2) {
  const coreController = buildCoreCommerceFacet(engine, {
    options: {
      ...options2,
      toggleSelectActionCreator: toggleSelectFacetValue,
      toggleExcludeActionCreator: toggleExcludeFacetValue
    }
  });
  const getFacetId = () => coreController.state.facetId;
  const { dispatch } = engine;
  const facetSearch2 = buildRegularFacetSearch(engine, {
    options: { facetId: getFacetId(), ...options2.facetSearch },
    select: () => {
      dispatch(options2.fetchProductsActionCreator());
    },
    exclude: () => {
      dispatch(options2.fetchProductsActionCreator());
    },
    isForFieldSuggestions: false
  });
  return {
    ...coreController,
    facetSearch: facetSearch2,
    get state() {
      return getRegularFacetState(coreController.state, specificFacetSearchStateSelector(engine[stateKey], getFacetId()));
    },
    type: "regular"
  };
}
const getRegularFacetState = (coreState, facetSearchSelector) => {
  return {
    ...coreState,
    facetSearch: {
      isLoading: facetSearchSelector?.isLoading ?? false,
      moreValuesAvailable: facetSearchSelector?.response.moreValuesAvailable ?? false,
      query: facetSearchSelector?.options.query ?? "",
      values: facetSearchSelector?.response.values ?? []
    },
    type: "regular"
  };
};
const optionsSchema$1 = new Schema({
  pageSize: new NumberValue({ min: 1, max: 1e3, required: false })
});
function buildCorePagination(engine, props) {
  if (!loadPaginationReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  validateOptions(engine, optionsSchema$1, props.options, "buildCorePagination");
  const slotId = props.options?.slotId;
  if (props.options?.pageSize) {
    dispatch(setPageSize({
      slotId,
      pageSize: props.options.pageSize
    }));
  }
  if (slotId) {
    dispatch(registerRecommendationsSlotPagination({ slotId }));
  }
  const paginationSelector = createSelector((state) => slotId ? state.commercePagination.recommendations[slotId] : state.commercePagination.principal, ({ perPage, ...rest }) => ({
    pageSize: perPage ?? 0,
    ...rest
  }));
  return {
    ...controller,
    get state() {
      return paginationSelector(engine[stateKey]);
    },
    selectPage(page) {
      dispatch(selectPage({
        slotId,
        page
      }));
      dispatch(props.fetchProductsActionCreator());
    },
    nextPage() {
      dispatch(nextPage({ slotId }));
      dispatch(props.fetchProductsActionCreator());
    },
    previousPage() {
      dispatch(previousPage({ slotId }));
      dispatch(props.fetchProductsActionCreator());
    },
    setPageSize(pageSize) {
      dispatch(setPageSize({ slotId, pageSize }));
      dispatch(props.fetchProductsActionCreator());
    },
    fetchMoreProducts() {
      dispatch(props.fetchMoreProductsActionCreator());
    }
  };
}
function loadPaginationReducers(engine) {
  engine.addReducers({
    commercePagination: paginationReducer
  });
  return true;
}
function getCommerceParametersInitialState() {
  return {};
}
const parametersReducer = createReducer(getCommerceParametersInitialState(), (builder) => {
  builder.addCase(nextPage, (state, action) => handleNextPage(state, action.payload)).addCase(previousPage, (state, action) => handlePreviousPage(state, action.payload)).addCase(selectPage, (state, action) => handleSelectPage(state, action.payload)).addCase(setPageSize, (state, action) => handleSetPageSize(state, action.payload)).addCase(applySort, (state, action) => handleApplySort(state, action.payload)).addCase(updateQuery$1, (state, action) => handleUpdateQuery(state, action.payload)).addCase(clearAllCoreFacets, (state) => handleClearAllCoreFacets(state)).addCase(deleteAllCoreFacets, (state) => handleClearAllCoreFacets(state)).addCase(deselectAllValuesInCoreFacet, (state, action) => handleDeselectAllValuesInCoreFacet(state, action.payload)).addCase(toggleSelectCategoryFacetValue, (state, action) => handleToggleCategoryFacetValue(state, action.payload)).addCase(selectCategoryFacetSearchResult, (state, action) => handleSelectCategoryFacetSearchResult(state, action)).addCase(toggleSelectFacetValue, (state, action) => handleToggleSelectFacetValue(state, action.payload)).addCase(toggleExcludeFacetValue, (state, action) => handleToggleExcludeFacetValue(state, action.payload)).addCase(selectFacetSearchResult, (state, action) => handleSelectFacetSearchResult(state, action)).addCase(excludeFacetSearchResult, (state, action) => handleExcludeFacetSearchResult(state, action)).addCase(toggleSelectNumericFacetValue, (state, action) => handleToggleSelectNumericFacetValue(state, action.payload)).addCase(toggleExcludeNumericFacetValue, (state, action) => handleToggleExcludeNumericFacetValue(state, action.payload)).addCase(updateManualNumericFacetRange, (state, action) => handleUpdateManualNumericFacetRange(state, action.payload)).addCase(toggleSelectDateFacetValue, (state, action) => handleToggleSelectDateFacetValue(state, action.payload)).addCase(toggleExcludeDateFacetValue, (state, action) => handleToggleExcludeDateFacetValue(state, action.payload)).addCase(toggleSelectLocationFacetValue, (state, action) => handleToggleSelectLocationFacetValue(state, action.payload)).addCase(setView, getCommerceParametersInitialState).addCase(restoreProductListingParameters, (state, action) => {
    state = action.payload;
    return state;
  }).addCase(restoreSearchParameters, (state, action) => {
    state = action.payload;
    return state;
  });
});
const handleNextPage = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  if (state.page !== void 0) {
    state.page++;
    return;
  }
  state.page = 1;
};
const handlePreviousPage = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  if (state.page !== void 0 && state.page > 1) {
    state.page--;
    return;
  }
  state.page = void 0;
};
const handleSelectPage = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  state.page = payload.page > 0 ? payload.page : void 0;
};
const handleSetPageSize = (state, payload) => {
  if (payload?.slotId !== void 0) {
    return;
  }
  state.page = void 0;
  if (payload.pageSize === 0) {
    state.perPage = void 0;
    return;
  }
  state.perPage = payload.pageSize;
};
const handleApplySort = (state, payload) => {
  state.page = void 0;
  state.sortCriteria = payload;
};
const handleUpdateQuery = (state, payload) => {
  state.page = void 0;
  const { query: query2 } = payload;
  if (query2 === void 0 || query2.trim() === "") {
    state.q = void 0;
    return;
  }
  state.q = query2;
};
const handleClearAllCoreFacets = (state) => {
  state.page = void 0;
  state.cf = void 0;
  state.df = void 0;
  state.dfExcluded = void 0;
  state.lf = void 0;
  state.mnf = void 0;
  state.mnfExcluded = void 0;
  state.nf = void 0;
  state.nfExcluded = void 0;
  state.f = void 0;
  state.fExcluded = void 0;
};
const handleDeselectAllValuesInCoreFacet = (state, payload) => {
  const { facetId: facetId2 } = payload;
  state.page = void 0;
  if (state.cf) {
    delete state.cf[facetId2];
    Object.keys(state.cf).length === 0 && delete state.cf;
  }
  if (state.df) {
    delete state.df[facetId2];
    Object.keys(state.df).length === 0 && delete state.df;
  }
  if (state.dfExcluded) {
    delete state.dfExcluded[facetId2];
    Object.keys(state.dfExcluded).length === 0 && delete state.dfExcluded;
  }
  if (state.lf) {
    delete state.lf[facetId2];
    Object.keys(state.lf).length === 0 && delete state.lf;
  }
  if (state.mnf) {
    delete state.mnf[facetId2];
    Object.keys(state.mnf).length === 0 && delete state.mnf;
  }
  if (state.mnfExcluded) {
    delete state.mnfExcluded[facetId2];
    Object.keys(state.mnfExcluded).length === 0 && delete state.mnfExcluded;
  }
  if (state.nf) {
    delete state.nf[facetId2];
    Object.keys(state.nf).length === 0 && delete state.nf;
  }
  if (state.nfExcluded) {
    delete state.nfExcluded[facetId2];
    Object.keys(state.nfExcluded).length === 0 && delete state.nfExcluded;
  }
  if (state.f) {
    delete state.f[facetId2];
    Object.keys(state.f).length === 0 && delete state.f;
  }
  if (state.fExcluded) {
    delete state.fExcluded[facetId2];
    Object.keys(state.fExcluded).length === 0 && delete state.fExcluded;
  }
};
const handleToggleCategoryFacetValue = (state, payload) => {
  state.page = void 0;
  if (payload.selection.state === "selected") {
    state.cf ??= {};
    delete state.cf[payload.facetId];
    if (Object.keys(state.cf).length === 0) {
      state.cf = void 0;
    }
    return;
  }
  state.cf ??= {};
  state.cf[payload.facetId] = payload.selection.path;
};
const handleSelectCategoryFacetSearchResult = (state, action) => {
  const payload = action.payload;
  state.page = void 0;
  state.cf ??= {};
  state.cf[payload.facetId] = [...payload.value.path, payload.value.rawValue];
};
const handleToggleSelectFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRegularValue(state, "fExcluded", state.fExcluded, payload.facetId, payload.selection.value);
  switch (payload.selection.state) {
    case "selected":
      unsetRegularValue(state, "f", state.f, payload.facetId, payload.selection.value);
      break;
    case "excluded":
    case "idle":
      state.f ??= {};
      state.f[payload.facetId] = [
        ...state.f[payload.facetId] ?? [],
        payload.selection.value
      ];
      break;
  }
};
const handleSelectFacetSearchResult = (state, action) => {
  const payload = action.payload;
  state.page = void 0;
  unsetRegularValue(state, "fExcluded", state.fExcluded, payload.facetId, payload.value.rawValue);
  state.f ??= {};
  state.f[payload.facetId] = [
    ...state.f[payload.facetId] ?? [],
    payload.value.rawValue
  ];
};
const handleToggleExcludeFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRegularValue(state, "f", state.f, payload.facetId, payload.selection.value);
  switch (payload.selection.state) {
    case "excluded":
      unsetRegularValue(state, "fExcluded", state.fExcluded, payload.facetId, payload.selection.value);
      break;
    case "selected":
    case "idle":
      state.fExcluded ??= {};
      state.fExcluded[payload.facetId] = [
        ...state.fExcluded[payload.facetId] ?? [],
        payload.selection.value
      ];
      break;
  }
};
const handleExcludeFacetSearchResult = (state, action) => {
  const payload = action.payload;
  state.page = void 0;
  unsetRegularValue(state, "f", state.f, payload.facetId, payload.value.rawValue);
  state.fExcluded ??= {};
  state.fExcluded[payload.facetId] = [
    ...state.fExcluded[payload.facetId] ?? [],
    payload.value.rawValue
  ];
};
const handleToggleSelectNumericFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload.selection);
  unsetRangeValue(state, "mnfExcluded", state.mnfExcluded, payload.facetId, payload.selection);
  unsetRangeValue(state, "nfExcluded", state.nfExcluded, payload.facetId, payload.selection);
  switch (payload.selection.state) {
    case "selected":
      unsetRangeValue(state, "nf", state.nf, payload.facetId, payload.selection);
      break;
    case "excluded":
    case "idle":
      state.nf ??= {};
      state.nf[payload.facetId] = [
        ...state.nf[payload.facetId] ?? [],
        payload.selection
      ];
      break;
  }
};
const handleToggleExcludeNumericFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload.selection);
  unsetRangeValue(state, "mnfExcluded", state.mnfExcluded, payload.facetId, payload.selection);
  unsetRangeValue(state, "nf", state.nf, payload.facetId, payload.selection);
  switch (payload.selection.state) {
    case "excluded":
      unsetRangeValue(state, "nfExcluded", state.nfExcluded, payload.facetId, payload.selection);
      break;
    case "selected":
    case "idle":
      state.nfExcluded ??= {};
      state.nfExcluded[payload.facetId] = [
        ...state.nfExcluded[payload.facetId] ?? [],
        payload.selection
      ];
      break;
  }
};
const handleUpdateManualNumericFacetRange = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "nf", state.nf, payload.facetId, payload);
  unsetRangeValue(state, "nfExcluded", state.nfExcluded, payload.facetId, payload);
  const { facetId: _facetId, ...restOfPayload } = payload;
  switch (payload.state) {
    case "idle":
      unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload);
      unsetRangeValue(state, "mnfExcluded", state.mnfExcluded, payload.facetId, payload);
      break;
    case "excluded":
      unsetRangeValue(state, "mnf", state.mnf, payload.facetId, payload);
      state.mnfExcluded ??= {};
      state.mnfExcluded[payload.facetId] = [restOfPayload];
      break;
    case "selected":
      unsetRangeValue(state, "mnfExcluded", state.mnfExcluded, payload.facetId, payload);
      state.mnf ??= {};
      state.mnf[payload.facetId] = [restOfPayload];
      break;
  }
};
const handleToggleSelectDateFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "dfExcluded", state.dfExcluded, payload.facetId, payload.selection);
  const { numberOfResults: _numberOfResults, ...restOfPayload } = payload.selection;
  switch (payload.selection.state) {
    case "selected":
      unsetRangeValue(state, "df", state.df, payload.facetId, payload.selection);
      break;
    case "excluded":
    case "idle":
      state.df ??= {};
      state.df[payload.facetId] = [
        ...state.df[payload.facetId] ?? [],
        restOfPayload
      ];
      break;
  }
};
const handleToggleExcludeDateFacetValue = (state, payload) => {
  state.page = void 0;
  unsetRangeValue(state, "df", state.df, payload.facetId, payload.selection);
  const { numberOfResults: _numberOfResults, ...restOfPayload } = payload.selection;
  switch (payload.selection.state) {
    case "excluded":
      unsetRangeValue(state, "dfExcluded", state.dfExcluded, payload.facetId, payload.selection);
      break;
    case "selected":
    case "idle":
      state.dfExcluded ??= {};
      state.dfExcluded[payload.facetId] = [
        ...state.dfExcluded[payload.facetId] ?? [],
        restOfPayload
      ];
      break;
  }
};
const handleToggleSelectLocationFacetValue = (state, payload) => {
  state.page = void 0;
  switch (payload.selection.state) {
    case "selected":
      unsetRegularValue(state, "lf", state.lf, payload.facetId, payload.selection.value);
      break;
    case "excluded":
    case "idle":
      state.lf ??= {};
      state.lf[payload.facetId] = [
        ...state.lf[payload.facetId] ?? [],
        payload.selection.value
      ];
      break;
  }
};
const unsetRegularValue = (state, stateKey2, stateParameter, facetId2, selection) => {
  if (stateParameter !== void 0 && stateParameter[facetId2] !== void 0) {
    stateParameter[facetId2] = stateParameter[facetId2].filter((value) => value !== selection);
    if (stateParameter[facetId2].length === 0) {
      delete stateParameter[facetId2];
    }
    if (Object.keys(stateParameter).length === 0) {
      state[stateKey2] = void 0;
    }
  }
};
const unsetRangeValue = (state, stateKey2, stateParameter, facetId2, selection) => {
  if (stateParameter !== void 0 && stateParameter[facetId2] !== void 0) {
    const filtered = stateParameter[facetId2].filter((value) => value.start !== selection.start || value.end !== selection.end || value.endInclusive !== selection.endInclusive);
    stateParameter[facetId2] = filtered;
    if (stateParameter[facetId2].length === 0) {
      delete stateParameter[facetId2];
    }
    if (Object.keys(stateParameter).length === 0) {
      state[stateKey2] = void 0;
    }
  }
};
const initialStateSchema = (parametersDefinition2) => new Schema({
  parameters: new RecordValue({
    options: { required: true },
    values: parametersDefinition2
  })
});
function buildCoreParameterManager(engine, props) {
  if (props.excludeDefaultParameters && !loadParameterManagerReducers(engine)) ;
  const parametersSelector = createSelector((state) => state.commerceParameters, (parameters) => parameters);
  const { dispatch } = engine;
  const controller = buildController(engine);
  if (props.initialState) {
    validateInitialState(engine, initialStateSchema(props.parametersDefinition), props.initialState, "buildCoreParameterManager");
    dispatch(props.restoreActionCreator(props.initialState.parameters));
  }
  return {
    ...controller,
    synchronize(parameters) {
      const activeParams = props.activeParametersSelector(engine[stateKey]);
      if (Object.keys(parameters).length > 0 && deepEqualAnyOrder(activeParams, parameters)) {
        return;
      }
      dispatch(props.restoreActionCreator(parameters));
      dispatch(props.fetchProductsActionCreator());
    },
    get state() {
      return {
        parameters: props.excludeDefaultParameters ? parametersSelector(engine[stateKey]) : props.activeParametersSelector(engine[stateKey])
      };
    }
  };
}
function loadParameterManagerReducers(engine) {
  engine.addReducers({
    commerceParameters: parametersReducer
  });
  return true;
}
const buildCoreSummary = (engine, props) => {
  const controller = buildController(engine);
  const { options: { numberOfProductsSelector: numberOfProductsSelector2, responseIdSelector: responseIdSelector2, isLoadingSelector: isLoadingSelector2, errorSelector: errorSelector2, pageSelector, perPageSelector, totalEntriesSelector, enrichSummary } } = props;
  const getState = () => engine[stateKey];
  const page = () => pageSelector(getState());
  const perPage = () => perPageSelector(getState());
  const totalNumberOfProducts = () => totalEntriesSelector(getState());
  const firstSearchExecuted2 = () => !!responseIdSelector2(getState());
  const hasProducts = () => firstSearchExecuted2() && totalNumberOfProducts() > 0;
  const firstProduct = () => hasProducts() ? page() * perPage() + 1 : 0;
  const lastProduct = () => hasProducts() ? firstProduct() + (numberOfProductsSelector2(getState()) - 1) : 0;
  return {
    ...controller,
    get state() {
      return {
        firstRequestExecuted: firstSearchExecuted2(),
        firstProduct: firstProduct(),
        lastProduct: lastProduct(),
        totalNumberOfProducts: totalNumberOfProducts(),
        hasProducts: hasProducts(),
        isLoading: isLoadingSelector2(getState()),
        hasError: errorSelector2(getState()) !== null,
        ...enrichSummary ? enrichSummary(getState()) : {}
      };
    }
  };
};
function buildCoreUrlManager(engine, props) {
  let lastRequestId;
  function updateLastRequestId() {
    lastRequestId = props.requestIdSelector(engine[stateKey]);
  }
  function hasRequestIdChanged() {
    return lastRequestId !== props.requestIdSelector(engine[stateKey]);
  }
  validateInitialState(engine, initialStateSchema$1, props.initialState, "buildUrlManager");
  const controller = buildController(engine);
  let previousFragment = props.initialState.fragment;
  updateLastRequestId();
  const parameterManager = props.parameterManagerBuilder(engine, {
    initialState: {
      parameters: props.serializer.deserialize(previousFragment)
    },
    excludeDefaultParameters: props.excludeDefaultParameters ?? false
  });
  return {
    ...controller,
    subscribe(listener) {
      const strictListener = () => {
        const newFragment = this.state.fragment;
        if (!areFragmentsEquivalent(props.serializer.deserialize, previousFragment, newFragment) && hasRequestIdChanged()) {
          previousFragment = newFragment;
          listener();
        }
        updateLastRequestId();
      };
      strictListener();
      return engine.subscribe(strictListener);
    },
    get state() {
      return {
        fragment: props.serializer.serialize(parameterManager.state.parameters)
      };
    },
    synchronize(fragment) {
      previousFragment = fragment;
      const parameters = props.serializer.deserialize(fragment);
      parameterManager.synchronize(parameters);
    }
  };
}
function areFragmentsEquivalent(deserialize2, fragment1, fragment2) {
  if (fragment1 === fragment2) {
    return true;
  }
  const params1 = deserialize2(fragment1);
  const params2 = deserialize2(fragment2);
  return deepEqualAnyOrder(params1, params2);
}
function buildSearchSubControllers(engine, subControllerProps) {
  return {
    ...buildSearchAndListingsSubControllers(engine, {
      ...subControllerProps,
      facetSearchType: "SEARCH"
    }),
    didYouMean() {
      return buildDidYouMean(engine);
    }
  };
}
function buildProductListingSubControllers(engine, subControllerProps) {
  return buildSearchAndListingsSubControllers(engine, {
    ...subControllerProps,
    facetSearchType: "LISTING"
  });
}
function buildSearchAndListingsSubControllers(engine, subControllerProps) {
  const { fetchProductsActionCreator, facetResponseSelector: facetResponseSelector2, isFacetLoadingResponseSelector: isFacetLoadingResponseSelector2, requestIdSelector: requestIdSelector2, serializer, parametersDefinition: parametersDefinition2, activeParametersSelector: activeParametersSelector2, restoreActionCreator, facetSearchType } = subControllerProps;
  return {
    ...buildBaseSubControllers(engine, subControllerProps),
    sort(props) {
      return buildCoreSort(engine, {
        ...props,
        fetchProductsActionCreator
      });
    },
    facetGenerator() {
      const commonOptions = {
        fetchProductsActionCreator,
        facetResponseSelector: facetResponseSelector2,
        isFacetLoadingResponseSelector: isFacetLoadingResponseSelector2,
        facetSearch: { type: facetSearchType }
      };
      return buildFacetGenerator(engine, {
        buildRegularFacet: (_engine, options2) => buildCommerceRegularFacet(engine, { ...options2, ...commonOptions }),
        buildNumericFacet: (_engine, options2) => buildCommerceNumericFacet(engine, { ...options2, ...commonOptions }),
        buildDateFacet: (_engine, options2) => buildCommerceDateFacet(engine, { ...options2, ...commonOptions }),
        buildCategoryFacet: (_engine, options2) => buildCategoryFacet(engine, { ...options2, ...commonOptions }),
        buildLocationFacet: (_engine, options2) => buildCommerceLocationFacet(engine, { ...options2, ...commonOptions }),
        fetchProductsActionCreator
      });
    },
    breadcrumbManager() {
      return buildCoreBreadcrumbManager(engine, {
        facetResponseSelector: facetResponseSelector2,
        fetchProductsActionCreator
      });
    },
    urlManager(props) {
      return buildCoreUrlManager(engine, {
        ...props,
        requestIdSelector: requestIdSelector2,
        parameterManagerBuilder: (_engine, props2) => this.parameterManager(props2),
        serializer
      });
    },
    parameterManager(props) {
      return buildCoreParameterManager(engine, {
        ...props,
        parametersDefinition: parametersDefinition2,
        activeParametersSelector: activeParametersSelector2,
        restoreActionCreator,
        fetchProductsActionCreator
      });
    }
  };
}
function buildBaseSubControllers(engine, subControllerProps) {
  const { responseIdSelector: responseIdSelector2, isLoadingSelector: isLoadingSelector2, errorSelector: errorSelector2, numberOfProductsSelector: numberOfProductsSelector2, fetchProductsActionCreator, fetchMoreProductsActionCreator, slotId, pageSelector, perPageSelector, totalEntriesSelector, enrichSummary } = subControllerProps;
  return {
    interactiveProduct(props) {
      return buildCoreInteractiveProduct(engine, {
        ...props,
        responseIdSelector: responseIdSelector2
      });
    },
    pagination(props) {
      return buildCorePagination(engine, {
        ...props,
        options: {
          ...props?.options,
          slotId
        },
        fetchProductsActionCreator,
        fetchMoreProductsActionCreator
      });
    },
    summary() {
      return buildCoreSummary(engine, {
        options: {
          responseIdSelector: responseIdSelector2,
          isLoadingSelector: isLoadingSelector2,
          errorSelector: errorSelector2,
          numberOfProductsSelector: numberOfProductsSelector2,
          pageSelector,
          perPageSelector,
          totalEntriesSelector,
          enrichSummary
        }
      });
    }
  };
}
const facetResponseSelector = createSelector((state, facetId2) => ({ state, facetId: facetId2 }), ({ state, facetId: facetId2 }) => {
  const facetResponse = state.productListing.facets.find((facetResponse2) => facetResponse2.facetId === facetId2);
  if (facetResponse && facetResponse.facetId in state.commerceFacetSet) {
    return facetResponse;
  }
  return void 0;
});
const isFacetLoadingResponseSelector = createSelector((state) => ({ state }), ({ state }) => state.productListing.isLoading);
function buildProductListing(engine) {
  if (!loadBaseProductListingReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const subControllers = buildProductListingSubControllers(engine, {
    responseIdSelector: responseIdSelector$1,
    fetchProductsActionCreator: fetchProductListing,
    fetchMoreProductsActionCreator: fetchMoreProducts$1,
    facetResponseSelector,
    isFacetLoadingResponseSelector,
    requestIdSelector: requestIdSelector$1,
    serializer: productListingSerializer,
    parametersDefinition,
    activeParametersSelector: activeParametersSelector$1,
    restoreActionCreator: restoreProductListingParameters,
    isLoadingSelector: isLoadingSelector$2,
    errorSelector: errorSelector$1,
    pageSelector: pagePrincipalSelector,
    perPageSelector: perPagePrincipalSelector,
    totalEntriesSelector: totalEntriesPrincipalSelector,
    numberOfProductsSelector: numberOfProductsSelector$1
  });
  return {
    ...controller,
    ...subControllers,
    get state() {
      const { products, error, isLoading, responseId } = getState().productListing;
      return {
        products,
        error,
        isLoading,
        responseId
      };
    },
    promoteChildToParent(child) {
      dispatch(promoteChildToParent$3({ child }));
    },
    refresh: () => dispatch(fetchProductListing()),
    executeFirstRequest() {
      const firstRequestExecuted = responseIdSelector$1(getState()) !== "";
      if (firstRequestExecuted) {
        return;
      }
      dispatch(fetchProductListing());
    }
  };
}
function loadBaseProductListingReducers(engine) {
  engine.addReducers({ productListing: productListingReducer, commerceContext: contextReducer, configuration });
  return true;
}
function buildRecommendations(engine, props) {
  if (!loadBaseRecommendationsReducers(engine)) ;
  validateInitialState(engine, recommendationsOptionsSchema, props.options, "buildRecommendations");
  const controller = buildController(engine);
  const { dispatch } = engine;
  const { slotId, productId } = props.options;
  dispatch(registerRecommendationsSlot({ slotId, productId }));
  const recommendationStateSelector = createSelector((state) => state.recommendations[slotId], (recommendations) => recommendations);
  const subControllers = buildBaseSubControllers(engine, {
    slotId,
    responseIdSelector: (state) => state.recommendations[slotId].responseId,
    fetchProductsActionCreator: () => fetchRecommendations({ slotId }),
    fetchMoreProductsActionCreator: () => fetchMoreRecommendations({ slotId }),
    isLoadingSelector: (state) => isLoadingSelector(state, slotId),
    errorSelector: (state) => state.recommendations[slotId].error,
    pageSelector: (state) => pageRecommendationSelector(state, slotId),
    perPageSelector: (state) => perPageRecommendationSelector(state, slotId),
    totalEntriesSelector: (state) => totalEntriesRecommendationSelector(state, slotId),
    numberOfProductsSelector: (state) => numberOfRecommendationsSelector(state, slotId)
  });
  return {
    ...controller,
    ...subControllers,
    promoteChildToParent(child) {
      dispatch(promoteChildToParent$1({ child, slotId }));
    },
    get state() {
      return recommendationStateSelector(engine[stateKey]);
    },
    refresh: () => dispatch(fetchRecommendations({ slotId, productId }))
  };
}
function loadBaseRecommendationsReducers(engine) {
  engine.addReducers({ recommendations: recommendationsReducer });
  return true;
}
function buildSearch(engine) {
  if (!loadBaseSearchReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine[stateKey];
  const subControllers = buildSearchSubControllers(engine, {
    responseIdSelector,
    fetchProductsActionCreator: executeSearch,
    fetchMoreProductsActionCreator: fetchMoreProducts,
    facetResponseSelector: facetResponseSelector$1,
    isFacetLoadingResponseSelector: isFacetLoadingResponseSelector$1,
    requestIdSelector,
    serializer: searchSerializer,
    parametersDefinition: searchParametersDefinition,
    restoreActionCreator: restoreSearchParameters,
    activeParametersSelector,
    isLoadingSelector: isLoadingSelector$1,
    errorSelector,
    pageSelector: pagePrincipalSelector,
    perPageSelector: perPagePrincipalSelector,
    totalEntriesSelector: totalEntriesPrincipalSelector,
    numberOfProductsSelector,
    enrichSummary: enrichedSummarySelector
  });
  return {
    ...controller,
    ...subControllers,
    get state() {
      return getState().commerceSearch;
    },
    promoteChildToParent(child) {
      dispatch(promoteChildToParent$2({ child }));
    },
    executeFirstSearch() {
      const firstSearchExecuted2 = responseIdSelector(getState()) !== "";
      if (firstSearchExecuted2) {
        return;
      }
      dispatch(executeSearch());
    }
  };
}
function loadBaseSearchReducers(engine) {
  engine.addReducers({
    commerceContext: contextReducer,
    configuration,
    commerceSearch: commerceSearchReducer,
    commerceQuery: queryReducer
  });
  return true;
}
const { id, highlightOptions, clearFilters } = searchBoxOptionDefinitions$1;
const searchBoxOptionDefinitions = { id, highlightOptions, clearFilters };
function getCommerceStandaloneSearchBoxSetInitialState() {
  return {};
}
createReducer(getCommerceStandaloneSearchBoxSetInitialState(), (builder) => builder.addCase(registerStandaloneSearchBox, (state, action) => {
  const { id: id2, redirectionUrl, overwrite } = action.payload;
  if (!overwrite && id2 in state) {
    return;
  }
  state[id2] = buildStandaloneSearchBoxEntry(redirectionUrl);
}).addCase(updateStandaloneSearchBoxRedirectionUrl, (state, action) => {
  const { id: id2, redirectionUrl } = action.payload;
  const searchBox = state[id2];
  if (!searchBox) {
    return;
  }
  searchBox.defaultRedirectionUrl = redirectionUrl;
}).addCase(resetStandaloneSearchBox, (state, action) => {
  const { id: id2 } = action.payload;
  const searchBox = state[id2];
  if (searchBox) {
    state[id2] = buildStandaloneSearchBoxEntry(searchBox.defaultRedirectionUrl);
    return;
  }
}).addCase(fetchRedirectUrl.pending, (state, action) => {
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.isLoading = true;
}).addCase(fetchRedirectUrl.fulfilled, (state, action) => {
  const redirectionUrl = action.payload;
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.redirectTo = redirectionUrl ? redirectionUrl : searchBox.defaultRedirectionUrl;
  searchBox.isLoading = false;
}).addCase(fetchRedirectUrl.rejected, (state, action) => {
  const searchBox = state[action.meta.arg.id];
  if (!searchBox) {
    return;
  }
  searchBox.isLoading = false;
}));
function buildStandaloneSearchBoxEntry(defaultRedirectionUrl) {
  return {
    defaultRedirectionUrl,
    redirectTo: "",
    isLoading: false
  };
}
new Schema({
  ...searchBoxOptionDefinitions,
  redirectionUrl: new StringValue({
    required: true,
    emptyAllowed: false
  }),
  overwrite: new BooleanValue({
    required: false
  })
});
const ProductListing = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.products.length) {
    return /* @__PURE__ */ jsx("button", { onClick: () => controller.refresh(), children: "Refresh" });
  }
  return /* @__PURE__ */ jsx("ul", { children: state.products.map(({ ec_name, clickUri, permanentid }) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("a", { href: clickUri, children: ec_name }) }, permanentid)) });
};
const AppContext = createContext({});
function ProductListingPage() {
  const engine = useMemo(
    () => buildCommerceEngine({
      configuration: getSampleCommerceEngineConfiguration()
    }),
    []
  );
  const productListing = buildProductListing(engine);
  return /* @__PURE__ */ jsx(AppContext.Provider, { value: { commerceEngine: engine }, children: /* @__PURE__ */ jsx(Section, { title: "product-listing", children: /* @__PURE__ */ jsx(ProductListing, { controller: productListing }) }) });
}
const Recommendations = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.products.length) {
    return /* @__PURE__ */ jsx("button", { onClick: () => controller.refresh(), children: "Refresh" });
  }
  return /* @__PURE__ */ jsx("ul", { children: state.products.map(({ ec_name, clickUri, permanentid }) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("a", { href: clickUri, children: ec_name }) }, permanentid)) });
};
function RecommendationsPage() {
  const engine = useMemo(
    () => buildCommerceEngine({
      configuration: getSampleCommerceEngineConfiguration()
    }),
    []
  );
  const recommendations = buildRecommendations(engine, {
    options: {
      slotId: "abccdea4-7d8d-4d56-b593-20267083f88f"
    }
  });
  return /* @__PURE__ */ jsx(AppContext.Provider, { value: { commerceEngine: engine }, children: /* @__PURE__ */ jsx(Section, { title: "recommendations", children: /* @__PURE__ */ jsx(Recommendations, { controller: recommendations }) }) });
}
const Search = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.products.length) {
    return /* @__PURE__ */ jsx("button", { onClick: () => controller.executeFirstSearch(), children: "Refresh" });
  }
  return /* @__PURE__ */ jsx("ul", { children: state.products.map(({ ec_name, clickUri, permanentid }) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("a", { href: clickUri, children: ec_name }) }, permanentid)) });
};
function SearchPage$1() {
  const engine = useMemo(
    () => buildCommerceEngine({
      configuration: getSampleCommerceEngineConfiguration()
    }),
    []
  );
  const search = buildSearch(engine);
  return /* @__PURE__ */ jsx(AppContext.Provider, { value: { commerceEngine: engine }, children: /* @__PURE__ */ jsx(Section, { title: "search", children: /* @__PURE__ */ jsx(Search, { controller: search }) }) });
}
const FacetSearch = (props) => {
  const onInput = (text) => {
    props.controller.updateText(text);
    props.controller.search();
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("input", { onInput: (e) => onInput(e.currentTarget.value) }),
    /* @__PURE__ */ jsx("ul", { children: props.facetState.values.map((facetSearchValue) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs(
      "button",
      {
        onClick: () => props.controller.select(facetSearchValue),
        disabled: props.isValueSelected(facetSearchValue),
        children: [
          facetSearchValue.displayValue,
          " (",
          facetSearchValue.count,
          " results)"
        ]
      }
    ) }, facetSearchValue.rawValue)) })
  ] });
};
const Facet$1 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.values.length) {
    return /* @__PURE__ */ jsx("div", { children: "No facet values" });
  }
  return /* @__PURE__ */ jsxs("ul", { children: [
    /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
      FacetSearch,
      {
        controller: controller.facetSearch,
        facetState: state.facetSearch,
        isValueSelected: (facetSearchValue) => !!state.values.find(
          (facetValue) => facetValue.value === facetSearchValue.displayValue && controller.isValueSelected(facetValue)
        )
      }
    ) }),
    /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("ul", { children: state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: controller.isValueSelected(value),
          onChange: () => controller.toggleSelect(value),
          disabled: state.isLoading
        }
      ),
      value.value,
      " (",
      value.numberOfResults,
      " results)"
    ] }, value.value)) }) })
  ] });
};
const MultilevelDependentFacet = ({ engine, dependencies }) => {
  const [showFacet, setShowFacet] = useState({});
  Object.values(dependencies).forEach(({ facet }) => {
    useEffect(
      () => facet.subscribe(
        () => setShowFacet((otherValues) => ({
          ...otherValues,
          [facet.state.facetId]: facet.state.enabled
        }))
      ),
      []
    );
  });
  Object.values(dependencies).forEach(({ facet, dependsOn }) => {
    useEffect(() => {
      if (!dependsOn) {
        return;
      }
      const facetConditionsManager = buildCoreFacetConditionsManager(engine, {
        facetId: facet.state.facetId,
        conditions: [
          {
            parentFacetId: dependsOn.state.facetId,
            condition: (parentValues) => parentValues.some((value) => value.state === "selected")
          }
        ]
      });
      return facetConditionsManager.stopWatching;
    });
  });
  return /* @__PURE__ */ jsx(Fragment, { children: Object.entries(showFacet).map(([facetId2, showDependentFacet]) => {
    return showDependentFacet && /* @__PURE__ */ jsx(Facet$1, { controller: dependencies[facetId2].facet }, facetId2);
  }) });
};
const SingleParentMultipleDependentFacet = ({ engine, parentFacet, dependentFacets }) => {
  const [showDependentFacet, setShowDependentFacet] = useState(false);
  dependentFacets.forEach((facet) => {
    useEffect(
      () => facet.subscribe(() => setShowDependentFacet(facet.state.enabled)),
      []
    );
  });
  dependentFacets.forEach((facet) => {
    useEffect(() => {
      const facetConditionsManager = buildCoreFacetConditionsManager(engine, {
        facetId: facet.state.facetId,
        conditions: [
          {
            parentFacetId: parentFacet.state.facetId,
            condition: (parentValues) => parentValues.some((value) => value.state === "selected")
          }
        ]
      });
      return facetConditionsManager.stopWatching;
    });
  });
  const parent = /* @__PURE__ */ jsx(Facet$1, { controller: parentFacet });
  const dependent = /* @__PURE__ */ jsx(Fragment, { children: dependentFacets.map((dependentFacet) => /* @__PURE__ */ jsx(Facet$1, { controller: dependentFacet }, dependentFacet.state.facetId)) });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("h4", { children: "Parent facet" }),
      parent
    ] }),
    /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("h4", { children: "Dependent facet" }),
      showDependentFacet ? dependent : null
    ] })
  ] });
};
const SingleParentSingleDependentFacet = ({ engine, parentFacet, dependentFacet }) => {
  const [showDependentFacet, setShowDependentFacet] = useState(false);
  useEffect(
    () => dependentFacet.subscribe(
      () => setShowDependentFacet(dependentFacet.state.enabled)
    ),
    []
  );
  useEffect(() => {
    const facetConditionsManager = buildCoreFacetConditionsManager(engine, {
      facetId: dependentFacet.state.facetId,
      conditions: [
        {
          parentFacetId: parentFacet.state.facetId,
          condition: (parentValues) => parentValues.some((value) => value.state === "selected")
        }
      ]
    });
    return facetConditionsManager.stopWatching;
  });
  const parent = /* @__PURE__ */ jsx(Facet$1, { controller: parentFacet });
  const dependent = /* @__PURE__ */ jsx(Facet$1, { controller: dependentFacet });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("h4", { children: "Parent facet" }),
      parent
    ] }),
    /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("h4", { children: "Dependent facet" }),
      showDependentFacet ? dependent : null
    ] })
  ] });
};
const SingleValueDependentFacet = ({ engine, parentFacet, dependentFacet, dependentValue }) => {
  const [showDependentFacet, setShowDependentFacet] = useState(false);
  useEffect(
    () => dependentFacet.subscribe(
      () => setShowDependentFacet(dependentFacet.state.enabled)
    ),
    []
  );
  useEffect(() => {
    const facetConditionsManager = buildCoreFacetConditionsManager(engine, {
      facetId: dependentFacet.state.facetId,
      conditions: [
        {
          parentFacetId: parentFacet.state.facetId,
          condition: (parentValues) => parentValues.some(
            (value) => "value" in value && value.value === dependentValue && value.state === "selected"
          )
        }
      ]
    });
    return facetConditionsManager.stopWatching;
  });
  const parent = /* @__PURE__ */ jsx(Facet$1, { controller: parentFacet });
  const dependent = /* @__PURE__ */ jsx(Facet$1, { controller: dependentFacet });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("h4", { children: "Parent facet" }),
      parent
    ] }),
    /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("h4", { children: "Dependent facet" }),
      showDependentFacet ? dependent : null
    ] })
  ] });
};
const Examples = {
  SingleParentSingleDependent: {
    name: "Single parent and dependent facet",
    description: "The most simple dependency: A single parent with a single dependent facet."
  },
  SingleParentMultipleDependent: {
    name: "Single parent with multiple dependent facet",
    description: "An example of a single parent facet, that controls the appearance of multiple dependent facet"
  },
  SingleValueDependent: {
    name: "Single parent with a single value dependency",
    description: "A dependency where the dependent facet only appears if a precise value is selected (filetype == doc)"
  },
  ComplexDependencies: {
    name: "Complex dependency (multiple level)",
    description: "A dependency with multiple level of hierarchy, where a grandparent facet controls the appearance of multiple parent facet, each with their own dependent facet"
  }
};
class DependentFacetPage extends Component {
  engine;
  authorFacet;
  sourceFacet;
  objectTypeFacet;
  fileTypeFacet;
  constructor(props) {
    super(props);
    this.engine = buildSearchEngine({
      configuration: getSampleSearchEngineConfiguration()
    });
    this.authorFacet = buildFacet(this.engine, { options: { field: "author" } });
    this.sourceFacet = buildFacet(this.engine, { options: { field: "source" } });
    this.objectTypeFacet = buildFacet(this.engine, {
      options: { field: "objecttype" }
    });
    this.fileTypeFacet = buildFacet(this.engine, {
      options: { field: "filetype" }
    });
    this.state = { currentExample: "SingleParentSingleDependent" };
  }
  componentDidMount() {
    this.engine.executeFirstSearch();
  }
  render() {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        "select",
        {
          onChange: (e) => this.setState({ currentExample: e.target.value }),
          children: Object.entries(Examples).map(([key, value]) => /* @__PURE__ */ jsx("option", { value: key, children: value.name }, key))
        }
      ),
      /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsx("h2", { children: Examples[this.state.currentExample].name }),
        /* @__PURE__ */ jsx("h3", { children: Examples[this.state.currentExample].description }),
        this.renderExample()
      ] })
    ] });
  }
  renderExample() {
    switch (this.state.currentExample) {
      case "SingleParentSingleDependent":
        return /* @__PURE__ */ jsx(
          SingleParentSingleDependentFacet,
          {
            engine: this.engine,
            parentFacet: this.sourceFacet,
            dependentFacet: this.objectTypeFacet
          }
        );
      case "SingleParentMultipleDependent":
        return /* @__PURE__ */ jsx(
          SingleParentMultipleDependentFacet,
          {
            engine: this.engine,
            parentFacet: this.sourceFacet,
            dependentFacets: [this.objectTypeFacet, this.fileTypeFacet]
          }
        );
      case "SingleValueDependent":
        return /* @__PURE__ */ jsx(
          SingleValueDependentFacet,
          {
            engine: this.engine,
            parentFacet: this.fileTypeFacet,
            dependentFacet: this.authorFacet,
            dependentValue: "doc"
          }
        );
      case "ComplexDependencies":
        return /* @__PURE__ */ jsx(
          MultilevelDependentFacet,
          {
            engine: this.engine,
            dependencies: {
              [this.sourceFacet.state.facetId]: {
                facet: this.sourceFacet
              },
              [this.objectTypeFacet.state.facetId]: {
                facet: this.objectTypeFacet,
                dependsOn: this.sourceFacet
              },
              [this.authorFacet.state.facetId]: {
                facet: this.authorFacet,
                dependsOn: this.sourceFacet
              },
              [this.fileTypeFacet.state.facetId]: {
                facet: this.fileTypeFacet,
                dependsOn: this.authorFacet
              }
            }
          }
        );
      default:
        return null;
    }
  }
}
const getRecommendationInitialState = () => ({
  duration: 0,
  error: null,
  isLoading: false,
  id: "Recommendation",
  recommendations: [],
  searchUid: "",
  splitTestRun: "",
  pipeline: ""
});
class RecommendationAnalyticsProvider extends BaseAnalyticsProvider {
  getPipeline() {
    return this.state.pipeline || this.state.recommendation?.pipeline || "default";
  }
  getSearchEventRequestPayload() {
    return {
      queryText: getQueryInitialState().q,
      responseTime: this.responseTime,
      results: this.mapResultsToAnalyticsDocument(),
      numberOfResults: this.numberOfResults
    };
  }
  getSearchUID() {
    const newState = this.getState();
    return newState.recommendation?.searchUid || getRecommendationInitialState().searchUid;
  }
  getSplitTestRunName() {
    return this.state.recommendation?.splitTestRun;
  }
  getSplitTestRunVersion() {
    const hasSplitTestRun = !!this.getSplitTestRunName();
    const effectivePipelineWithSplitTestRun = this.state.recommendation?.pipeline || this.state.pipeline || "default";
    return hasSplitTestRun ? effectivePipelineWithSplitTestRun : void 0;
  }
  get responseTime() {
    return this.state.recommendation?.duration || getRecommendationInitialState().duration;
  }
  mapResultsToAnalyticsDocument() {
    return this.state.recommendation?.recommendations.map((r) => ({
      documentUri: r.uri,
      documentUriHash: r.raw.urihash
    }));
  }
  get numberOfResults() {
    return this.state.recommendation?.recommendations.length || getRecommendationInitialState().recommendations.length;
  }
}
const logRecommendationUpdate = () => makeAnalyticsAction("analytics/recommendation/update", (client) => client.makeRecommendationInterfaceLoad(), (getState) => new RecommendationAnalyticsProvider(getState));
const recommendationInterfaceLoad = () => ({
  actionCause: SearchPageEvents.recommendationInterfaceLoad
});
const logRecommendationOpen = (result) => makeAnalyticsAction({
  prefix: "analytics/recommendation/open",
  __legacy__getBuilder: (client, state) => {
    validateResultPayload(result);
    return client.makeRecommendationOpen(partialRecommendationInformation(result, state), documentIdentifier(result));
  },
  __legacy__provider: (getState) => new RecommendationAnalyticsProvider(getState),
  analyticsType: "itemClick",
  analyticsPayloadBuilder: (state) => {
    const docInfo = partialRecommendationInformation(result, state);
    const docId = documentIdentifier(result);
    return {
      responseId: result.searchUid ?? "",
      position: docInfo.documentPosition,
      itemMetadata: {
        uniqueFieldName: docId.contentIDKey,
        uniqueFieldValue: docId.contentIDValue,
        title: docInfo.documentTitle,
        author: docInfo.documentAuthor,
        url: docInfo.documentUrl
      }
    };
  }
});
const setRecommendationId = createAction("recommendation/set", (payload) => validatePayload(payload, {
  id: requiredNonEmptyString
}));
const getRecommendations = createAsyncThunk("recommendation/get", async (_, { getState, rejectWithValue, extra: { apiClient } }) => {
  const state = getState();
  const startedAt = Date.now();
  const request = await buildRecommendationRequest(state);
  const fetched = await apiClient.recommendations(request);
  const duration = Date.now() - startedAt;
  if (isErrorResponse$1(fetched)) {
    return rejectWithValue(fetched.error);
  }
  return {
    recommendations: fetched.success.results,
    analyticsAction: logRecommendationUpdate(),
    duration,
    searchUid: fetched.success.searchUid,
    splitTestRun: fetched.success.splitTestRun,
    pipeline: fetched.success.pipeline
  };
});
const buildRecommendationRequest = async (s) => ({
  accessToken: s.configuration.accessToken,
  organizationId: s.configuration.organizationId,
  url: s.configuration.search.apiBaseUrl ?? getSearchApiBaseUrl(s.configuration.organizationId, s.configuration.environment),
  recommendation: s.recommendation.id,
  tab: s.configuration.analytics.originLevel2,
  referrer: s.configuration.analytics.originLevel3,
  timezone: s.configuration.search.timezone,
  locale: s.configuration.search.locale,
  actionsHistory: s.configuration.analytics.enabled ? HistoryStore2.getInstance().getHistory() : [],
  ...s.advancedSearchQueries && {
    aq: s.advancedSearchQueries.aq,
    cq: s.advancedSearchQueries.cq
  },
  ...s.pipeline && {
    pipeline: s.pipeline
  },
  ...s.searchHub && {
    searchHub: s.searchHub
  },
  ...s.context && {
    context: s.context.contextValues
  },
  ...s.dictionaryFieldContext && {
    dictionaryFieldContext: s.dictionaryFieldContext.contextValues
  },
  ...s.fields && {
    fieldsToInclude: s.fields.fieldsToInclude
  },
  ...s.configuration.analytics.enabled && await buildAnalyticsSection(s, recommendationInterfaceLoad()),
  ...s.configuration.search.authenticationProviders.length && {
    authentication: s.configuration.search.authenticationProviders.join(",")
  },
  ...s.pagination && {
    numberOfResults: s.pagination.numberOfResults
  }
});
const buildAnalyticsSection = async (state, action) => {
  const eventDescription = state.configuration.analytics.analyticsMode === "legacy" ? void 0 : {
    actionCause: action.actionCause,
    type: action.actionCause
  };
  return await fromAnalyticsStateToAnalyticsParams(state.configuration.analytics, eventDescription);
};
const recommendationReducer = createReducer(getRecommendationInitialState(), (builder) => {
  builder.addCase(setRecommendationId, (state, action) => {
    state.id = action.payload.id;
  }).addCase(getRecommendations.rejected, (state, action) => {
    state.error = action.payload ? action.payload : null;
    state.isLoading = false;
  }).addCase(getRecommendations.fulfilled, (state, action) => {
    state.error = null;
    state.recommendations = action.payload.recommendations.map((recommendation) => ({
      ...recommendation,
      searchUid: action.payload.searchUid
    }));
    state.duration = action.payload.duration;
    state.isLoading = false;
    state.searchUid = action.payload.searchUid;
    state.splitTestRun = action.payload.splitTestRun;
    state.pipeline = action.payload.pipeline;
  }).addCase(getRecommendations.pending, (state) => {
    state.isLoading = true;
  }).addCase(setError, (state, action) => {
    state.error = action.payload;
    state.isLoading = false;
  });
});
const recommendationEngineConfigurationSchema = new Schema({
  ...engineConfigurationDefinitions,
  pipeline: new StringValue({ required: false, emptyAllowed: true }),
  searchHub: nonEmptyString,
  locale: nonEmptyString,
  timezone: nonEmptyString
});
function getSampleRecommendationEngineConfiguration() {
  return {
    ...getSampleEngineConfiguration(),
    searchHub: "default"
  };
}
const recommendationEngineReducers = {
  debug: debugReducer,
  pipeline: pipelineReducer,
  searchHub: searchHubReducer,
  recommendation: recommendationReducer
};
function buildRecommendationEngine(options2) {
  const logger = buildLogger(options2.loggerOptions);
  validateConfiguration(options2.configuration, logger);
  const searchAPIClient = createSearchAPIClient(options2.configuration, logger);
  const thunkArguments = {
    ...buildThunkExtraArguments(options2.configuration, logger),
    apiClient: searchAPIClient
  };
  const augmentedOptions = {
    ...options2,
    reducers: recommendationEngineReducers
  };
  const engine = buildEngine(augmentedOptions, thunkArguments);
  const { pipeline, searchHub, timezone: timezone2, locale, proxyBaseUrl } = options2.configuration;
  engine.dispatch(updateSearchConfiguration({ timezone: timezone2, locale, proxyBaseUrl }));
  if (!isNullOrUndefined(pipeline)) {
    engine.dispatch(setPipeline(pipeline));
  }
  if (!isNullOrUndefined(searchHub)) {
    engine.dispatch(setSearchHub(searchHub));
  }
  return {
    ...engine,
    get state() {
      return engine.state;
    }
  };
}
function validateConfiguration(configuration2, logger) {
  try {
    recommendationEngineConfigurationSchema.validate(configuration2);
  } catch (error) {
    logger.error(error, "Recommendation engine configuration error");
    throw error;
  }
}
function createSearchAPIClient(configuration2, logger) {
  return new SearchAPIClient({
    logger,
    preprocessRequest: configuration2.preprocessRequest || NoopPreprocessRequest,
    postprocessSearchResponseMiddleware: configuration2.preprocessSearchResponseMiddleware || NoopPostprocessSearchResponseMiddleware,
    postprocessFacetSearchResponseMiddleware: NoopPostprocessFacetSearchResponseMiddleware,
    postprocessQuerySuggestResponseMiddleware: NoopPostprocessQuerySuggestResponseMiddleware
  });
}
const optionsSchema = new Schema({
  id: new StringValue({
    emptyAllowed: true,
    required: false,
    default: ""
  }),
  numberOfRecommendations: new NumberValue({ min: 0 })
});
function buildRecommendationList(engine, props = {}) {
  if (!loadRecommendationListReducers(engine)) ;
  const controller = buildController(engine);
  const { dispatch } = engine;
  const getState = () => engine.state;
  const options2 = validateOptions(engine, optionsSchema, props.options, "buildRecommendationList");
  if (options2.id !== "") {
    dispatch(setRecommendationId({ id: options2.id }));
  }
  if (options2.numberOfRecommendations) {
    dispatch(loadPaginationActions(engine).updateNumberOfResults(options2.numberOfRecommendations));
  }
  return {
    ...controller,
    refresh() {
      dispatch(getRecommendations());
    },
    get state() {
      const state = getState();
      return {
        recommendations: state.recommendation.recommendations,
        error: state.recommendation.error,
        isLoading: state.recommendation.isLoading,
        searchResponseId: state.recommendation.searchUid
      };
    }
  };
}
function loadRecommendationListReducers(engine) {
  engine.addReducers({ recommendation: recommendationReducer, configuration });
  return true;
}
function loadClickAnalyticsActions(engine) {
  engine.addReducers({});
  return {
    logRecommendationOpen
  };
}
function filterProtocol(uri) {
  const isAbsolute = /^(https?|ftp|file|mailto|tel|sip):/i.test(uri);
  const isRelative = /^(\/|\.\/|\.\.\/)/.test(uri);
  return isAbsolute || isRelative ? uri : "";
}
let RecommendationList$1 = class RecommendationList extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildRecommendationList(
      this.context.recommendationEngine,
      { options: this.props }
    );
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  logClick(recommendation) {
    const engine = this.context.recommendationEngine;
    if (!engine) {
      return;
    }
    const { logRecommendationOpen: logRecommendationOpen2 } = loadClickAnalyticsActions(engine);
    engine.dispatch(logRecommendationOpen2(recommendation));
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (this.state.error) {
      return /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsxs("div", { children: [
          "Oops ",
          this.state.error.message
        ] }),
        /* @__PURE__ */ jsx("code", { children: JSON.stringify(this.state.error) }),
        /* @__PURE__ */ jsx("button", { onClick: () => this.controller.refresh(), children: "Try again" })
      ] });
    }
    if (!this.state.recommendations.length) {
      return /* @__PURE__ */ jsx("button", { onClick: () => this.controller.refresh(), children: "Refresh" });
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("button", { onClick: () => this.controller.refresh(), children: "Refresh" }),
      /* @__PURE__ */ jsx("ul", { style: { textAlign: "left" }, children: this.state.recommendations.map((recommendation) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
        /* @__PURE__ */ jsx("h2", { children: /* @__PURE__ */ jsx(
          "a",
          {
            href: filterProtocol(recommendation.clickUri),
            onClick: () => this.logClick(recommendation),
            onContextMenu: () => this.logClick(recommendation),
            onMouseDown: () => this.logClick(recommendation),
            onMouseUp: () => this.logClick(recommendation),
            children: recommendation.title
          }
        ) }),
        /* @__PURE__ */ jsx("p", { children: recommendation.excerpt })
      ] }) }, recommendation.uniqueId)) })
    ] });
  }
};
const RecommendationList2 = (props) => {
  const engine = useContext(AppContext).recommendationEngine;
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (state.error) {
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsxs("div", { children: [
        "Oops ",
        state.error.message
      ] }),
      /* @__PURE__ */ jsx("code", { children: JSON.stringify(state.error) }),
      /* @__PURE__ */ jsx("button", { onClick: () => controller.refresh(), children: "Try again" })
    ] });
  }
  if (!state.recommendations.length) {
    return /* @__PURE__ */ jsx("button", { onClick: () => controller.refresh(), children: "Refresh" });
  }
  const logClick = (recommendation) => {
    if (!engine) {
      return;
    }
    const { logRecommendationOpen: logRecommendationOpen2 } = loadClickAnalyticsActions(engine);
    engine.dispatch(logRecommendationOpen2(recommendation));
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("button", { onClick: () => controller.refresh(), children: "Refresh" }),
    /* @__PURE__ */ jsx("ul", { style: { textAlign: "left" }, children: state.recommendations.map((recommendation) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
      /* @__PURE__ */ jsx("h2", { children: /* @__PURE__ */ jsx(
        "a",
        {
          href: filterProtocol(recommendation.clickUri),
          onClick: () => logClick(recommendation),
          onContextMenu: () => logClick(recommendation),
          onMouseDown: () => logClick(recommendation),
          onMouseUp: () => logClick(recommendation),
          children: recommendation.title
        }
      ) }),
      /* @__PURE__ */ jsx("p", { children: recommendation.excerpt })
    ] }) }, recommendation.uniqueId)) })
  ] });
};
function RecommendationPage() {
  const engine = useMemo(
    () => buildRecommendationEngine({
      configuration: getSampleRecommendationEngineConfiguration()
    }),
    []
  );
  const recommendationList = useMemo(
    () => buildRecommendationList(engine),
    [engine]
  );
  return /* @__PURE__ */ jsx(AppContext.Provider, { value: { recommendationEngine: engine }, children: /* @__PURE__ */ jsxs(Section, { title: "recommendation-list", children: [
    /* @__PURE__ */ jsx(RecommendationList$1, {}),
    /* @__PURE__ */ jsx(RecommendationList2, { controller: recommendationList })
  ] }) });
}
const samlClientOptions = {
  organizationId: "",
  provider: ""
};
const SamlPage = ({ children }) => {
  const [initialAccessToken, setInitialAccessToken] = useState("");
  const samlClient = useRef(null);
  useEffect(() => {
    if (samlClient.current) {
      return;
    }
    samlClient.current = buildSamlClient(samlClientOptions);
    samlClient.current.authenticate().then(setInitialAccessToken);
  }, []);
  const engine = useMemo(
    () => initialAccessToken && samlClient.current ? buildSearchEngine({
      configuration: {
        organizationId: samlClientOptions.organizationId,
        accessToken: initialAccessToken,
        renewAccessToken: samlClient.current.authenticate
      }
    }) : null,
    [samlClientOptions, samlClient.current, initialAccessToken]
  );
  if (!engine) {
    return null;
  }
  return /* @__PURE__ */ jsx(AppContext.Provider, { value: { engine }, children });
};
let AutomaticFacet$1 = class AutomaticFacet extends Component {
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = this.props.controller;
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsx("ul", { children: this.state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: value.state === "selected",
          onChange: () => this.controller.toggleSelect(value)
        }
      ),
      value.value,
      " (",
      value.numberOfResults,
      " results)"
    ] }, value.value)) });
  }
};
let AutomaticFacetGenerator$1 = class AutomaticFacetGenerator extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildAutomaticFacetGenerator(this.context.engine, {
      options: {
        desiredCount: this.props.desiredCount,
        numberOfValues: this.props.numberOfValues
      }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    const automaticFacets = this.state.automaticFacets.map((facet) => {
      return /* @__PURE__ */ jsx(
        AutomaticFacet$1,
        {
          controller: facet
        },
        facet.state.field
      );
    });
    return automaticFacets;
  }
};
const AutomaticFacet2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsx("ul", { children: state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        checked: value.state === "selected",
        onChange: () => controller.toggleSelect(value)
      }
    ),
    value.value,
    " (",
    value.numberOfResults,
    " results)"
  ] }, value.value)) });
};
const AutomaticFacetGenerator2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const automaticFacets = state.automaticFacets.map((facet) => {
    return /* @__PURE__ */ jsx(
      AutomaticFacet2,
      {
        controller: facet
      },
      facet.state.field
    );
  });
  return /* @__PURE__ */ jsx("div", { children: automaticFacets });
};
let BreadcrumbManager$1 = class BreadcrumbManager extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildBreadcrumbManager(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state?.hasBreadcrumbs) {
      return null;
    }
    return /* @__PURE__ */ jsx("ul", { children: this.state.facetBreadcrumbs.map((facet) => /* @__PURE__ */ jsxs("li", { children: [
      facet.field,
      ":",
      " ",
      facet.values.map((breadcrumb) => /* @__PURE__ */ jsx(
        "button",
        {
          onClick: () => breadcrumb.deselect(),
          children: breadcrumb.value.value
        },
        breadcrumb.value.value
      ))
    ] }, facet.facetId)) });
  }
};
const BreadcrumbManager2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state?.hasBreadcrumbs) {
    return null;
  }
  return /* @__PURE__ */ jsx("ul", { children: state.facetBreadcrumbs.map((facet) => /* @__PURE__ */ jsxs("li", { children: [
    facet.field,
    ":",
    " ",
    facet.values.map((breadcrumb) => /* @__PURE__ */ jsx(
      "button",
      {
        onClick: () => breadcrumb.deselect(),
        children: breadcrumb.value.value
      },
      breadcrumb.value.value
    ))
  ] }, facet.facetId)) });
};
const CategoryFacetSearch = (props) => {
  const onInput = (text) => {
    props.controller.updateText(text);
    props.controller.search();
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("input", { onInput: (e) => onInput(e.currentTarget.value) }),
    /* @__PURE__ */ jsx("ul", { children: props.searchState.values.map((value) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("button", { onClick: () => props.controller.select(value), children: [
      value.displayValue,
      " (",
      value.count,
      " results)"
    ] }) }, [...value.path, value.rawValue].join(">"))) })
  ] });
};
let CategoryFacet$1 = class CategoryFacet extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildCategoryFacet$1(this.context.engine, {
      options: this.props
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  getUniqueKeyForValue(value) {
    return value.path.join(">");
  }
  renderSearch() {
    return /* @__PURE__ */ jsx(
      CategoryFacetSearch,
      {
        controller: this.controller.facetSearch,
        searchState: this.state.facetSearch
      }
    );
  }
  renderClearButton() {
    return /* @__PURE__ */ jsx("button", { onClick: () => this.controller.deselectAll(), children: "All categories" });
  }
  renderParents() {
    return this.state.hasActiveValues && /* @__PURE__ */ jsxs("div", { children: [
      "Filtering by: ",
      this.renderClearButton(),
      this.state.valuesAsTrees.map((parentValue, i) => {
        const isSelectedValue = i === this.state.valuesAsTrees.length - 1;
        return /* @__PURE__ */ jsxs("span", { children: [
          "",
          !isSelectedValue ? /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => this.controller.toggleSelect(parentValue),
              children: parentValue.value
            }
          ) : /* @__PURE__ */ jsx("span", { children: parentValue.value })
        ] }, this.getUniqueKeyForValue(parentValue));
      })
    ] });
  }
  renderActiveValues() {
    return /* @__PURE__ */ jsx("ul", { children: this.state.selectedValueAncestry.map((value) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("button", { onClick: () => this.controller.toggleSelect(value), children: [
      value.value,
      " (",
      value.numberOfResults,
      " ",
      value.numberOfResults === 1 ? "result" : "results",
      ")"
    ] }) }, this.getUniqueKeyForValue(value))) });
  }
  renderCanShowMoreLess() {
    return /* @__PURE__ */ jsxs("div", { children: [
      this.state.canShowLessValues && /* @__PURE__ */ jsx("button", { onClick: () => this.controller.showLessValues(), children: "Show less" }),
      this.state.canShowMoreValues && /* @__PURE__ */ jsx("button", { onClick: () => this.controller.showMoreValues(), children: "Show more" })
    ] });
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.hasActiveValues && this.state.selectedValueAncestry.length === 0) {
      return /* @__PURE__ */ jsx("div", { children: "No facet values" });
    }
    return /* @__PURE__ */ jsxs("ul", { children: [
      /* @__PURE__ */ jsx("li", { children: this.renderSearch() }),
      /* @__PURE__ */ jsxs("li", { children: [
        this.renderParents(),
        this.renderActiveValues(),
        this.renderCanShowMoreLess()
      ] })
    ] });
  }
};
const CategoryFacet2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function getUniqueKeyForValue(value) {
    return value.path.join(">");
  }
  function renderSearch() {
    return /* @__PURE__ */ jsx(
      CategoryFacetSearch,
      {
        controller: controller.facetSearch,
        searchState: state.facetSearch
      }
    );
  }
  function renderClearButton() {
    return /* @__PURE__ */ jsx("button", { onClick: () => controller.deselectAll(), children: "All categories" });
  }
  function renderParents() {
    return state.hasActiveValues && /* @__PURE__ */ jsxs("div", { children: [
      "Filtering by: ",
      renderClearButton(),
      state.valuesAsTrees.map((parentValue, i) => {
        const isSelectedValue = i === state.valuesAsTrees.length - 1;
        return /* @__PURE__ */ jsxs("span", { children: [
          "",
          !isSelectedValue ? /* @__PURE__ */ jsx("button", { onClick: () => controller.toggleSelect(parentValue), children: parentValue.value }) : /* @__PURE__ */ jsx("span", { children: parentValue.value })
        ] }, getUniqueKeyForValue(parentValue));
      })
    ] });
  }
  function renderActiveValues() {
    return /* @__PURE__ */ jsx("ul", { children: state.selectedValueAncestry.map((value) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("button", { onClick: () => controller.toggleSelect(value), children: [
      value.value,
      " (",
      value.numberOfResults,
      " ",
      value.numberOfResults === 1 ? "result" : "results",
      ")"
    ] }) }, getUniqueKeyForValue(value))) });
  }
  function renderCanShowMoreLess() {
    return /* @__PURE__ */ jsxs("div", { children: [
      state.canShowLessValues && /* @__PURE__ */ jsx("button", { onClick: () => controller.showLessValues(), children: "Show less" }),
      state.canShowMoreValues && /* @__PURE__ */ jsx("button", { onClick: () => controller.showMoreValues(), children: "Show more" })
    ] });
  }
  if (!state.hasActiveValues && state.selectedValueAncestry.length === 0) {
    return /* @__PURE__ */ jsx("div", { children: "No facet values" });
  }
  return /* @__PURE__ */ jsxs("ul", { children: [
    /* @__PURE__ */ jsx("li", { children: renderSearch() }),
    /* @__PURE__ */ jsxs("li", { children: [
      renderParents(),
      renderActiveValues(),
      renderCanShowMoreLess()
    ] })
  ] });
};
function Context() {
  const { engine } = useContext(AppContext);
  const ctx = buildContext(engine);
  ctx.set({ ageGroup: "30-45", interests: ["sports", "camping", "electronics"] });
  return null;
}
dayjs.extend(customParseFormat);
const dateRanges = [
  buildDateRange({
    start: new Date(1970, 1),
    end: new Date(1990, 1)
  }),
  buildDateRange({
    start: new Date(1990, 1),
    end: new Date(2005, 1)
  }),
  buildDateRange({
    start: new Date(2005, 1),
    end: new Date(2010, 1)
  }),
  buildDateRange({
    start: new Date(2010, 1),
    end: new Date(2015, 1)
  }),
  buildDateRange({
    start: new Date(2015, 1),
    end: new Date(2018, 1)
  }),
  buildDateRange({
    start: new Date(2018, 1),
    end: new Date(2020, 1)
  }),
  buildDateRange({
    start: new Date(2020, 1),
    end: new Date(2021, 1)
  })
];
function parseDate(date) {
  return dayjs(date, API_DATE_FORMAT);
}
let DateFacet$1 = class DateFacet extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildDateFacet(this.context.engine, {
      options: this.props
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  getKeyForRange(value) {
    return `[${value.start}..${value.end}]`;
  }
  format(dateStr) {
    return parseDate(dateStr).format("MMMM D YYYY");
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.values.filter(
      (value) => value.state !== "idle" || value.numberOfResults > 0
    ).length) {
      return /* @__PURE__ */ jsx("div", { children: "No facet values" });
    }
    return /* @__PURE__ */ jsx("ul", { children: this.state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: this.controller.isValueSelected(value),
          onChange: () => this.controller.toggleSelect(value),
          disabled: this.state.isLoading
        }
      ),
      this.format(value.start),
      " to ",
      this.format(value.end),
      " (",
      value.numberOfResults,
      " ",
      value.numberOfResults === 1 ? "result" : "results",
      ")"
    ] }, this.getKeyForRange(value))) });
  }
};
const DateFacet2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function getKeyForRange(value) {
    return `[${value.start}..${value.end}]`;
  }
  function format(dateStr) {
    return parseDate(dateStr).format("MMMM D YYYY");
  }
  if (!state.values.filter(
    (value) => value.state !== "idle" || value.numberOfResults > 0
  ).length) {
    return /* @__PURE__ */ jsx("div", { children: "No facet values" });
  }
  return /* @__PURE__ */ jsx("ul", { children: state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        checked: controller.isValueSelected(value),
        onChange: () => controller.toggleSelect(value),
        disabled: state.isLoading
      }
    ),
    format(value.start),
    " to ",
    format(value.end),
    " (",
    value.numberOfResults,
    " ",
    value.numberOfResults === 1 ? "result" : "results",
    ")"
  ] }, getKeyForRange(value))) });
};
let DateFilter$1 = class DateFilter extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  startRef;
  endRef;
  componentDidMount() {
    this.controller = buildDateFilter(this.context.engine, {
      options: {
        field: this.props.field,
        facetId: this.props.facetId
      }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  formattedDateValue(date) {
    if (!date) {
      return "";
    }
    return parseDate(date).format("YYYY-MM-DD");
  }
  apply() {
    if (!this.startRef.validity.valid || !this.endRef.validity.valid) {
      return;
    }
    this.controller.setRange(
      buildDateRange({
        start: this.startRef.valueAsDate,
        end: this.endRef.valueAsDate
      })
    );
  }
  render() {
    if (!this.state) {
      return null;
    }
    const { range } = this.state;
    return [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "date",
          ref: (ref) => {
            this.startRef = ref;
          },
          defaultValue: this.formattedDateValue(range?.start),
          placeholder: "Start"
        },
        "start"
      ),
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "date",
          ref: (ref) => {
            this.endRef = ref;
          },
          defaultValue: this.formattedDateValue(range?.end),
          placeholder: "End"
        },
        "end"
      ),
      /* @__PURE__ */ jsx("button", { onClick: () => this.apply(), children: "Apply" }, "apply")
    ];
  }
};
function formattedDateValue(date) {
  if (!date) {
    return "";
  }
  return parseDate(date).format("YYYY-MM-DD");
}
const DateFilter2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  let startRef;
  let endRef;
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const { range } = state;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "Date",
        ref: (ref) => {
          startRef = ref;
        },
        defaultValue: formattedDateValue(range?.start),
        placeholder: "Start"
      },
      "start"
    ),
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "Date",
        ref: (ref) => {
          endRef = ref;
        },
        defaultValue: formattedDateValue(range?.end),
        placeholder: "End"
      },
      "end"
    ),
    /* @__PURE__ */ jsx(
      "button",
      {
        onClick: () => {
          if (!startRef.validity.valid || !endRef.validity.valid) {
            return;
          }
          controller.setRange(
            buildDateRange({
              start: startRef.valueAsDate,
              end: endRef.valueAsDate
            })
          );
        },
        children: "Apply"
      },
      "apply"
    )
  ] });
};
function DictionaryFieldContext() {
  const { engine } = useContext(AppContext);
  const ctx = buildDictionaryFieldContext(engine);
  ctx.set({ price_currency: "fr", price_discounted: "fr" });
  return null;
}
let DidYouMean$1 = class DidYouMean extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildDidYouMean$1(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state?.hasQueryCorrection) {
      return null;
    }
    if (this.state.wasAutomaticallyCorrected) {
      return /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsxs("p", { children: [
          "No results for",
          " ",
          /* @__PURE__ */ jsx("b", { children: this.state.queryCorrection.wordCorrections[0].originalWord })
        ] }),
        /* @__PURE__ */ jsxs("p", { children: [
          "Query was automatically corrected to",
          " ",
          /* @__PURE__ */ jsx("b", { children: this.state.wasCorrectedTo })
        ] })
      ] });
    }
    return /* @__PURE__ */ jsxs("button", { onClick: () => this.controller.applyCorrection(), children: [
      "Did you mean: ",
      this.state.queryCorrection.correctedQuery,
      " ?"
    ] });
  }
};
const DidYouMean2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.hasQueryCorrection) {
    return null;
  }
  if (state.wasAutomaticallyCorrected) {
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsxs("p", { children: [
        "No results for",
        " ",
        /* @__PURE__ */ jsx("b", { children: state.queryCorrection.wordCorrections[0].originalWord })
      ] }),
      /* @__PURE__ */ jsxs("p", { children: [
        "Query was automatically corrected to ",
        /* @__PURE__ */ jsx("b", { children: state.wasCorrectedTo })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxs("button", { onClick: () => controller.applyCorrection(), children: [
    "Did you mean: ",
    state.queryCorrection.correctedQuery,
    " ?"
  ] });
};
class Facet extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildFacet(this.context.engine, {
      options: this.props
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.values.length) {
      return /* @__PURE__ */ jsx("div", { children: "No facet values" });
    }
    return /* @__PURE__ */ jsxs("ul", { children: [
      /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
        FacetSearch,
        {
          controller: this.controller.facetSearch,
          facetState: this.state.facetSearch,
          isValueSelected: (facetSearchValue) => !!this.state.values.find(
            (facetValue) => facetValue.value === facetSearchValue.displayValue && this.controller.isValueSelected(facetValue)
          )
        }
      ) }),
      /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("ul", { children: this.state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
        /* @__PURE__ */ jsx(
          "input",
          {
            type: "checkbox",
            checked: this.controller.isValueSelected(value),
            onChange: () => this.controller.toggleSelect(value),
            disabled: this.state.isLoading
          }
        ),
        value.value,
        " (",
        value.numberOfResults,
        " results)"
      ] }, value.value)) }) })
    ] });
  }
}
let FacetManager$1 = class FacetManager extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildFacetManager(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  createPayload(facets) {
    return facets.map((facet) => ({
      facetId: facet.props.facetId,
      payload: facet
    }));
  }
  render() {
    if (!this.state) {
      return /* @__PURE__ */ jsx(Fragment, { children: this.props.children });
    }
    const childFacets = Children.toArray(
      this.props.children
    );
    const payload = this.createPayload(childFacets);
    const sortedFacets = this.controller.sort(payload).map((p) => p.payload);
    return /* @__PURE__ */ jsx(Fragment, { children: sortedFacets });
  }
};
const FacetManager2 = (props) => {
  const { controller } = props;
  const [, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function createPayload(facets) {
    return facets.map((facet) => ({
      facetId: facet.props.controller.state.facetId,
      payload: facet
    }));
  }
  const childFacets = Children.toArray(props.children);
  const payload = createPayload(childFacets);
  const sortedFacets = controller.sort(payload).map((p) => p.payload);
  return /* @__PURE__ */ jsx("div", { children: sortedFacets });
};
let CategoryFieldSuggestions$1 = class CategoryFieldSuggestions extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildCategoryFieldSuggestions(this.context.engine, {
      options: { facet: this.props }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  onInput(text) {
    if (text === "") {
      this.controller.clear();
      return;
    }
    this.controller.updateText(text);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("input", { onInput: (e) => this.onInput(e.currentTarget.value) }),
      /* @__PURE__ */ jsx("ul", { children: this.state.values.map((facetSearchValue) => /* @__PURE__ */ jsxs(
        "li",
        {
          onClick: () => this.controller.select(facetSearchValue),
          onKeyDown: (e) => {
            if (e.key === "Enter" || e.key === " ") {
              this.controller.select(facetSearchValue);
            }
          },
          children: [
            [...facetSearchValue.path, facetSearchValue.displayValue].join(
              " > "
            ),
            " ",
            "(",
            facetSearchValue.count,
            " results)"
          ]
        },
        [...facetSearchValue.path, facetSearchValue.rawValue].join(
          ">"
        )
      )) })
    ] });
  }
};
const CategoryFieldSuggestions2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const onInput = (text) => {
    if (text === "") {
      controller.clear();
      return;
    }
    controller.updateText(text);
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("input", { onInput: (e) => onInput(e.currentTarget.value) }),
    /* @__PURE__ */ jsx("ul", { children: state.values.map((facetSearchValue) => /* @__PURE__ */ jsxs(
      "li",
      {
        onClick: () => controller.select(facetSearchValue),
        onKeyDown: (e) => {
          if (e.key === "Enter" || e.key === " ") {
            controller.select(facetSearchValue);
          }
        },
        children: [
          [...facetSearchValue.path, facetSearchValue.displayValue].join(
            " > "
          ),
          " ",
          "(",
          facetSearchValue.count,
          " results)"
        ]
      },
      [...facetSearchValue.path, facetSearchValue.rawValue].join(
        ">"
      )
    )) })
  ] });
};
let FieldSuggestions$1 = class FieldSuggestions extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildFieldSuggestions(this.context.engine, {
      options: { facet: this.props }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  onInput(text) {
    if (text === "") {
      this.controller.clear();
      return;
    }
    this.controller.updateText(text);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("input", { onInput: (e) => this.onInput(e.currentTarget.value) }),
      /* @__PURE__ */ jsx("ul", { children: this.state.values.map((facetSearchValue) => /* @__PURE__ */ jsxs(
        "li",
        {
          onClick: () => this.controller.select(facetSearchValue),
          onKeyUp: (e) => {
            if (e.key === "Enter" || e.key === " ") {
              this.controller.select(facetSearchValue);
            }
          },
          children: [
            facetSearchValue.displayValue,
            " (",
            facetSearchValue.count,
            " results)"
          ]
        },
        facetSearchValue.rawValue
      )) })
    ] });
  }
};
const FieldSuggestions2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const onInput = (text) => {
    if (text === "") {
      controller.clear();
      return;
    }
    controller.updateText(text);
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("input", { onInput: (e) => onInput(e.currentTarget.value) }),
    /* @__PURE__ */ jsx("ul", { children: state.values.map((facetSearchValue) => /* @__PURE__ */ jsxs(
      "li",
      {
        onClick: () => controller.select(facetSearchValue),
        onKeyUp: (e) => {
          if (e.key === "Enter" || e.key === " ") {
            controller.select(facetSearchValue);
          }
        },
        children: [
          facetSearchValue.displayValue,
          " (",
          facetSearchValue.count,
          " results)"
        ]
      },
      facetSearchValue.rawValue
    )) })
  ] });
};
const ResultLink = (props) => {
  const { engine } = useContext(AppContext);
  const interactiveResult = buildInteractiveResult(engine, {
    options: { result: props.result }
  });
  useEffect(() => () => interactiveResult.cancelPendingSelect(), []);
  return /* @__PURE__ */ jsx(
    "a",
    {
      href: filterProtocol(props.result.clickUri),
      onClick: () => interactiveResult.select(),
      onContextMenu: () => interactiveResult.select(),
      onMouseDown: () => interactiveResult.select(),
      onMouseUp: () => interactiveResult.select(),
      onTouchStart: () => interactiveResult.beginDelayedSelect(),
      onTouchEnd: () => interactiveResult.cancelPendingSelect(),
      children: props.children
    }
  );
};
let FoldedResultList$1 = class FoldedResultList extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildFoldedResultList(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  renderFoldedResults(results) {
    return results.map(({ result, children }) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
      /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(ResultLink, { result, children: result.title }) }),
      /* @__PURE__ */ jsx("p", { children: result.excerpt }),
      /* @__PURE__ */ jsx("ul", { children: this.renderFoldedResults(children) })
    ] }) }, result.uniqueId));
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.results.length) {
      return /* @__PURE__ */ jsx("div", { children: "No results" });
    }
    return /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx("ul", { style: { textAlign: "left" }, children: this.state.results.map((collection) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
      /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(ResultLink, { result: collection.result, children: collection.result.title }) }),
      /* @__PURE__ */ jsx("p", { children: collection.result.excerpt }),
      /* @__PURE__ */ jsx("ul", { children: this.renderFoldedResults(collection.children) }),
      collection.moreResultsAvailable && /* @__PURE__ */ jsx(
        "button",
        {
          disabled: collection.isLoadingMoreResults,
          onClick: () => this.controller.loadCollection(collection),
          children: "Show more"
        }
      )
    ] }) }, collection.result.uniqueId)) }) });
  }
};
const FoldedResultList2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function renderFoldedResults(results) {
    return results.map(({ result, children }) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
      /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(ResultLink, { result, children: result.title }) }),
      /* @__PURE__ */ jsx("p", { children: result.excerpt }),
      /* @__PURE__ */ jsx("ul", { children: renderFoldedResults(children) })
    ] }) }, result.uniqueId));
  }
  if (!state.results.length) {
    return /* @__PURE__ */ jsx("div", { children: "No results" });
  }
  return /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx("ul", { style: { textAlign: "left" }, children: state.results.map((collection) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
    /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(ResultLink, { result: collection.result, children: collection.result.title }) }),
    /* @__PURE__ */ jsx("p", { children: collection.result.excerpt }),
    /* @__PURE__ */ jsx("ul", { children: renderFoldedResults(collection.children) }),
    collection.moreResultsAvailable && /* @__PURE__ */ jsx(
      "button",
      {
        disabled: collection.isLoadingMoreResults,
        onClick: () => controller.loadCollection(collection),
        children: "Show more"
      }
    )
  ] }) }, collection.result.uniqueId)) }) });
};
let HistoryManager$1 = class HistoryManager extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildHistoryManager(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx(
        "button",
        {
          disabled: this.state.past.length === 0,
          onClick: () => this.controller.back(),
          children: "Back"
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          disabled: this.state.future.length === 0,
          onClick: () => this.controller.forward(),
          children: "Forward"
        }
      )
    ] });
  }
};
const HistoryManager2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx(
      "button",
      {
        disabled: state.past.length === 0,
        onClick: () => controller.back(),
        children: "Back"
      }
    ),
    /* @__PURE__ */ jsx(
      "button",
      {
        disabled: state.future.length === 0,
        onClick: () => controller.forward(),
        children: "Forward"
      }
    )
  ] });
};
let InstantResults$1 = class InstantResults extends Component {
  static contextType = AppContext;
  context;
  controllerInstantResults;
  controllerSearchbox;
  unsubscribe = () => {
  };
  componentDidMount() {
    const sharedIdBetweenSearchboxAndInstantResult = "sample-instant-results";
    this.controllerSearchbox = buildSearchBox(this.context.engine, {
      options: { id: sharedIdBetweenSearchboxAndInstantResult }
    });
    this.controllerInstantResults = buildInstantResults(this.context.engine, {
      options: {
        maxResultsPerQuery: 5,
        searchBoxId: sharedIdBetweenSearchboxAndInstantResult
      }
    });
    this.updateState();
    const unsubInstantResults = this.controllerInstantResults.subscribe(
      () => this.updateState()
    );
    const unsubSearchbox = this.controllerSearchbox.subscribe(() => {
      this.updateState();
    });
    this.unsubscribe = () => {
      unsubInstantResults();
      unsubSearchbox();
    };
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState({
      instantResults: this.controllerInstantResults.state,
      searchbox: this.controllerSearchbox.state
    });
  }
  isEnterKey(e) {
    return e.key === "Enter";
  }
  render() {
    if (!this.state) {
      return;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("p", { children: "Type in the searchbox and hover a query suggestion to preview associated results" }),
      /* @__PURE__ */ jsx(
        "input",
        {
          value: this.state.searchbox.value,
          onChange: (e) => this.controllerSearchbox.updateText(e.target.value),
          onKeyDown: (e) => this.isEnterKey(e) && this.controllerSearchbox.submit()
        }
      ),
      /* @__PURE__ */ jsxs("div", { style: { display: "flex" }, children: [
        /* @__PURE__ */ jsx("ul", { children: this.state.searchbox.suggestions.map((suggestion) => {
          const value = suggestion.rawValue;
          return /* @__PURE__ */ jsx(
            "li",
            {
              onMouseEnter: () => this.controllerInstantResults.updateQuery(value),
              onClick: () => this.controllerSearchbox.selectSuggestion(value),
              onKeyDown: (e) => {
                if (e.key === "Enter" || e.key === " ") {
                  this.controllerSearchbox.selectSuggestion(value);
                }
              },
              children: value
            },
            value
          );
        }) }),
        /* @__PURE__ */ jsx("ul", { children: this.state.instantResults.results.map((result) => {
          return /* @__PURE__ */ jsxs("li", { children: [
            /* @__PURE__ */ jsxs("div", { children: [
              result.title,
              ": ",
              result.raw.source
            ] }),
            /* @__PURE__ */ jsx("pre", { children: result.excerpt })
          ] }, result.uniqueId);
        }) })
      ] })
    ] });
  }
};
const InstantResults2 = (props) => {
  const { controllerSearchbox, controllerInstantResults } = props;
  const isEnterKey = (e) => e.key === "Enter";
  const [searchboxState, setStateSearchbox] = useState(
    controllerSearchbox.state
  );
  const [instantResultsState, setStateInstantResults] = useState(
    controllerInstantResults.state
  );
  useEffect(
    () => controllerSearchbox.subscribe(
      () => setStateSearchbox(controllerSearchbox.state)
    ),
    []
  );
  useEffect(
    () => controllerInstantResults.subscribe(
      () => setStateInstantResults(controllerInstantResults.state)
    ),
    []
  );
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx("p", { children: "Type in the searchbox and hover a query suggestion to preview associated results" }),
    /* @__PURE__ */ jsx(
      "input",
      {
        value: searchboxState.value,
        onChange: (e) => controllerSearchbox.updateText(e.target.value),
        onKeyDown: (e) => isEnterKey(e) && controllerSearchbox.submit()
      }
    ),
    /* @__PURE__ */ jsxs("div", { style: { display: "flex" }, children: [
      /* @__PURE__ */ jsx("ul", { children: searchboxState.suggestions.map((suggestion) => {
        const value = suggestion.rawValue;
        return /* @__PURE__ */ jsx(
          "li",
          {
            onMouseEnter: () => controllerInstantResults.updateQuery(value),
            onClick: () => controllerSearchbox.selectSuggestion(value),
            onKeyDown: (e) => {
              if (e.key === "Enter" || e.key === " ") {
                controllerSearchbox.selectSuggestion(value);
              }
            },
            children: value
          },
          value
        );
      }) }),
      /* @__PURE__ */ jsx("ul", { children: instantResultsState.results.map((result) => {
        return /* @__PURE__ */ jsxs("li", { children: [
          /* @__PURE__ */ jsxs("div", { children: [
            result.title,
            ": ",
            result.raw.source
          ] }),
          /* @__PURE__ */ jsx("pre", { children: result.excerpt })
        ] }, result.uniqueId);
      }) })
    ] })
  ] });
};
let NumericFacet$1 = class NumericFacet extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildNumericFacet(this.context.engine, {
      options: {
        field: this.props.field,
        facetId: this.props.facetId,
        generateAutomaticRanges: this.props.generateAutomaticRanges,
        ...this.props.currentValues && {
          currentValues: this.props.currentValues
        }
      }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  getKeyForRange(value) {
    return `[${value.start}..${value.end}${value.endInclusive ? "]" : "["}`;
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.values.filter(
      (value) => value.state !== "idle" || value.numberOfResults > 0
    ).length) {
      return /* @__PURE__ */ jsx("div", { children: "No facet values" });
    }
    const { format } = this.props;
    return /* @__PURE__ */ jsx("ul", { children: this.state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: this.controller.isValueSelected(value),
          onChange: () => this.controller.toggleSelect(value),
          disabled: this.state.isLoading
        }
      ),
      format(value.start),
      " to ",
      format(value.end),
      " ",
      value.endInclusive ? "inclusively" : "exclusively",
      " (",
      value.numberOfResults,
      " ",
      value.numberOfResults === 1 ? "result" : "results",
      ")"
    ] }, this.getKeyForRange(value))) });
  }
};
const NumericFacet2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function getKeyForRange(value) {
    return `[${value.start}..${value.end}${value.endInclusive ? "]" : "["}`;
  }
  if (!state.values.filter(
    (value) => value.state !== "idle" || value.numberOfResults > 0
  ).length) {
    return /* @__PURE__ */ jsx("div", { children: "No facet values" });
  }
  const { format } = props;
  return /* @__PURE__ */ jsx("ul", { children: state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        checked: controller.isValueSelected(value),
        onChange: () => controller.toggleSelect(value),
        disabled: state.isLoading
      }
    ),
    format(value.start),
    " to ",
    format(value.end),
    " ",
    value.endInclusive ? "inclusively" : "exclusively",
    " (",
    value.numberOfResults,
    " ",
    value.numberOfResults === 1 ? "result" : "results",
    ")"
  ] }, getKeyForRange(value))) });
};
let NumericFilter$1 = class NumericFilter extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  startRef;
  endRef;
  componentDidMount() {
    this.controller = buildNumericFilter(this.context.engine, {
      options: {
        field: this.props.field,
        facetId: this.props.facetId
      }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    const { range } = this.state;
    return [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "number",
          ref: (ref) => {
            this.startRef = ref;
          },
          defaultValue: range?.start,
          placeholder: "Start"
        },
        "start"
      ),
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "number",
          ref: (ref) => {
            this.endRef = ref;
          },
          defaultValue: range?.end,
          placeholder: "End"
        },
        "end"
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          onClick: () => this.controller.setRange({
            start: this.startRef.valueAsNumber,
            end: this.endRef.valueAsNumber
          }),
          children: "Apply"
        },
        "apply"
      )
    ];
  }
};
const NumericFilter2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  let startRef;
  let endRef;
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const { range } = state;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "number",
        ref: (ref) => {
          startRef = ref;
        },
        defaultValue: range?.start,
        placeholder: "Start"
      },
      "start"
    ),
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "number",
        ref: (ref) => {
          endRef = ref;
        },
        defaultValue: range?.end,
        placeholder: "End"
      },
      "end"
    ),
    /* @__PURE__ */ jsx(
      "button",
      {
        onClick: () => controller.setRange({
          start: startRef.valueAsNumber,
          end: endRef.valueAsNumber
        }),
        children: "Apply"
      },
      "apply"
    )
  ] });
};
let Pager$1 = class Pager extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildPager(this.context.engine, {
      options: { numberOfPages: 6 }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("nav", { children: [
      /* @__PURE__ */ jsx(
        "button",
        {
          disabled: !this.state.hasPreviousPage,
          onClick: () => this.controller.previousPage(),
          children: "<"
        }
      ),
      this.state.currentPages.map((page) => /* @__PURE__ */ jsx(
        "button",
        {
          disabled: this.controller.isCurrentPage(page),
          onClick: () => this.controller.selectPage(page),
          children: page
        },
        page
      )),
      /* @__PURE__ */ jsx(
        "button",
        {
          disabled: !this.state.hasNextPage,
          onClick: () => this.controller.nextPage(),
          children: ">"
        }
      )
    ] });
  }
};
const Pager2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsxs("nav", { children: [
    /* @__PURE__ */ jsx(
      "button",
      {
        disabled: !state.hasPreviousPage,
        onClick: () => controller.previousPage(),
        children: "<"
      }
    ),
    state.currentPages.map((page) => /* @__PURE__ */ jsx(
      "button",
      {
        disabled: controller.isCurrentPage(page),
        onClick: () => controller.selectPage(page),
        children: page
      },
      page
    )),
    /* @__PURE__ */ jsx(
      "button",
      {
        disabled: !state.hasNextPage,
        onClick: () => controller.nextPage(),
        children: ">"
      }
    )
  ] });
};
let QueryError$1 = class QueryError extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildQueryError(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state?.hasError) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsxs("div", { children: [
        "Oops ",
        this.state.error.message
      ] }),
      /* @__PURE__ */ jsx("code", { children: JSON.stringify(this.state.error) })
    ] });
  }
};
const QueryError2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.hasError) {
    return null;
  }
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsxs("div", { children: [
      "Oops ",
      state.error.message
    ] }),
    /* @__PURE__ */ jsx("code", { children: JSON.stringify(state.error) })
  ] });
};
let QuerySummary$1 = class QuerySummary extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildQuerySummary(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    const {
      hasResults,
      hasQuery,
      hasDuration,
      firstResult,
      lastResult,
      total,
      query: query2,
      durationInSeconds
    } = this.state;
    if (!hasResults) {
      return null;
    }
    const summary = [`Results ${firstResult}-${lastResult} of ${total}`];
    if (hasQuery) {
      summary.push(`for ${query2}`);
    }
    if (hasDuration) {
      summary.push(`in ${durationInSeconds} seconds`);
    }
    return /* @__PURE__ */ jsx("p", { children: summary.join(" ") });
  }
};
const QuerySummary2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const {
    hasResults,
    hasQuery,
    hasDuration,
    firstResult,
    lastResult,
    total,
    query: query2,
    durationInSeconds
  } = state;
  if (!hasResults) {
    return null;
  }
  const summary = [`Results ${firstResult}-${lastResult} of ${total}`];
  if (hasQuery) {
    summary.push(`for ${query2}`);
  }
  if (hasDuration) {
    summary.push(`in ${durationInSeconds} seconds`);
  }
  return /* @__PURE__ */ jsx("p", { children: summary.join(" ") });
};
let RecentQueriesList$1 = class RecentQueriesList extends Component {
  static contextType = AppContext;
  context = void 0;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    const initialState2 = { queries: this.retrieveLocalStorage() };
    this.controller = buildRecentQueriesList(this.context.engine, {
      options: this.props,
      initialState: initialState2
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => {
      this.updateState();
      this.updateLocalStorage();
    });
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  retrieveLocalStorage() {
    const storedQueries = localStorage.getItem("recentQueries");
    return storedQueries ? JSON.parse(storedQueries) : [];
  }
  updateLocalStorage() {
    localStorage.setItem(
      "recentQueries",
      JSON.stringify(this.controller.state.queries)
    );
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      "Recent queries:",
      /* @__PURE__ */ jsx("ul", { children: this.state.queries.map((query2) => /* @__PURE__ */ jsx("li", { children: query2 }, query2)) })
    ] });
  }
};
const RecentQueriesList2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => {
    const storedQueries = retrieveLocalStorage();
    if (storedQueries.length) {
      controller.state.queries = storedQueries;
    }
    const unsubscribe = controller.subscribe(() => {
      setState(controller.state);
      updateLocalStorage();
    });
    return () => unsubscribe();
  }, [controller]);
  const retrieveLocalStorage = () => {
    const storedQueries = localStorage.getItem("recentQueries");
    return storedQueries ? JSON.parse(storedQueries) : [];
  };
  const updateLocalStorage = () => {
    localStorage.setItem(
      "recentQueries",
      JSON.stringify(controller.state.queries)
    );
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    "Recent queries:",
    /* @__PURE__ */ jsx("ul", { children: state.queries.map((query2) => /* @__PURE__ */ jsx("li", { children: query2 }, query2)) })
  ] });
};
let RecentResultsList$1 = class RecentResultsList extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildRecentResultsList(this.context.engine, {
      options: this.props
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      "Recent results:",
      /* @__PURE__ */ jsx("ul", { children: this.state.results.map((result) => /* @__PURE__ */ jsx("li", { children: result.title }, result.uniqueId)) })
    ] });
  }
};
const RecentResultsList2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsxs("div", { children: [
    "Recent results:",
    /* @__PURE__ */ jsx("ul", { children: state.results.map((result) => /* @__PURE__ */ jsx("li", { children: result.title }, result.uniqueId)) })
  ] });
};
let RelativeDateFacet$1 = class RelativeDateFacet extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildDateFacet(this.context.engine, {
      options: this.props
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  getKeyForRange(value) {
    return `[${value.start}..${value.end}]`;
  }
  format(value) {
    const relativeDate = deserializeRelativeDate(value);
    return relativeDate.period === "now" ? relativeDate.period : `${relativeDate.period} ${relativeDate.amount} ${relativeDate.unit}`;
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.values.filter(
      (value) => value.state !== "idle" || value.numberOfResults > 0
    ).length) {
      return /* @__PURE__ */ jsx("div", { children: "No facet values" });
    }
    return /* @__PURE__ */ jsx("ul", { children: this.state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: this.controller.isValueSelected(value),
          onChange: () => this.controller.toggleSelect(value),
          disabled: this.state.isLoading
        }
      ),
      this.format(value.start),
      " to ",
      this.format(value.end),
      " (",
      value.numberOfResults,
      " ",
      value.numberOfResults === 1 ? "result" : "results",
      ")"
    ] }, this.getKeyForRange(value))) });
  }
};
const RelativeDateFacet2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function getKeyForRange(value) {
    return `[${value.start}..${value.end}]`;
  }
  function format(value) {
    const relativeDate = deserializeRelativeDate(value);
    return relativeDate.period === "now" ? relativeDate.period : `${relativeDate.period} ${relativeDate.amount} ${relativeDate.unit}`;
  }
  if (!state.values.filter(
    (value) => value.state !== "idle" || value.numberOfResults > 0
  ).length) {
    return /* @__PURE__ */ jsx("div", { children: "No facet values" });
  }
  return /* @__PURE__ */ jsx("ul", { children: state.values.map((value) => /* @__PURE__ */ jsxs("li", { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "checkbox",
        checked: controller.isValueSelected(value),
        onChange: () => controller.toggleSingleSelect(value),
        disabled: state.isLoading
      }
    ),
    format(value.start),
    " to ",
    format(value.end),
    " (",
    value.numberOfResults,
    " ",
    value.numberOfResults === 1 ? "result" : "results",
    ")"
  ] }, getKeyForRange(value))) });
};
const relativeDateRanges = [
  buildDateRange({
    start: { period: "past", unit: "day", amount: 1 },
    end: { period: "now" }
  }),
  buildDateRange({
    start: { period: "past", unit: "week", amount: 1 },
    end: { period: "now" }
  }),
  buildDateRange({
    start: { period: "past", unit: "month", amount: 1 },
    end: { period: "now" }
  }),
  buildDateRange({
    start: { period: "past", unit: "quarter", amount: 1 },
    end: { period: "now" }
  }),
  buildDateRange({
    start: { period: "past", unit: "year", amount: 1 },
    end: { period: "now" }
  })
];
let RelevanceInspector$1 = class RelevanceInspector extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildRelevanceInspector(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  componentDidUpdate() {
    console.info("Debug information [class]", this.state);
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsxs("label", { children: [
        "Enable debug mode:",
        " ",
        /* @__PURE__ */ jsx(
          "input",
          {
            type: "checkbox",
            checked: this.state.isEnabled,
            onChange: () => this.state.isEnabled ? this.controller.disable() : this.controller.enable()
          }
        )
      ] }),
      /* @__PURE__ */ jsxs("label", { children: [
        "Enable fetch all fields:",
        " ",
        /* @__PURE__ */ jsx(
          "input",
          {
            type: "checkbox",
            checked: this.state.fetchAllFields,
            onChange: () => this.state.fetchAllFields ? this.controller.disableFetchAllFields() : this.controller.enableFetchAllFields()
          }
        )
      ] }),
      /* @__PURE__ */ jsxs("button", { onClick: () => this.controller.fetchFieldsDescription(), children: [
        " ",
        "Retrieve fields description"
      ] })
    ] });
  }
};
const RelevanceInspector2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(
    () => controller.subscribe(() => {
      console.info("Debug information [fn]", controller.state);
      setState(controller.state);
    }),
    []
  );
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsxs("label", { children: [
      "Enable debug mode:",
      " ",
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: state.isEnabled,
          onChange: () => state.isEnabled ? controller.disable() : controller.enable()
        }
      )
    ] }),
    /* @__PURE__ */ jsxs("label", { children: [
      "Enable fetch all fields:",
      " ",
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: state.fetchAllFields,
          onChange: () => state.fetchAllFields ? controller.disableFetchAllFields() : controller.enableFetchAllFields()
        }
      )
    ] }),
    /* @__PURE__ */ jsxs("button", { onClick: () => controller.fetchFieldsDescription(), children: [
      " ",
      "Retrieve fields description"
    ] })
  ] });
};
let Quickview$1 = class Quickview extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    const result = this.props.result;
    this.controller = buildQuickview(this.context.engine, {
      options: { result }
    });
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState({ quickview: this.controller.state });
  }
  openModal() {
    this.controller.fetchResultContent();
    this.setState({ isModalOpen: true });
  }
  closeModal() {
    this.setState({ isModalOpen: false });
  }
  render() {
    if (!this.state?.quickview.resultHasPreview) {
      return null;
    }
    if (this.state.isModalOpen) {
      return /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsx("button", { onClick: () => this.closeModal(), children: "X" }),
        /* @__PURE__ */ jsx(
          "iframe",
          {
            title: "Quickview",
            srcDoc: this.state.quickview.content
          }
        )
      ] });
    }
    return /* @__PURE__ */ jsx("button", { onClick: () => this.openModal(), children: "view" });
  }
};
let ResultList$1 = class ResultList extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildResultList(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (!this.state.results.length) {
      return /* @__PURE__ */ jsx("div", { children: "No results" });
    }
    return /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx("ul", { style: { textAlign: "left" }, children: this.state.results.map((result) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
      /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(ResultLink, { result, children: result.title }) }),
      /* @__PURE__ */ jsx("p", { children: result.excerpt }),
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(Quickview$1, { result }) })
    ] }) }, result.uniqueId)) }) });
  }
};
const Quickview2 = (props) => {
  const { result } = props;
  const { engine } = useContext(AppContext);
  const controller = buildQuickview(engine, { options: { result } });
  const [state, setState] = useState(controller.state);
  const [isModalOpen, toggleModal] = useState(false);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const openModal = () => {
    controller.fetchResultContent();
    toggleModal(true);
  };
  const closeModal = () => toggleModal(false);
  if (!state.resultHasPreview) {
    return null;
  }
  if (isModalOpen) {
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("button", { onClick: () => closeModal(), children: "X" }),
      /* @__PURE__ */ jsx("iframe", { title: "Quickview", srcDoc: state.content })
    ] });
  }
  return /* @__PURE__ */ jsx("button", { onClick: () => openModal(), children: "view" });
};
const ResultList2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  if (!state.results.length) {
    return /* @__PURE__ */ jsx("div", { children: "No results" });
  }
  return /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx("ul", { style: { textAlign: "left" }, children: state.results.map((result) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs("article", { children: [
    /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(ResultLink, { result, children: result.title }) }),
    /* @__PURE__ */ jsx("p", { children: result.excerpt }),
    /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(Quickview2, { result }) })
  ] }) }, result.uniqueId)) }) });
};
let ResultsPerPage$1 = class ResultsPerPage extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildResultsPerPage(this.context.engine, {
      initialState: { numberOfResults: this.props.options[0] }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsx("ul", { children: this.props.options.map((numberOfResults) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
      "button",
      {
        disabled: this.controller.isSetTo(numberOfResults),
        onClick: () => this.controller.set(numberOfResults),
        children: numberOfResults
      }
    ) }, numberOfResults)) });
  }
};
const ResultsPerPage2 = (props) => {
  const { controller, options: options2 } = props;
  const [, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsx("ul", { children: options2.map((numberOfResults) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
    "button",
    {
      disabled: controller.isSetTo(numberOfResults),
      onClick: () => controller.set(numberOfResults),
      children: numberOfResults
    }
  ) }, numberOfResults)) });
};
class SearchBox extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildSearchBox(this.context.engine, {
      options: { numberOfSuggestions: 8 }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  isEnterKey(e) {
    return e.key === "Enter";
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          value: this.state.value,
          onChange: (e) => this.controller.updateText(e.target.value),
          onKeyDown: (e) => this.isEnterKey(e) && this.controller.submit()
        }
      ),
      /* @__PURE__ */ jsx("ul", { children: this.state.suggestions.map((suggestion) => {
        const value = suggestion.rawValue;
        return /* @__PURE__ */ jsx(
          "li",
          {
            onClick: () => this.controller.selectSuggestion(value),
            onKeyDown: (e) => {
              if (e.key === "Enter" || e.key === " ") {
                this.controller.selectSuggestion(value);
              }
            },
            children: value
          },
          value
        );
      }) })
    ] });
  }
}
let SearchStatus$1 = class SearchStatus extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildSearchStatus(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    const { hasResults, firstSearchExecuted: firstSearchExecuted2, isLoading } = this.state;
    if (!hasResults && !firstSearchExecuted2 && isLoading) {
      return /* @__PURE__ */ jsx("p", { children: "The first search ever is currently loading." });
    }
    if (!hasResults && !firstSearchExecuted2 && !isLoading) {
      return /* @__PURE__ */ jsx("p", { children: "No search was ever executed." });
    }
    if (!hasResults && firstSearchExecuted2 && !isLoading) {
      return /* @__PURE__ */ jsx("p", { children: "A search was executed but gave no results." });
    }
    if (hasResults && isLoading) {
      return /* @__PURE__ */ jsx("p", { children: "The previous search gave results, but new ones are loading." });
    }
    if (hasResults && !isLoading) {
      return /* @__PURE__ */ jsx("p", { children: "There are results and no pending search." });
    }
    return null;
  }
};
const SearchStatus2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const { hasResults, firstSearchExecuted: firstSearchExecuted2, isLoading } = state;
  if (!hasResults && !firstSearchExecuted2 && isLoading) {
    return /* @__PURE__ */ jsx("p", { children: "The first search ever is currently loading." });
  }
  if (!hasResults && !firstSearchExecuted2 && !isLoading) {
    return /* @__PURE__ */ jsx("p", { children: "No search was ever executed." });
  }
  if (!hasResults && firstSearchExecuted2 && !isLoading) {
    return /* @__PURE__ */ jsx("p", { children: "A search was executed but gave no results." });
  }
  if (hasResults && isLoading) {
    return /* @__PURE__ */ jsx("p", { children: "The previous search gave results, but new ones are loading." });
  }
  if (hasResults && !isLoading) {
    return /* @__PURE__ */ jsx("p", { children: "There are results and no pending search." });
  }
  return null;
};
let SmartSnippet$1 = class SmartSnippet extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  detailedAnswerRef = createRef();
  componentDidMount() {
    this.controller = buildSmartSnippet(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  answerStyles(expanded) {
    const maskImage = () => expanded ? "none" : "linear-gradient(to bottom, black 50%, transparent 100%)";
    return {
      maxHeight: expanded ? "100%" : "100px",
      maxWidth: "200px",
      overflow: "hidden",
      marginBottom: "10px",
      maskImage: maskImage(),
      WebkitMaskImage: maskImage()
    };
  }
  renderSource() {
    const { source } = this.state;
    if (!source) {
      return;
    }
    return /* @__PURE__ */ jsx(
      "a",
      {
        href: filterProtocol(source.clickUri),
        onClick: () => this.controller.selectSource(),
        onContextMenu: () => this.controller.selectSource(),
        onMouseDown: () => this.controller.selectSource(),
        onMouseUp: () => this.controller.selectSource(),
        onTouchStart: () => this.controller.beginDelayedSelectSource(),
        onTouchEnd: () => this.controller.cancelPendingSelectSource(),
        children: "Source"
      }
    );
  }
  render() {
    if (!this.state) {
      return null;
    }
    const {
      answerFound,
      answer,
      question,
      liked,
      disliked,
      expanded,
      feedbackModalOpen
    } = this.state;
    if (!answerFound) {
      return /* @__PURE__ */ jsx("div", { children: "Sorry, no answer has been found for this query." });
    }
    if (feedbackModalOpen) {
      return /* @__PURE__ */ jsxs("div", { role: "dialog", children: [
        /* @__PURE__ */ jsx("h1", { children: "What's wrong with this snippet?" }),
        /* @__PURE__ */ jsxs("fieldset", { children: [
          /* @__PURE__ */ jsx("legend", { children: "Give a simple answer" }),
          /* @__PURE__ */ jsxs("ul", { children: [
            /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
              "button",
              {
                onClick: () => this.controller.sendFeedback("does_not_answer"),
                children: "It does not answer my question"
              }
            ) }),
            /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
              "button",
              {
                onClick: () => this.controller.sendFeedback("partially_answers"),
                children: "It only partially answers my question"
              }
            ) }),
            /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
              "button",
              {
                onClick: () => this.controller.sendFeedback("was_not_a_question"),
                children: "I was not asking a question"
              }
            ) })
          ] })
        ] }),
        "OR",
        /* @__PURE__ */ jsxs("fieldset", { children: [
          /* @__PURE__ */ jsx("legend", { children: "Give a detailed answer" }),
          /* @__PURE__ */ jsx("textarea", { ref: this.detailedAnswerRef }),
          /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => this.detailedAnswerRef.current && this.controller.sendDetailedFeedback(
                this.detailedAnswerRef.current.value
              ),
              children: "Send feedback"
            }
          )
        ] }),
        /* @__PURE__ */ jsx("button", { onClick: () => this.controller.closeFeedbackModal(), children: "Cancel" })
      ] });
    }
    return /* @__PURE__ */ jsx("div", { style: { textAlign: "left" }, children: /* @__PURE__ */ jsxs("dl", { children: [
      /* @__PURE__ */ jsx("dt", { children: question }),
      /* @__PURE__ */ jsxs("dd", { children: [
        /* @__PURE__ */ jsx(
          "div",
          {
            dangerouslySetInnerHTML: { __html: answer },
            style: this.answerStyles(expanded)
          }
        ),
        /* @__PURE__ */ jsx(
          "button",
          {
            style: { display: expanded ? "none" : "block" },
            onClick: () => this.controller.expand(),
            children: "Show complete answer"
          }
        ),
        /* @__PURE__ */ jsx(
          "button",
          {
            style: { display: expanded ? "block" : "none" },
            onClick: () => this.controller.collapse(),
            children: "Collapse answer"
          }
        ),
        /* @__PURE__ */ jsx(
          "button",
          {
            style: { fontWeight: liked ? "bold" : "normal" },
            onClick: () => this.controller.like(),
            children: "Thumbs up"
          }
        ),
        /* @__PURE__ */ jsx(
          "button",
          {
            style: { fontWeight: disliked ? "bold" : "normal" },
            onClick: () => this.controller.dislike(),
            children: "Thumbs down"
          }
        ),
        this.renderSource(),
        disliked ? /* @__PURE__ */ jsx("button", { onClick: () => this.controller.openFeedbackModal(), children: "Explain why" }) : []
      ] })
    ] }) });
  }
};
const SmartSnippet2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  const detailedAnswerRef = useRef(null);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const answerStyles = (expanded2) => {
    const maskImage = () => expanded2 ? "none" : "linear-gradient(to bottom, black 50%, transparent 100%)";
    return {
      maxHeight: expanded2 ? "100%" : "100px",
      maxWidth: "200px",
      overflow: "hidden",
      marginBottom: "10px",
      maskImage: maskImage(),
      WebkitMaskImage: maskImage()
    };
  };
  const {
    answerFound,
    answer,
    question,
    liked,
    disliked,
    expanded,
    source,
    feedbackModalOpen
  } = state;
  if (!answerFound) {
    return /* @__PURE__ */ jsx("div", { children: "Sorry, no answer has been found for this query." });
  }
  function renderSource() {
    if (!source) {
      return;
    }
    return /* @__PURE__ */ jsx(
      "a",
      {
        href: filterProtocol(source.clickUri),
        onClick: () => controller.selectSource(),
        onContextMenu: () => controller.selectSource(),
        onMouseDown: () => controller.selectSource(),
        onMouseUp: () => controller.selectSource(),
        onTouchStart: () => controller.beginDelayedSelectSource(),
        onTouchEnd: () => controller.cancelPendingSelectSource(),
        children: "Source"
      }
    );
  }
  if (feedbackModalOpen) {
    return /* @__PURE__ */ jsxs("div", { role: "dialog", children: [
      /* @__PURE__ */ jsx("h1", { children: "What's wrong with this snippet?" }),
      /* @__PURE__ */ jsxs("fieldset", { children: [
        /* @__PURE__ */ jsx("legend", { children: "Give a simple answer" }),
        /* @__PURE__ */ jsxs("ul", { children: [
          /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => controller.sendFeedback("does_not_answer"),
              children: "It does not answer my question"
            }
          ) }),
          /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => controller.sendFeedback("partially_answers"),
              children: "It only partially answers my question"
            }
          ) }),
          /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => controller.sendFeedback("was_not_a_question"),
              children: "I was not asking a question"
            }
          ) })
        ] })
      ] }),
      "OR",
      /* @__PURE__ */ jsxs("fieldset", { children: [
        /* @__PURE__ */ jsx("legend", { children: "Give a detailed answer" }),
        /* @__PURE__ */ jsx("textarea", { ref: detailedAnswerRef }),
        /* @__PURE__ */ jsx(
          "button",
          {
            onClick: () => detailedAnswerRef.current && controller.sendDetailedFeedback(detailedAnswerRef.current.value),
            children: "Send feedback"
          }
        )
      ] }),
      /* @__PURE__ */ jsx("button", { onClick: () => controller.closeFeedbackModal(), children: "Cancel" })
    ] });
  }
  return /* @__PURE__ */ jsx("div", { style: { textAlign: "left" }, children: /* @__PURE__ */ jsxs("dl", { children: [
    /* @__PURE__ */ jsx("dt", { children: question }),
    /* @__PURE__ */ jsxs("dd", { children: [
      /* @__PURE__ */ jsx(
        "div",
        {
          dangerouslySetInnerHTML: { __html: answer },
          style: answerStyles(expanded)
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: { display: expanded ? "none" : "block" },
          onClick: () => controller.expand(),
          children: "Show complete answer"
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: { display: expanded ? "block" : "none" },
          onClick: () => controller.collapse(),
          children: "Collapse answer"
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: { fontWeight: liked ? "bold" : "normal" },
          onClick: () => controller.like(),
          children: "Thumbs up"
        }
      ),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: { fontWeight: disliked ? "bold" : "normal" },
          onClick: () => controller.dislike(),
          children: "Thumbs down"
        }
      ),
      renderSource(),
      disliked ? /* @__PURE__ */ jsx("button", { onClick: () => controller.openFeedbackModal(), children: "Explain why" }) : []
    ] })
  ] }) });
};
let SmartSnippetQuestionsList$1 = class SmartSnippetQuestionsList extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildSmartSnippetQuestionsList(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    const { questions } = this.state;
    if (questions.length === 0) {
      return /* @__PURE__ */ jsx("div", { children: "Sorry, no related questions found" });
    }
    return /* @__PURE__ */ jsxs("div", { style: { textAlign: "left" }, children: [
      "People also ask:",
      /* @__PURE__ */ jsx("dl", { children: questions.map((question) => {
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx("dt", { children: question.question }),
          /* @__PURE__ */ jsxs("dd", { children: [
            /* @__PURE__ */ jsx(
              "div",
              {
                style: { display: question.expanded ? "block" : "none" },
                dangerouslySetInnerHTML: { __html: question.answer }
              }
            ),
            /* @__PURE__ */ jsx(
              "button",
              {
                style: { display: question.expanded ? "none" : "block" },
                onClick: () => this.controller.expand(question.questionAnswerId),
                children: "Show answer"
              }
            ),
            /* @__PURE__ */ jsx(
              "button",
              {
                style: { display: question.expanded ? "block" : "none" },
                onClick: () => this.controller.collapse(question.questionAnswerId),
                children: "Hide answer"
              }
            )
          ] })
        ] });
      }) })
    ] });
  }
};
const SmartSnippetQuestionsList2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const { questions } = state;
  if (questions.length === 0) {
    return /* @__PURE__ */ jsx("div", { children: "Sorry, no related questions found" });
  }
  return /* @__PURE__ */ jsxs("div", { style: { textAlign: "left" }, children: [
    "People also ask:",
    /* @__PURE__ */ jsx("dl", { children: questions.map((question) => {
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("dt", { children: question.question }),
        /* @__PURE__ */ jsxs("dd", { children: [
          /* @__PURE__ */ jsx(
            "div",
            {
              style: { display: question.expanded ? "block" : "none" },
              dangerouslySetInnerHTML: { __html: question.answer }
            }
          ),
          /* @__PURE__ */ jsx(
            "button",
            {
              style: { display: question.expanded ? "none" : "block" },
              onClick: () => controller.expand(question.questionAnswerId),
              children: "Show answer"
            }
          ),
          /* @__PURE__ */ jsx(
            "button",
            {
              style: { display: question.expanded ? "block" : "none" },
              onClick: () => controller.collapse(question.questionAnswerId),
              children: "Hide answer"
            }
          )
        ] })
      ] });
    }) })
  ] });
};
let Sort$1 = class Sort extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildSort(this.context.engine, {
      initialState: { criterion: this.props.initialCriterion }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  getCriterionFromName(name) {
    return this.props.criteria.find(
      ([criterionName]) => criterionName === name
    );
  }
  get currentCriterion() {
    return this.props.criteria.find(
      ([, criterion]) => this.state.sortCriteria === buildCriterionExpression$1(criterion)
    );
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsx(
      "select",
      {
        value: this.currentCriterion[0],
        onChange: (e) => this.controller.sortBy(this.getCriterionFromName(e.target.value)[1]),
        children: this.props.criteria.map(([criterionName]) => /* @__PURE__ */ jsx("option", { value: criterionName, children: criterionName }, criterionName))
      }
    );
  }
};
const Sort2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  const getCriterionFromName = (name) => props.criteria.find(([criterionName]) => criterionName === name);
  const getCurrentCriterion = () => props.criteria.find(
    ([, criterion]) => state.sortCriteria === buildCriterionExpression$1(criterion)
  );
  return /* @__PURE__ */ jsx(
    "select",
    {
      value: getCurrentCriterion()[0],
      onChange: (e) => controller.sortBy(getCriterionFromName(e.target.value)[1]),
      children: props.criteria.map(([criterionName]) => /* @__PURE__ */ jsx("option", { value: criterionName, children: criterionName }, criterionName))
    }
  );
};
const standaloneSearchBoxStorageKey = "coveo-standalone-search-box";
let StaticFilter$1 = class StaticFilter extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildStaticFilter(this.context.engine, {
      options: this.props
    });
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsx("ul", { children: this.state.values.map((value) => {
      return /* @__PURE__ */ jsxs("li", { children: [
        /* @__PURE__ */ jsx(
          "input",
          {
            type: "checkbox",
            checked: this.controller.isValueSelected(value),
            onChange: () => this.controller.toggleSelect(value)
          }
        ),
        /* @__PURE__ */ jsx("span", { children: value.caption })
      ] }, value.caption);
    }) });
  }
};
const StaticFilter2 = (props) => {
  const { engine } = useContext(AppContext);
  const controller = buildStaticFilter(engine, { options: props });
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsx("ul", { children: state.values.map((value) => {
    return /* @__PURE__ */ jsxs("li", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          type: "checkbox",
          checked: controller.isValueSelected(value),
          onChange: () => controller.toggleSelect(value)
        }
      ),
      /* @__PURE__ */ jsx("span", { children: value.caption })
    ] }, value.caption);
  }) });
};
let Tab$1 = class Tab extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildTab(this.context.engine, {
      initialState: { isActive: !!this.props.active },
      options: {
        expression: this.props.expression,
        id: this.props.id
      }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsx(
      "button",
      {
        disabled: this.state.isActive,
        onClick: () => this.controller.select(),
        children: this.props.children
      }
    );
  }
};
const Tab2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  return /* @__PURE__ */ jsx("button", { disabled: state.isActive, onClick: () => controller.select(), children: props.children });
};
function bindExecuteTrigger(engine) {
  const controller = buildExecuteTrigger(engine);
  const executeFunction = (execution) => {
    const { functionName, params } = execution;
    if (functionName === "log") {
      log(params);
    }
  };
  const log = (params) => {
    console.log("params: ", params);
  };
  const unsubscribe = controller.subscribe(
    () => controller.state.executions.forEach(
      (execution) => executeFunction(execution)
    )
  );
  return unsubscribe;
}
class ExecuteTrigger extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildExecuteTrigger(this.context.engine);
    this.unsubscribe = this.controller.subscribe(
      () => this.controller.state.executions.forEach(
        (execution) => this.executeFunction(execution)
      )
    );
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  executeFunction = (execution) => {
    const { functionName, params } = execution;
    if (functionName === "log") {
      this.log(params);
    }
  };
  log = (params) => {
    console.log("params: ", params);
  };
  render() {
    return null;
  }
}
let NotifyTrigger$1 = class NotifyTrigger extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildNotifyTrigger(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state, () => {
      this.state.notifications.forEach((notification) => {
        alert(`Notification: ${notification}`);
      });
    });
  }
  render() {
    return null;
  }
};
const NotifyTrigger2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => updateState()), []);
  useEffect(() => notify(), [state.notifications]);
  const updateState = () => {
    setState(props.controller.state);
  };
  const notify = () => {
    state.notifications.forEach((notification) => {
      alert(`Notification: ${notification}`);
    });
  };
  return null;
};
let QueryTrigger$1 = class QueryTrigger extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildQueryTrigger(this.context.engine);
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  updateState() {
    this.setState(this.controller.state);
  }
  render() {
    if (!this.state) {
      return null;
    }
    if (this.state.wasQueryModified) {
      return /* @__PURE__ */ jsxs("div", { children: [
        "The query changed from ",
        `${this.state.originalQuery} `,
        "to ",
        this.state.newQuery
      ] });
    }
    return null;
  }
};
const QueryTrigger2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => updateState()), []);
  const updateState = () => {
    setState(props.controller.state);
  };
  if (state.wasQueryModified) {
    return /* @__PURE__ */ jsxs("div", { children: [
      "The query changed from ",
      state.originalQuery,
      " to ",
      state.newQuery
    ] });
  }
  return null;
};
let RedirectionTrigger$1 = class RedirectionTrigger extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildRedirectionTrigger(this.context.engine);
    this.redirect();
    this.unsubscribe = this.controller.subscribe(() => this.redirect());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  redirect() {
    this.setState(this.controller.state, () => {
      if (!this.controller.state.redirectTo) {
        return;
      }
      window.location.replace(this.controller.state.redirectTo);
    });
  }
  render() {
    return null;
  }
};
const RedirectionTrigger2 = (props) => {
  const { controller } = props;
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => redirect()), []);
  useEffect(() => redirect(), [state.redirectTo]);
  const redirect = () => {
    setState(props.controller.state);
    if (state.redirectTo) {
      window.location.replace(controller.state.redirectTo);
    }
  };
  return null;
};
function bindUrlManager(engine) {
  const statusControllers = buildSearchStatus(engine);
  const fragment = () => window.location.hash.slice(1);
  const urlManager = buildUrlManager(engine, {
    initialState: { fragment: fragment() }
  });
  const onHashChange = () => {
    urlManager.synchronize(fragment());
  };
  window.addEventListener("hashchange", onHashChange);
  const unsubscribeManager = urlManager.subscribe(() => {
    const hash = `#${urlManager.state.fragment}`;
    if (!statusControllers.state.firstSearchExecuted) {
      history.replaceState(null, document.title, hash);
      return;
    }
    history.pushState(null, document.title, hash);
  });
  return () => {
    window.removeEventListener("hashchange", onHashChange);
    unsubscribeManager();
  };
}
const isServerSideRendered = globalThis.window?.HEADLESS_STATE;
const [KB, MB, GB] = [1e3, 1e6, 1e9];
function formatFileSize(bytes) {
  if (bytes === 0) return "0 B";
  const units = ["B", "kB", "MB", "GB", "TB", "PB"];
  const base = 1e3;
  const exponent = Math.floor(Math.log(Math.abs(bytes)) / Math.log(base));
  const value = bytes / base ** exponent;
  const unit = units[Math.min(exponent, units.length - 1)];
  const formatter = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: value >= 100 ? 0 : value >= 10 ? 1 : 2
  });
  return `${formatter.format(value)} ${unit}`;
}
const criteria = [
  ["Relevance", buildRelevanceSortCriterion$1()],
  ["Date (Ascending)", buildDateSortCriterion(SortOrder.Ascending)],
  ["Date (Descending)", buildDateSortCriterion(SortOrder.Descending)],
  ["Size (Ascending)", buildFieldSortCriterion("size", SortOrder.Ascending)],
  ["Size (Descending)", buildFieldSortCriterion("size", SortOrder.Descending)]
];
const initialCriterion = criteria[0][1];
const resultsPerPageOptions = [10, 25, 50, 100];
class SearchPage extends Component {
  engine;
  tabs;
  breadcrumbManager;
  searchBox;
  didYouMean;
  searchStatus;
  queryError;
  querySummary;
  resultList;
  foldedResultList;
  facetManager;
  geographyFacet;
  objectTypeFacet;
  fileSizeAutomaticNumericFacet;
  fileSizeManualNumericFacet;
  fileSizeNumericFilter;
  dateAutomaticDateFacet;
  dateManualDateFacet;
  dateRelativeDateFacet;
  dateFilter;
  sort;
  resultsPerPage;
  pager;
  historyManager;
  relevanceInspector;
  redirectionTrigger;
  queryTrigger;
  notifyTrigger;
  smartSnippet;
  smartSnippetQuestionsList;
  fieldSuggestionsAuthor;
  categoryFieldSuggestions;
  recentQueriesList;
  recentResultsList;
  instantResults;
  searchboxInstantResults;
  automaticFacetGenerator;
  unsubscribeUrlManager;
  unsubscribeExecuteTrigger;
  constructor(props) {
    super(props);
    this.initEngine(props);
    this.tabs = {
      all: buildTab(this.engine, {
        initialState: { isActive: true },
        options: {
          id: "all",
          expression: ""
        }
      }),
      messages: buildTab(this.engine, {
        options: {
          id: "messages",
          expression: this.messageExpression
        }
      }),
      confluence: buildTab(this.engine, {
        options: {
          id: "confluence",
          expression: this.confluenceExpression
        }
      })
    };
    this.breadcrumbManager = buildBreadcrumbManager(this.engine);
    this.searchBox = buildSearchBox(this.engine, {
      options: { numberOfSuggestions: 8 }
    });
    this.didYouMean = buildDidYouMean$1(this.engine);
    this.searchStatus = buildSearchStatus(this.engine);
    this.queryError = buildQueryError(this.engine);
    this.querySummary = buildQuerySummary(this.engine);
    this.facetManager = buildFacetManager(this.engine);
    this.automaticFacetGenerator = buildAutomaticFacetGenerator(this.engine, {
      options: {
        desiredCount: 5
      }
    });
    this.geographyFacet = buildCategoryFacet$1(this.engine, {
      options: {
        field: "geographicalhierarchy",
        facetId: "geographicalhierarchy-2"
      }
    });
    this.objectTypeFacet = buildFacet(this.engine, {
      options: { field: "objecttype", facetId: "objecttype-2" }
    });
    this.fileSizeAutomaticNumericFacet = buildNumericFacet(this.engine, {
      options: {
        field: "size",
        facetId: "size-3",
        generateAutomaticRanges: true
      }
    });
    this.fileSizeManualNumericFacet = buildNumericFacet(this.engine, {
      options: {
        field: "size",
        facetId: "size-4",
        generateAutomaticRanges: false,
        currentValues: [
          buildNumericRange({ start: 0, end: 5 * KB }),
          buildNumericRange({ start: 5 * KB, end: 5 * MB }),
          buildNumericRange({ start: 5 * MB, end: 5 * GB })
        ]
      }
    });
    this.fileSizeNumericFilter = buildNumericFilter(this.engine, {
      options: { field: "size", facetId: "size-6" }
    });
    this.dateAutomaticDateFacet = buildDateFacet(this.engine, {
      options: {
        field: "date",
        facetId: "date-3",
        generateAutomaticRanges: true
      }
    });
    this.dateManualDateFacet = buildDateFacet(this.engine, {
      options: {
        field: "date",
        facetId: "date-4",
        generateAutomaticRanges: false,
        currentValues: dateRanges
      }
    });
    this.dateRelativeDateFacet = buildDateFacet(this.engine, {
      options: {
        field: "date",
        facetId: "date-5",
        generateAutomaticRanges: false,
        currentValues: relativeDateRanges
      }
    });
    this.dateFilter = buildDateFilter(this.engine, {
      options: { field: "date", facetId: "date-7" }
    });
    this.sort = buildSort(this.engine, {
      initialState: { criterion: initialCriterion }
    });
    this.resultList = buildResultList(this.engine);
    this.foldedResultList = buildFoldedResultList(this.engine);
    this.resultsPerPage = buildResultsPerPage(this.engine, {
      initialState: { numberOfResults: resultsPerPageOptions[0] }
    });
    this.pager = buildPager(this.engine, { options: { numberOfPages: 6 } });
    this.historyManager = buildHistoryManager(this.engine);
    this.relevanceInspector = buildRelevanceInspector(this.engine);
    this.redirectionTrigger = buildRedirectionTrigger(this.engine);
    this.queryTrigger = buildQueryTrigger(this.engine);
    this.notifyTrigger = buildNotifyTrigger(this.engine);
    this.smartSnippet = buildSmartSnippet(this.engine);
    this.smartSnippetQuestionsList = buildSmartSnippetQuestionsList(
      this.engine
    );
    this.fieldSuggestionsAuthor = buildFieldSuggestions(this.engine, {
      options: { facet: { field: "author", facetId: "author-2" } }
    });
    this.categoryFieldSuggestions = buildCategoryFieldSuggestions(this.engine, {
      options: {
        facet: {
          field: "geographicalhierarchy",
          facetId: "geographicalhierarchy-3"
        }
      }
    });
    this.recentQueriesList = buildRecentQueriesList(this.engine);
    this.recentResultsList = buildRecentResultsList(this.engine);
    const sharedIdBetweenSearchboxAndInstantResult = "sample-instant-results";
    this.instantResults = buildInstantResults(this.engine, {
      options: {
        maxResultsPerQuery: 5,
        searchBoxId: sharedIdBetweenSearchboxAndInstantResult
      }
    });
    this.searchboxInstantResults = buildSearchBox(this.engine, {
      options: {
        id: sharedIdBetweenSearchboxAndInstantResult
      }
    });
  }
  initEngine(props) {
    if (props.engine) {
      this.engine = props.engine;
      return;
    }
    this.engine = buildSearchEngine({
      configuration: getSampleSearchEngineConfiguration(),
      preloadedState: window.HEADLESS_STATE
    });
  }
  componentDidMount() {
    this.unsubscribeUrlManager = bindUrlManager(this.engine);
    this.unsubscribeExecuteTrigger = bindExecuteTrigger(this.engine);
    this.executeInitialSearch();
  }
  componentWillUnmount() {
    this.unsubscribeUrlManager();
    this.unsubscribeExecuteTrigger();
  }
  get messageExpression() {
    return buildQueryExpression().addStringField({
      field: "objecttype",
      operator: "isExactly",
      values: ["Message"]
    }).toQuerySyntax();
  }
  get confluenceExpression() {
    return buildQueryExpression().addStringField({
      field: "connectortype",
      operator: "isExactly",
      values: ["Confluence2Crawler"]
    }).addStringField({
      field: "documenttype",
      operator: "isExactly",
      values: ["Space"],
      negate: true
    }).toQuerySyntax();
  }
  executeInitialSearch() {
    if (isServerSideRendered) {
      const { logInterfaceLoad: logInterfaceLoad2 } = loadSearchAnalyticsActions(this.engine);
      this.engine.dispatch(logInterfaceLoad2());
      return;
    }
    const data = localStorage.getItem(standaloneSearchBoxStorageKey);
    if (data) {
      this.executeFirstSearchAfterStandaloneSearchBoxRedirect(data);
      return;
    }
    this.engine.executeFirstSearch();
  }
  executeFirstSearchAfterStandaloneSearchBoxRedirect(data) {
    localStorage.removeItem(standaloneSearchBoxStorageKey);
    const parsed = JSON.parse(data);
    const { value, analytics } = parsed;
    const { updateQuery: updateQuery2 } = loadQueryActions(this.engine);
    this.engine.dispatch(updateQuery2({ q: value }));
    this.engine.executeFirstSearchAfterStandaloneSearchBoxRedirect(analytics);
  }
  get staticFilterValues() {
    const youtubeExpression = buildQueryExpression().addStringField({
      field: "filetype",
      operator: "isExactly",
      values: ["youtubevideo"]
    }).toQuerySyntax();
    const dropboxExpression = buildQueryExpression().addStringField({
      field: "connectortype",
      operator: "isExactly",
      values: ["DropboxCrawler"]
    }).addStringField({
      field: "objecttype",
      operator: "isExactly",
      values: ["File"]
    }).toQuerySyntax();
    return [
      buildStaticFilterValue({
        caption: "Youtube",
        expression: youtubeExpression
      }),
      buildStaticFilterValue({
        caption: "Dropbox",
        expression: dropboxExpression
      })
    ];
  }
  render() {
    return /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs(AppContext.Provider, { value: { engine: this.engine }, children: [
      /* @__PURE__ */ jsx(Context, {}),
      /* @__PURE__ */ jsx(DictionaryFieldContext, {}),
      /* @__PURE__ */ jsxs(Section, { title: "tabs", children: [
        /* @__PURE__ */ jsxs("nav", { children: [
          /* @__PURE__ */ jsx(Tab$1, { id: "all", expression: "", active: true, children: "All" }),
          /* @__PURE__ */ jsx(Tab$1, { id: "messages", expression: this.messageExpression, children: "Messages" }),
          /* @__PURE__ */ jsx(Tab$1, { id: "confluence", expression: this.confluenceExpression, children: "Confluence" })
        ] }),
        /* @__PURE__ */ jsxs("nav", { children: [
          /* @__PURE__ */ jsx(Tab2, { controller: this.tabs.all, children: "All" }),
          /* @__PURE__ */ jsx(Tab2, { controller: this.tabs.messages, children: "Messages" }),
          /* @__PURE__ */ jsx(Tab2, { controller: this.tabs.confluence, children: "Confluence" })
        ] })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "breadcrumb-manager", children: [
        /* @__PURE__ */ jsx(BreadcrumbManager$1, {}),
        /* @__PURE__ */ jsx(BreadcrumbManager2, { controller: this.breadcrumbManager })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "search-box", children: [
        /* @__PURE__ */ jsx(SearchBox, {}),
        /* @__PURE__ */ jsx(SearchBox$1, { controller: this.searchBox })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "field-suggestions", children: [
        /* @__PURE__ */ jsx(FieldSuggestions$1, { field: "author", facetId: "author-1" }),
        /* @__PURE__ */ jsx(FieldSuggestions2, { controller: this.fieldSuggestionsAuthor })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "category-field-suggestions", children: [
        /* @__PURE__ */ jsx(
          CategoryFieldSuggestions$1,
          {
            field: "geographicalhierarchy",
            facetId: "geographicalhierarchy-4"
          }
        ),
        /* @__PURE__ */ jsx(CategoryFieldSuggestions2, { controller: this.categoryFieldSuggestions })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "did-you-mean", children: [
        /* @__PURE__ */ jsx(DidYouMean$1, {}),
        /* @__PURE__ */ jsx(DidYouMean2, { controller: this.didYouMean })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "search-status", children: [
        /* @__PURE__ */ jsx(SearchStatus$1, {}),
        /* @__PURE__ */ jsx(SearchStatus2, { controller: this.searchStatus })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "query-error", children: [
        /* @__PURE__ */ jsx(QueryError$1, {}),
        /* @__PURE__ */ jsx(QueryError2, { controller: this.queryError })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "query-summary", children: [
        /* @__PURE__ */ jsx(QuerySummary$1, {}),
        /* @__PURE__ */ jsx(QuerySummary2, { controller: this.querySummary })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "static filter", children: [
        /* @__PURE__ */ jsx(StaticFilter$1, { id: "filetypes-a", values: this.staticFilterValues }),
        /* @__PURE__ */ jsx(StaticFilter2, { id: "filetypes-b", values: this.staticFilterValues })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "facet", children: [
        /* @__PURE__ */ jsx(AutomaticFacetGenerator$1, { desiredCount: 5 }),
        /* @__PURE__ */ jsxs(FacetManager$1, { children: [
          /* @__PURE__ */ jsx(
            CategoryFacet$1,
            {
              field: "geographicalhierarchy",
              facetId: "geographicalhierarchy-1"
            }
          ),
          /* @__PURE__ */ jsx(Facet, { field: "author", facetId: "author-1" }),
          /* @__PURE__ */ jsx(
            NumericFacet$1,
            {
              format: (bytes) => formatFileSize(bytes),
              field: "size",
              facetId: "size-1",
              generateAutomaticRanges: true
            }
          ),
          /* @__PURE__ */ jsx(
            NumericFacet$1,
            {
              format: (bytes) => formatFileSize(bytes),
              field: "size",
              facetId: "size-2",
              generateAutomaticRanges: false,
              currentValues: [
                buildNumericRange({ start: 0, end: 5 * KB }),
                buildNumericRange({ start: 5 * KB, end: 5 * MB }),
                buildNumericRange({ start: 5 * MB, end: 5 * GB })
              ]
            }
          ),
          /* @__PURE__ */ jsx(NumericFilter$1, { field: "size", facetId: "size-5" }),
          /* @__PURE__ */ jsx(
            DateFacet$1,
            {
              field: "date",
              facetId: "date-1",
              generateAutomaticRanges: true
            }
          ),
          /* @__PURE__ */ jsx(
            DateFacet$1,
            {
              field: "date",
              facetId: "date-2",
              generateAutomaticRanges: false,
              currentValues: dateRanges
            }
          ),
          /* @__PURE__ */ jsx(
            RelativeDateFacet$1,
            {
              field: "date",
              facetId: "date-6",
              generateAutomaticRanges: false,
              currentValues: relativeDateRanges
            }
          ),
          /* @__PURE__ */ jsx(DateFilter$1, { field: "date", facetId: "date-3" })
        ] }),
        /* @__PURE__ */ jsx(
          AutomaticFacetGenerator2,
          {
            controller: this.automaticFacetGenerator
          }
        ),
        /* @__PURE__ */ jsxs(FacetManager2, { controller: this.facetManager, children: [
          /* @__PURE__ */ jsx(CategoryFacet2, { controller: this.geographyFacet }),
          /* @__PURE__ */ jsx(Facet$1, { controller: this.objectTypeFacet }),
          /* @__PURE__ */ jsx(
            NumericFacet2,
            {
              controller: this.fileSizeAutomaticNumericFacet,
              format: (bytes) => formatFileSize(bytes)
            }
          ),
          /* @__PURE__ */ jsx(
            NumericFacet2,
            {
              controller: this.fileSizeManualNumericFacet,
              format: (bytes) => formatFileSize(bytes)
            }
          ),
          /* @__PURE__ */ jsx(NumericFilter2, { controller: this.fileSizeNumericFilter }),
          /* @__PURE__ */ jsx(DateFacet2, { controller: this.dateAutomaticDateFacet }),
          /* @__PURE__ */ jsx(DateFacet2, { controller: this.dateManualDateFacet }),
          /* @__PURE__ */ jsx(RelativeDateFacet2, { controller: this.dateRelativeDateFacet }),
          /* @__PURE__ */ jsx(DateFilter2, { controller: this.dateFilter })
        ] })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "sort", children: [
        /* @__PURE__ */ jsx(Sort$1, { criteria, initialCriterion }),
        /* @__PURE__ */ jsx(Sort2, { controller: this.sort, criteria })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "result-list", children: [
        /* @__PURE__ */ jsx(ResultList$1, {}),
        /* @__PURE__ */ jsx(ResultList2, { controller: this.resultList })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "smart-snippet", children: [
        /* @__PURE__ */ jsx(SmartSnippet$1, {}),
        /* @__PURE__ */ jsx(SmartSnippet2, { controller: this.smartSnippet })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "smart-snippet-questions-list", children: [
        /* @__PURE__ */ jsx(SmartSnippetQuestionsList$1, {}),
        /* @__PURE__ */ jsx(
          SmartSnippetQuestionsList2,
          {
            controller: this.smartSnippetQuestionsList
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "folded-result-list", children: [
        /* @__PURE__ */ jsx(FoldedResultList$1, {}),
        /* @__PURE__ */ jsx(FoldedResultList2, { controller: this.foldedResultList })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "results-per-page", children: [
        /* @__PURE__ */ jsx(ResultsPerPage$1, { options: resultsPerPageOptions }),
        /* @__PURE__ */ jsx(
          ResultsPerPage2,
          {
            controller: this.resultsPerPage,
            options: resultsPerPageOptions
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "pager", children: [
        /* @__PURE__ */ jsx(Pager$1, {}),
        /* @__PURE__ */ jsx(Pager2, { controller: this.pager })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "history-manager", children: [
        /* @__PURE__ */ jsx(HistoryManager$1, {}),
        /* @__PURE__ */ jsx(HistoryManager2, { controller: this.historyManager })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "relevance-inspector", children: [
        /* @__PURE__ */ jsx(RelevanceInspector$1, {}),
        /* @__PURE__ */ jsx(RelevanceInspector2, { controller: this.relevanceInspector })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "redirection-trigger", children: [
        /* @__PURE__ */ jsx(RedirectionTrigger$1, {}),
        /* @__PURE__ */ jsx(
          RedirectionTrigger2,
          {
            controller: this.redirectionTrigger
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "query-trigger", children: [
        /* @__PURE__ */ jsx(QueryTrigger$1, {}),
        /* @__PURE__ */ jsx(QueryTrigger2, { controller: this.queryTrigger })
      ] }),
      /* @__PURE__ */ jsx(Section, { title: "execute-trigger", children: /* @__PURE__ */ jsx(ExecuteTrigger, {}) }),
      /* @__PURE__ */ jsxs(Section, { title: "notify-trigger", children: [
        /* @__PURE__ */ jsx(NotifyTrigger$1, {}),
        /* @__PURE__ */ jsx(NotifyTrigger2, { controller: this.notifyTrigger })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "recent-queries-list", children: [
        /* @__PURE__ */ jsx(RecentQueriesList$1, { maxLength: 10 }),
        /* @__PURE__ */ jsx(RecentQueriesList2, { controller: this.recentQueriesList })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "recent-results-list", children: [
        /* @__PURE__ */ jsx(RecentResultsList$1, { maxLength: 10 }),
        /* @__PURE__ */ jsx(RecentResultsList2, { controller: this.recentResultsList })
      ] }),
      /* @__PURE__ */ jsxs(Section, { title: "instant-results-list", children: [
        /* @__PURE__ */ jsx(InstantResults$1, {}),
        /* @__PURE__ */ jsx(
          InstantResults2,
          {
            controllerInstantResults: this.instantResults,
            controllerSearchbox: this.searchboxInstantResults
          }
        )
      ] })
    ] }) });
  }
}
let StandaloneSearchBox$1 = class StandaloneSearchBox extends Component {
  static contextType = AppContext;
  context;
  controller;
  unsubscribe = () => {
  };
  componentDidMount() {
    this.controller = buildStandaloneSearchBox(this.context.engine, {
      options: { redirectionUrl: "/search-page" }
    });
    this.updateState();
    this.unsubscribe = this.controller.subscribe(() => this.updateState());
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  componentDidUpdate() {
    const { redirectTo, value, analytics } = this.state;
    if (!redirectTo) {
      return;
    }
    const data = JSON.stringify({ value, analytics });
    localStorage.setItem(standaloneSearchBoxStorageKey, data);
    window.location.href = redirectTo;
  }
  updateState() {
    this.setState(this.controller.state);
  }
  isEnterKey(e) {
    return e.key === "Enter";
  }
  render() {
    if (!this.state) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          value: this.state.value,
          onChange: (e) => this.controller.updateText(e.target.value),
          onKeyDown: (e) => this.isEnterKey(e) && this.controller.submit()
        }
      ),
      /* @__PURE__ */ jsx("ul", { children: this.state.suggestions.map((suggestion) => {
        const value = suggestion.rawValue;
        return /* @__PURE__ */ jsx(
          "li",
          {
            onClick: () => this.controller.selectSuggestion(value),
            onKeyDown: (e) => {
              if (e.key === "Enter" || e.key === " ") {
                this.controller.selectSuggestion(value);
              }
            },
            children: value
          },
          value
        );
      }) })
    ] });
  }
};
const StandaloneSearchBox2 = (props) => {
  const { engine } = useContext(AppContext);
  const controller = buildStandaloneSearchBox(engine, { options: props });
  const [state, setState] = useState(controller.state);
  useEffect(() => controller.subscribe(() => setState(controller.state)), []);
  function isEnterKey(e) {
    return e.key === "Enter";
  }
  if (!state) {
    return null;
  }
  if (state.redirectTo) {
    const { redirectTo, value, analytics } = state;
    const data = JSON.stringify({ value, analytics });
    localStorage.setItem(standaloneSearchBoxStorageKey, data);
    window.location.href = redirectTo;
    return null;
  }
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx(
      "input",
      {
        value: state.value,
        onChange: (e) => controller.updateText(e.target.value),
        onKeyDown: (e) => isEnterKey(e) && controller.submit()
      }
    ),
    /* @__PURE__ */ jsx("ul", { children: state.suggestions.map((suggestion) => {
      const value = suggestion.rawValue;
      return /* @__PURE__ */ jsx(
        "li",
        {
          onClick: () => controller.selectSuggestion(value),
          onKeyDown: (e) => {
            if (e.key === "Enter" || e.key === " ") {
              controller.selectSuggestion(value);
            }
          },
          children: value
        },
        value
      );
    }) })
  ] });
};
function StandaloneSearchBoxPage() {
  const engine = useMemo(
    () => buildSearchEngine({
      configuration: getSampleSearchEngineConfiguration()
    }),
    []
  );
  return /* @__PURE__ */ jsx(AppContext.Provider, { value: { engine }, children: /* @__PURE__ */ jsxs(Section, { title: "standalone-search-box", children: [
    /* @__PURE__ */ jsx(StandaloneSearchBox$1, {}),
    /* @__PURE__ */ jsx(StandaloneSearchBox2, { id: "ssb-1", redirectionUrl: "/search-page" })
  ] }) });
}
function App(props) {
  const activeNavLink = { color: "red" };
  return /* @__PURE__ */ jsx(BrowserRouter, { children: /* @__PURE__ */ jsxs("main", { className: "App", children: [
    /* @__PURE__ */ jsxs("nav", { children: [
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          end: true,
          to: "/",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Search"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/recommendation",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Recommendation"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/standalone-search-box",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Standalone Search Box"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/about",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "About"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/saml",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Saml"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/dependent-facet",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Dependent facet"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/analyticshooks",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Analytics hook (Google Tag Manager)"
        }
      ) }),
      /* @__PURE__ */ jsx("button", { children: /* @__PURE__ */ jsx(
        NavLink,
        {
          to: "/commerce",
          style: ({ isActive }) => isActive ? activeNavLink : {},
          children: "Commerce"
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxs(Routes, { children: [
      /* @__PURE__ */ jsx(Route, { path: "/recommendation", element: /* @__PURE__ */ jsx(RecommendationPage, {}) }),
      /* @__PURE__ */ jsx(
        Route,
        {
          path: "/standalone-search-box",
          element: /* @__PURE__ */ jsx(StandaloneSearchBoxPage, {})
        }
      ),
      /* @__PURE__ */ jsx(Route, { path: "/about", element: /* @__PURE__ */ jsx(AboutPage, {}) }),
      /* @__PURE__ */ jsx(Route, { path: "/saml", element: /* @__PURE__ */ jsx(SamlPage, {}) }),
      /* @__PURE__ */ jsx(Route, { path: "/dependent-facet", element: /* @__PURE__ */ jsx(DependentFacetPage, {}) }),
      /* @__PURE__ */ jsx(Route, { path: "/analyticshooks", element: /* @__PURE__ */ jsx(AnalyticsHook, {}) }),
      /* @__PURE__ */ jsxs(Route, { path: "/commerce", element: /* @__PURE__ */ jsx(CommerceApp, {}), children: [
        /* @__PURE__ */ jsx(Route, { path: "search", element: /* @__PURE__ */ jsx(SearchPage$1, {}) }),
        /* @__PURE__ */ jsx(Route, { path: "product-listing", element: /* @__PURE__ */ jsx(ProductListingPage, {}) }),
        /* @__PURE__ */ jsx(Route, { path: "recommendations", element: /* @__PURE__ */ jsx(RecommendationsPage, {}) })
      ] }),
      /* @__PURE__ */ jsx(Route, { path: "/search-page", element: /* @__PURE__ */ jsx(SearchPage, { ...props }) }),
      /* @__PURE__ */ jsx(Route, { path: "/", element: /* @__PURE__ */ jsx(SearchPage, { ...props }) })
    ] })
  ] }) });
}
const PORT = 3e3;
const app = express();
app.get("/", async (_req, res2) => {
  const engine = buildSearchEngine({
    configuration: getSampleSearchEngineConfiguration()
  });
  renderServerSide(engine);
  await firstSearchExecuted(engine);
  const app2 = renderServerSide(engine);
  const indexFile = require$$2$2.resolve("./build/index.html");
  fs.readFile(indexFile, "utf8", (err2, data) => {
    if (err2) {
      console.error("Something went wrong:", err2);
      return res2.status(500).send("Internal error");
    }
    const state = escapeHtml$1(JSON.stringify(engine.state));
    const page = data.replace('<div id="root"></div>', `<div id="root">${app2}</div>`).replace(
      '<script id="ssr"><\/script>',
      `<script id="ssr">window.HEADLESS_STATE = ${state}<\/script>`
    );
    return res2.send(page);
  });
});
function renderServerSide(engine) {
  return ReactDOMServer.renderToString(/* @__PURE__ */ jsx(App, { engine }));
}
function firstSearchExecuted(engine) {
  return new Promise((resolve) => {
    const searchStatus = buildSearchStatus(engine);
    const unsubscribe = searchStatus.subscribe(() => {
      if (searchStatus.state.firstSearchExecuted) {
        unsubscribe();
        resolve(true);
      }
    });
    engine.executeFirstSearch();
  });
}
app.use(express.static("./build"));
app.listen(PORT, () => {
  console.log(`Server is listening on port ${PORT}`);
});
