import {execSync} from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import {fileURLToPath} from 'node:url';
import ts from 'typescript';
import colors from '../../../utils/ci/colors.mjs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const componentsDir = path.resolve(__dirname, '../src/components');
const outputFile = path.resolve(
  __dirname,
  '../src/utils/custom-element-tags.ts'
);

/**
 * Extracts custom element tag names from component files using TypeScript AST.
 * Only extracts Lit components: @customElement('tag-name')
 * Stencil components are skipped as they lazy-load and don't require tracking.
 *
 * Uses AST parsing to avoid picking up decorator usage in JSDoc comments.
 */
function extractCustomElementTags() {
  const tags = new Set();

  function scanDirectory(dir) {
    const entries = fs.readdirSync(dir, {withFileTypes: true});

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        scanDirectory(fullPath);
      } else if (
        entry.isFile() &&
        (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx')) &&
        !entry.name.includes('.spec.') &&
        !entry.name.includes('.stories.') &&
        !entry.name.includes('.e2e.')
      ) {
        const content = fs.readFileSync(fullPath, 'utf-8');
        const sourceFile = ts.createSourceFile(
          fullPath,
          content,
          ts.ScriptTarget.Latest,
          true
        );

        visitNode(sourceFile);
      }
    }
  }

  function visitNode(node) {
    // Check if this is a class declaration with decorators
    if (ts.isClassDeclaration(node) && node.modifiers) {
      for (const modifier of node.modifiers) {
        if (ts.isDecorator(modifier)) {
          const tagName = extractTagFromDecorator(modifier);
          if (tagName) {
            tags.add(tagName);
          }
        }
      }
    }

    ts.forEachChild(node, visitNode);
  }

  function extractTagFromDecorator(decorator) {
    const expression = decorator.expression;

    // Handle @customElement('tag-name')
    if (
      ts.isCallExpression(expression) &&
      ts.isIdentifier(expression.expression) &&
      expression.expression.text === 'customElement'
    ) {
      const arg = expression.arguments[0];
      if (arg && ts.isStringLiteral(arg)) {
        return arg.text;
      }
    }

    return null;
  }

  scanDirectory(componentsDir);
  return Array.from(tags).sort();
}

/**
 * Generates a TypeScript file with a set of all custom element tags.
 */
export function generateCustomElementTags() {
  console.log(colors.blue('Extracting custom element tags...'));

  const tags = extractCustomElementTags();

  console.log(colors.green(`Found ${tags.length} custom element tags`));

  const fileContent = `// Auto-generated file - DO NOT EDIT
// This file is generated by scripts/generate-custom-element-tags.mjs

/**
 * Set of all custom element tags defined in the Atomic library.
 * This is generated at build time from @customElement decorators (Lit components only).
 * Stencil components are excluded as they lazy-load.
 */
export const ATOMIC_CUSTOM_ELEMENT_TAGS = new Set<string>([
${tags.map((tag) => `  '${tag}',`).join('\n')}
]);

/**
 * Waits for all Atomic custom element children to be defined.
 * This ensures that all vanilla (non-framework) Atomic components have been
 * registered with the custom elements registry before proceeding.
 * 
 * @param host - The host element to scan for Atomic children
 */
export async function waitForAtomicChildrenToBeDefined(
  host: Element
): Promise<void> {
  await Promise.all(
    Array.from(host.querySelectorAll('*'))
      .filter((el) => ATOMIC_CUSTOM_ELEMENT_TAGS.has(el.tagName.toLowerCase()))
      .map((el) => customElements.whenDefined(el.tagName.toLowerCase()))
  );
}
`;

  fs.writeFileSync(outputFile, fileContent, 'utf-8');
  console.log(colors.green(`Generated ${outputFile}`));

  // Format the generated file with biome
  console.log(colors.blue('Formatting with biome...'));
  execSync(`npx @biomejs/biome format --write ${outputFile}`);
  console.log(colors.green('Formatting complete'));
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  generateCustomElementTags();
}
