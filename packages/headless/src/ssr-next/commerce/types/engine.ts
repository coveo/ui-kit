import type {UnknownAction} from '@reduxjs/toolkit';
import type {Controller} from '../../../controllers/controller/headless-controller.js';
import type {ControllersMap} from '../../common/types/controllers.js';
import type {EngineStaticState} from '../../common/types/engine.js';
import type {SSRCommerceEngine} from '../factories/build-factory.js';
import type {SSRCommerceEngineOptions} from './build.js';
import type {SolutionType} from './controller-constants.js';
import type {
  BakedInControllers,
  ControllerDefinitionsMap,
} from './controller-definitions.js';
import type {
  InferControllerPropsMapFromDefinitions,
  InferControllerStaticStateMapFromDefinitionsWithSolutionType,
  InferControllersMapFromDefinition,
} from './controller-inference.js';
import type {FetchStaticState} from './fetch-static-state.js';
import type {
  HydrateStaticState,
  HydrateStaticStateOptions,
} from './hydrate-static-state.js';

export type {
  HydrateStaticState,
  HydrateStaticStateOptions,
  FetchStaticState,
  EngineStaticState,
};

type ReservedControllerNames = 'context' | 'parameterManager' | 'cart';

type ValidateControllerNames<T extends ControllerDefinitionsMap<Controller>> = {
  [K in keyof T]: K extends ReservedControllerNames
    ? `ERROR: Controller name "${K & string}" is reserved and cannot be used. Reserved names are: context, parameterManager, cart. Please choose a different controller name.`
    : T[K];
};

/**
 * The options to create a Commerce engine definition in SSR.
 */
export type CommerceEngineDefinitionOptions<
  TControllers extends
    ControllerDefinitionsMap<Controller> = ControllerDefinitionsMap<Controller>,
> = SSRCommerceEngineOptions & {
  /**
   * The controllers to initialize with the commerce engine.
   */
  controllers?: ValidateControllerNames<TControllers>;
  /**
   * Callback invoked when the access token changes.
   */
  onAccessTokenUpdate?: (updateCallback: (token: string) => void) => void;
};

export interface CommerceEngineDefinition<
  TControllers extends ControllerDefinitionsMap<Controller>,
  TSolutionType extends SolutionType,
> {
  /**
   * Executes a commerce search/listing/recommendation request on the server side and returns the static state.
   *
   * This method performs the initial commerce request based on the solution type, captures the response,
   * and returns a serializable state snapshot that can be transferred to the client for hydration.
   *
   * The returned static state includes controller states (facets, products, pagination, etc.)
   *
   * @param params - A configuration object containing navigation context, search parameters,
   *                 cart state, and controller-specific props
   * @returns A Promise that resolves to the static state containing controller states
   *
   * @example
   * ```typescript
   * // For a search page
   * const staticState = await searchEngineDefinition.fetchStaticState({
   *   navigatorContext: { ... },
   *   context: { ... },
   *   searchParams: { q: 'running shoes' }
   * });
   *
   * // For recommendations
   * const staticState = await recommendationEngineDefinition.fetchStaticState({
   *   navigatorContext: { ... },
   *   context: { ... },
   *   recommendations: ['popularProducts'],
   *   productId: 'abc123'
   * });
   * ```
   */
  fetchStaticState: FetchStaticState<
    UnknownAction,
    InferControllerStaticStateMapFromDefinitionsWithSolutionType<
      TControllers,
      TSolutionType
    >,
    InferControllerPropsMapFromDefinitions<TControllers>,
    TControllers,
    TSolutionType
  >;
  /**
   * Creates a commerce engine on the client side from the server-side static state.
   *
   * This method is used for client-side hydration in SSR scenarios. It takes the static state
   * generated by `fetchStaticState()` on the server and reconstructs a live commerce engine
   * with all controllers in the exact same state as they were on the server.
   *
   * The hydration process:
   * - Recreates the engine with the same configuration
   * - Restores all controller states from the static state
   * - Replays search/listing/recommendation actions to synchronize the state
   * - Returns live, interactive controllers ready for user interaction
   *
   * @param params - A configuration object containing the static state, navigation context,
   *                 and any controller-specific props needed for hydration
   * @returns A Promise that resolves to the hydrated engine and interactive controllers
   *
   * @example
   * ```typescript
   * // Client-side hydration
   * const result = await engineDefinition.hydrateStaticState(staticState);
   *
   * // Controllers are now interactive
   * result.controllers.productListing.sort({ criterion: 'price' });
   * ```
   */
  hydrateStaticState: HydrateStaticState<
    InferControllersMapFromDefinition<TControllers, TSolutionType>,
    UnknownAction,
    InferControllerPropsMapFromDefinitions<TControllers>,
    TControllers,
    TSolutionType
  >;
  /**
   * Returns the access token.
   */
  getAccessToken: () => string;

  /**
   * Updates the access token.
   * @param accessToken - The access token to update.
   */
  setAccessToken: (accessToken: string) => void;
}

export interface CommerceEngineDefinitionBuildResult<
  TControllers extends ControllersMap,
> {
  engine: SSRCommerceEngine;
  controllers: TControllers & BakedInControllers;
}

export type CommerceControllerDefinitionsMap =
  ControllerDefinitionsMap<Controller>;

type Definition<
  TControllerDefinitions extends CommerceControllerDefinitionsMap,
  TSolutionType extends SolutionType,
> = CommerceEngineDefinition<TControllerDefinitions, TSolutionType>;

type FetchStaticStateFunction<
  TControllerDefinitions extends CommerceControllerDefinitionsMap,
  TSolutionType extends SolutionType,
> = Definition<TControllerDefinitions, TSolutionType>['fetchStaticState'];

export type HydrateStaticStateFunction<
  TControllerDefinitions extends CommerceControllerDefinitionsMap,
  TSolutionType extends SolutionType,
> = Definition<TControllerDefinitions, TSolutionType>['hydrateStaticState'];

export type FetchStaticStateParameters<
  TControllerDefinitions extends CommerceControllerDefinitionsMap,
  TSolutionType extends SolutionType,
> = Parameters<
  FetchStaticStateFunction<TControllerDefinitions, TSolutionType>
>[0];

export type HydrateStaticStateParameters<
  TControllerDefinitions extends CommerceControllerDefinitionsMap,
  TSolutionType extends SolutionType,
> = Parameters<
  HydrateStaticStateFunction<TControllerDefinitions, TSolutionType>
>[0];
